分布式的版本控制会不会造成开发中的无序，导致版本管理的崩溃？对于习惯了如 Subversion 这类的集中式版本控制系统的用户，脑子里一定会有这个疑问。

作为分布式版本控制系统，每一个 Git 克隆都是一个完整的版本库，可以提供一个版本控制服务器所能提供的一切服务，即每个人的机器都是一台服务器。与之相反，像 Subversion 那样的集中式版本控制系统，只拥有唯一的版本控制服务器，所有团队成员都使用客户端与之交互，大部分操作要通过网络传输来实现。对于习惯了和唯一服务器交互的团队，转换到 Git 后，该如何协同团队的工作呢？在下面“经典Git协同模型”一章会介绍集中式和金字塔式两种主要的协同工作模型。

基于某个项目进行二次开发，需要使用不同的工作模型。原始的项目称为上游项目，不能直接在上游项目中提交，可能是因为授权的原因或者是因为目标用户的需求不同。这种基于上游项目进行二次开发，实际上是对各个独特的功能分支进行管理，同时又能对上游项目的开发进度进行兼收并蓄式的合并。“Topgit 协同模型” 会重点介绍这一方面的内容。

多个版本库组成一个项目，在实际应用中并不罕见。一部分原因可能是版本库需要依赖第三方的版本库，这时 “子模组协同模型” 就可以派上用场。有的时候还要对第三方的版本库进行定制，“子树合并” 提供了一个解决方案。有的时候，为了管理方便（授权或者项目确实太庞杂），多个版本库共同组成一个大的项目，例如 Google Android 项目就是由近200个版本库组成的。“Android 式多版本库协同” 提供了一个非常有趣的解决方案，解决了“子模组协同模型”的管理上的难题。

在本部分的最后，会介绍 git-svn 这一工具。可能因为公司对代码严格的授权要求，而不能将公司的版本控制服务器从 Subversion 迁移到 Git（实际可以通过对Git版本库细粒度拆分实现授权管理），可是这并不能阻止个人使用 git-svn 作为前端工具操作 Subversion 版本库。git-svn 可以让 git 和 subversion 完美的协同工作。

经典Git协同模型
****************

集中式协同模型
===============

可以像集中式版本控制系统那样使用 Git，在一个大家都可以访问到的服务器上架设 Git 服务器，每个人从该服务器克隆代码，本地提交推送到服务器上。


  .. figure:: images/git-model/central-model.png
     :scale: 100

     图：集中式协同模型


回忆一下在使用 Subversion 等集中式版本控制系统时，对服务器管理上的要求：

* 只允许拥有帐号的用户访问版本库。
* 甚至只允许用户访问版本库中的某些路径，其它路径不能访问。
* 特定目录只允许特定用户执行写操作。
* 服务器可以通过钩子实现特殊功能，如对 commit log 的检查，数据镜像等。

对于这些需求，Git 大部分都能支持，甚至能够做到更多：

* 能够授权谁能够访问版本库，谁不能访问版本库。
* 具有更为丰富的写操作授权。可以限制哪些分支不允许写，哪些路径不允许写。
* 可以设置谁可以创建新的分支。
* 可以设置谁可以创建新的版本库。
* 可以设置谁可以强制更新。
* 服务器端同样支持钩子脚本。

但是也要承认，在“读授权”上 Git 做不到很精细，这也是分布式版本控制机制使然。按模块分解 Git 版本库，并结合后面介绍的多版本库协同解决方案可以克服 Git 读授权的局限。

* Git 不支持对版本库读取的精确授权，只能是非零即壹的授权。即或者能够读取一个版本库的全部，或者什么也读不到。
* 因为 Git 的提交是一个整体，提交中包含了完整目录树（tree）的哈希，因此完整性不容破坏。
* Git 是分布式版本控制系统，如果允许不完整的克隆，那么本地就是截然不同的版本库，在向服务器推送的时候，会被拒绝或者产生新的分支。

**用 Gitolite 架设集中式的 Git 服务器**

对于集中式的工作模型的核心就是架设集中式的 Git 服务器，而且尽量能够满足前面提到的对授权和版本库管理上的需求。在本书下一部分介绍服务器部署的时候，会介绍用 Gitolite 架设 Git 服务器，可以实现集中式协同模型对版本库授权和管理上的要求。

使用集中协同模型
-----------------

对于简单的代码修改，可以像传统集中式版本控制系统（Subversion）中那样工作：


.. figure:: images/git-model/central-model-workflow-1.png
   :scale: 80

   图：集中式协同模型工作流1

如果对于复杂的修改（代码重构/增加复杂功能），这个工作模式就不合适了。

第一个问题是：很容易将不成熟代码带入共享的版本库，破坏共享版本库相应分支的代码稳定性。例如破坏编译、破坏每日集成。这是因为开发者克隆版本库后，直接工作在缺省的跟踪分支上，当不小心执行 `git push` 命令，就会将自己的提交推送到服务器上。

为了避免上面的问题，开发者可能会延迟推送，例如在新功能定制的整个过程（一个月）只在本地提交，而不向服务器推送，这样产生更严重的问题：数据丢失。开发者可能因为操作系统感染病毒，或者不小心的目录删除，或者硬盘故障导致工作成果的彻底丢失，这对个人和团队来说都是灾难。
  
解决这个问题的方法也很简单，就是在本地创建本地分支（功能分支），并且同时在服务器端（共享版本库）也创建自己独享的功能分支。本地提交推送到共享版本库的自己独享的分支上。当开发完成之后，将功能分支合并到主线上，推送到共享版本库，完成开发。当然如果该特性分支不再需要时需要作些清理工作。参见下面的工作流程图。

.. figure:: images/git-model/central-model-workflow-2.png
   :scale: 80

   图：集中式协同模型工作流2


Gerrit 特殊的集中协同模型
---------------------------

**传统集中式协同模型的缺点**

传统集中式协同模型的主要问题是在管理上：谁能够向版本库推送？可以信赖某人向版本库推送么？

对于在一个相对固定的团队内部使用集中式协同模型没有问题，因为大家彼此信赖，都熟悉项目相关领域。但是对于公开的项目（开源项目）来说，采用集中式的协同模型，必然只能有部分核心人员具有“写”权限，相当的有能力的参与者被拒之门外，这不利于项目的发展。因此集中式协同模型主要应用在公司范围内和商业软件开发中，而不会成为开源项目的首选。

**强制代码审核的集中式协同模型**

Android 项目采用了独树一帜的集中式管理模型 —— 通过 Gerrit 架设的审核服务器对提交进行强制审核。Android 是由大约近 200 个 Git 版本库组成的庞大的项目，为了对庞大的版本库进行管理，Android 项目开发了两个工具 repo 和 Gerrit 进行版本库的管理。其中 Gerrit 服务器为 Android 项目引入了特别的集中式协同模型。

Gerrit 服务器通过 SSH 协议管理 Git 版本库，并实现了一个 Web 界面的评审工作流。任何注册用户都可以参与到项目中来，都可以推送 Git 提交到 Gerrit 管理下的 Git 版本库（通过 Gerrit 启动的特殊端口 SSH 端口）。 Git 推送不能直接推送到分支，而是推送到特殊的引用 `refs/for/<branch-name>` ，此提交会自动转换为形如 `refs/changes/<nn>/<review-id>/<patch-set>` 的补丁集，此补丁集在 Gerrit 的 Web 界面中显示为对应的评审任务。评审任务进入审核流程，当通过相关负责人的审核后，才被接受，被合并到正式的版本库中。

在本书的下一部分介绍服务器部署的时候，会对 Gerrit 的架设和使用予以详尽的介绍。

