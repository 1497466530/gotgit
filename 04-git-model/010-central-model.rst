分布式的版本控制会不会造成开发中的无序，导致版本管理的崩溃？对于习惯了如 Subversion 这样的集中式版本控制系统的用户，脑子里一定会有这个疑问。

作为分布式版本控制系统，每一个 Git 克隆都是一个完整的版本库，可以提供一个版本控制服务器所能提供的一切服务，即每个人都是服务器。与之相反，像 Subversion 那样的集中式版本控制系统，只拥有唯一的版本控制服务器，所有团队成员都使用客户端与之交互，大部分操作要通过网络传输来实现。对于习惯了和唯一服务器交互的团队，转换到 Git 后，该如何协同团队的工作呢？在下面的 “集中式协同模型” 和 “整合管理员应用模型” 中我们会介绍两种主要的协同工作模型。

基于某个项目进行二次开发，需要使用不同的工作模型。原始的项目称为上游项目，不能直接在上游项目中提交，可能是因为授权的原因或者是因为目标用户的需求不同。这种基于上游项目进行二次开发，实际上是对各个独特的功能分支进行管理，同时又能对上游项目的开发进度进行兼收并蓄式的合并。“Topgit 协同模型” 会重点介绍这一方面的内容。

多个版本库组成一个项目，在实际应用中并不罕见。一部分原因可能是版本库需要依赖第三方的版本库，这时 “子模组协同模型” 就可以派上用场。有的时候还要对第三方的版本库进行定制，“子树合并模型” 提供了一个解决方案。有的时候，为了管理方便（授权或者项目确实太庞杂），多个版本库共同组成一个大的项目，例如 Google Android 项目就是由近200个版本库组成的。“Android 协同模型” 提供了一个非常有趣的解决方案，解决了“子模组协同模型”的管理上的难题。

集中式协同模型
==============

可以像集中式版本控制系统那样使用 Git，在唯一的服务器中架设 Git 服务器，每个人从唯一的服务器克隆代码，本地提交推送到服务器上。

::

        +--------+
        |        | <====================> user1 workspace
        | git    |
        | server | <====================> user2 workspace
        |        | push              pull
        +--------+ 

回忆一下在使用 Subversion 等集中式版本控制系统时，对服务器管理上的要求：

* 只允许拥有帐号的用户访问版本库。
* 甚至只允许用户访问版本库中的某些路径，其它路径不能访问。
* 特定目录只允许特定用户执行写操作。
* 服务器可以通过钩子实现特殊功能，如对 commit log 的检查，数据镜像等。

对于这些需求，Git 大部分都能支持，甚至能够做到更多：

* 能够授权谁能够访问版本库，谁不能访问版本库。
* 具有更为丰富的写操作授权。可以限制哪些分支不允许写，哪些路径不允许写。
* 可以设置谁可以创建新的分支。
* 可以设置谁可以创建新的版本库。
* 可以设置谁可以强制更新。
* 服务器端同样支持钩子脚本。

但是也要承认，在读授权上 Git 做的不精细，这也是分布式版本控制机制使然。

* Git 不支持对版本库读取的精确授权，只能是非零即壹的授权。即或者能够读取一个版本库的全部，或者什么也读不到。
* 因为 Git 的提交是一个整体，提交 ID 是关于提交完整目录树的哈希，完整性不容破坏。
* Git 是分布式版本控制系统，如果允许不完整的克隆，那么本地就是截然不同的版本库，在向服务器推送的时候，找不到推送的目标。

在后面介绍服务器部署的时候，会介绍用 Gitolite 架设 Git 服务器，可以实现集中式协同模型对版本库授权的要求。

Android 项目采用的则是独树一帜的集中式管理模型，通过审核服务器对提交进行管理。

Android 是由大约 160 个 Git 版本库组成的庞大的项目，为了对庞大的版本库进行管理，Android 项目开发了两个工具 repo 和 Gerrit 进行版本库的管理。其中 Gerrit 就是负责架设Web界面的提交评审服务器并提供基于 SSH 协议的 Git 服务器。向 Gerrit 启动的使用特殊端口的基于 SSH 协议的 Git 服务器提交时，要求提交到特殊的引用 refs/for/branch ，此提交会自动转换为 refs/changes/ 下的具有独立id的变更，此变更可以在 Gerrit 的 Web 审核界面显示。进入审核流程的变更通过审核后，会被合并到正式的版本库中。

我们会在服务器架设章节介绍 Gerrit 的架设和使用。

