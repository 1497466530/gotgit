作为分布式版本控制系统，每一个 Git 克隆都是一个完整的版本库，可以提供一个版本控制服务器所能提供的一切服务，即每个人都是服务器。与之相反，像 Subversion 那样的集中式版本控制系统，只拥有唯一的版本控制服务器，所有团队成员都使用客户端与之交互，大部分操作要通过网络传输来实现。对于习惯了和唯一服务器交互的团队，转换到 Git 后，该如何协同团队的工作呢？在下面的 “集中式协同模型” 和 “整合管理员应用模型” 中我们会介绍两种主要的协同工作模型。

基于某个项目进行二次开发，需要使用不同的工作模型。原始的项目称为上游项目，不能直接在上游项目中提交，可能是因为授权的原因或者是因为目标用户的需求不同。这种基于上游项目进行二次开发，实际上是对各个独特的功能分支进行管理，同时又能对上游项目的开发进度进行兼收并蓄式的合并。“Topgit 协同模型” 会重点介绍这一方面的内容。

多个版本库组成一个项目，在实际应用中并不罕见。一部分原因可能是版本库需要依赖第三方的版本库，这时 “子模组协同模型” 就可以派上用场。有的时候还要对第三方的版本库进行定制，“子树合并模型” 提供了一个解决方案。有的时候，为了管理方便（授权或者项目确实太庞杂），多个版本库共同组成一个大的项目，例如 Google Android 项目就是由近200个版本库组成的。“Android 协同模型” 提供了一个非常有趣的解决方案，解决了“子模组协同模型”的管理上的难题。

集中式协同模型
==============
