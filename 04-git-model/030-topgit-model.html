
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>4.3. Topgit协同模型 &mdash; GotGit</title>
    
    <link rel="stylesheet" href="../static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="/stylesheets/master.css" type="text/css" />
    <link rel="stylesheet" href="/stylesheets/syntax.css" type="text/css" />
    <link rel="stylesheet" href="../static/worldhello.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/translations.js"></script>
    <link rel="top" title="GotGit" href="../index.html" />
    <link rel="up" title="4. Git协同模型" href="index.html" />
    <link rel="next" title="4.4. 子模组协同模型" href="040-submodule-model.html" />
    <link rel="prev" title="4.2. 金字塔式协同模型" href="020-distribute-model.html" /> 
  </head>
  <body>
    <div id='header'>
      <h1><a href='/'>World Hello</a></h1>

      <div id='menu'>
        <ul>
          <li><a href='/' id='home-link' title='Home'>首页</a></li>
          <li><a href='/blog.html' id='blog-link' title='Blog'>博客</a></li>
          <li><a href='/doc/' id='docs-link' title='Docs'>文章</a></li>
          <li><a href='/about.html' id='about-link' title='About'>关于</a></li>
          <li><a href='http://github.com/gotgit' target='_blank' title='GitHub' rel='me' id='github-link'>GitHub</a></li>
          <li><a href='http://weibo.com/gotgit' title='微博' target='_blank' id='weibo-link'>微博</a></li>
        </ul>
      </div>
    </div>

    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="040-submodule-model.html" title="4.4. 子模组协同模型"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="020-distribute-model.html" title="4.2. 金字塔式协同模型"
             accesskey="P">上一页</a> |</li>
        <li><a href="../index.html">GotGit</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">4. Git协同模型</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">4.3. Topgit协同模型</a><ul>
<li><a class="reference internal" href="#id1">4.3.1. 作者版本控制系统三个里程碑</a></li>
<li><a class="reference internal" href="#id2">4.3.2. Topgit原理</a></li>
<li><a class="reference internal" href="#id3">4.3.3. Topgit的安装</a></li>
<li><a class="reference internal" href="#id4">4.3.4. Topgit的使用</a><ul>
<li><a class="reference internal" href="#tg-help">4.3.4.1. <strong class="command">tg help</strong>命令</a></li>
<li><a class="reference internal" href="#tg-create">4.3.4.2. <strong class="command">tg create</strong>命令</a></li>
<li><a class="reference internal" href="#tg-info">4.3.4.3. <strong class="command">tg info</strong>命令</a></li>
<li><a class="reference internal" href="#tg-update">4.3.4.4. <strong class="command">tg update</strong>命令</a></li>
<li><a class="reference internal" href="#tg-summary">4.3.4.5. <strong class="command">tg summary</strong>命令</a></li>
<li><a class="reference internal" href="#tg-remote">4.3.4.6. <strong class="command">tg remote</strong>命令</a></li>
<li><a class="reference internal" href="#tg-push">4.3.4.7. <strong class="command">tg push</strong>命令</a></li>
<li><a class="reference internal" href="#tg-depend">4.3.4.8. <strong class="command">tg depend</strong>命令</a></li>
<li><a class="reference internal" href="#tg-base">4.3.4.9. <strong class="command">tg base</strong>命令</a></li>
<li><a class="reference internal" href="#tg-delete">4.3.4.10. <strong class="command">tg delete</strong>命令</a></li>
<li><a class="reference internal" href="#tg-patch">4.3.4.11. <strong class="command">tg patch</strong>命令</a></li>
<li><a class="reference internal" href="#tg-export">4.3.4.12. <strong class="command">tg export</strong>命令</a></li>
<li><a class="reference internal" href="#tg-import">4.3.4.13. <strong class="command">tg import</strong>命令</a></li>
<li><a class="reference internal" href="#tg-log">4.3.4.14. <strong class="command">tg log</strong>命令</a></li>
<li><a class="reference internal" href="#tg-mail">4.3.4.15. <strong class="command">tg mail</strong>命令</a></li>
<li><a class="reference internal" href="#tg-graph">4.3.4.16. <strong class="command">tg graph</strong>命令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#topgit-hacks">4.3.5. Topgit hacks</a></li>
<li><a class="reference internal" href="#id5">4.3.6. Topgit使用中的注意事项</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="020-distribute-model.html"
                        title="上一章">4.2. 金字塔式协同模型</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="040-submodule-model.html"
                        title="下一章">4.4. 子模组协同模型</a></p>
  <h3>本页</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/04-git-model/030-topgit-model.txt"
           rel="nofollow">显示源代码</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>快速搜索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="转向" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    输入相关的术语，模块，类或者函数名称进行搜索
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="topgit">
<h1>4.3. Topgit协同模型<a class="headerlink" href="#topgit" title="永久链接至标题">¶</a></h1>
<p>如果没有Topgit，就不会有此书。因为发现了Topgit，才让作者下定决心在公司大范围推广Git；因为Topgit，激发了作者对Git的好奇之心。</p>
<div class="section" id="id1">
<h2>4.3.1. 作者版本控制系统三个里程碑<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>从2005年开始作者专心于开源软件的研究、定制开发和整合，在这之后的几年，一直使用Subversion做版本控制。对于定制开发工作，Subversion有一种称为卖主分支（Vendor Branch）的模式。</p>
<div class="figure">
<a class="reference internal image-reference" href="../images/topgit-branch-vendor-branch.png"><img alt="../images/topgit-branch-vendor-branch.png" src="../images/topgit-branch-vendor-branch.png" style="width: 417.0px; height: 93.0px;" /></a>
<p class="caption">图22-1：卖主分支工作模式图</p>
</div>
<p>卖主分支的工作模式如图22-1所示：</p>
<ul class="simple">
<li>图22-1由左至右，提交随着时间而递增。</li>
<li>主线trunk用于对定制开发的过程进行跟踪。</li>
<li>主线的第一个提交<tt class="docutils literal"><span class="pre">v1.0</span></tt>是导入上游（该开源软件官方版本库）发布的版本。</li>
<li>之后在<tt class="docutils literal"><span class="pre">v1.0</span></tt>提交之处建立分支，是为卖主分支（vendor branch）。</li>
<li>主线上依次进行了c1、c2两次提交，是基于v1.0进行的定制开发。</li>
<li>当上游有了新版本，提交到卖主分支上，即<tt class="docutils literal"><span class="pre">v2.0</span></tt>提交。和<tt class="docutils literal"><span class="pre">v1.0</span></tt>相比除了大量的文件更改外，还可能有文件增加和删除。</li>
<li>然后在主线上执行从卖主分支到主线的合并，即提交<tt class="docutils literal"><span class="pre">M1</span></tt>。因为此时主线上的改动相对少，合并<tt class="docutils literal"><span class="pre">v2.0</span></tt>并不太费事。</li>
<li>主线继续开发。可能同时有针对不同需求的定制开发，在主线上会有越来越多的提交，如上图从c3到c99近百次提交。</li>
<li>如果在卖主分支上导入上游的新版本<tt class="docutils literal"><span class="pre">v3.0</span></tt>，合并将会非常痛苦。因为主线上针对不同需求的定制开发已经混在在一起！</li>
</ul>
<p>实践证明，Subversion的卖主分支对于大规模的定制开发非常不适合。向上游新版本的迁移随着定制功能和提交的增多越来越困难。</p>
<p>在2008年，我们的版本库迁移到Mercurial（水银，又称为Hg），并工作在“Hg+MQ”模式下，我自以为找到了定制开发版本控制的终极解决方案，那时我们已被Subversion的卖主分支折磨的太久了。</p>
<p>Hg和Git一样也是一种分布式版本控制系统，MQ是Hg的一个扩展，可以实现提交和补丁两种模式之间的转换。Hg版本库上的提交可以通过<strong class="command">hg qimport</strong>命令转化为补丁列表，也可以通过<strong class="command">hg qpush</strong>、<strong class="command">hg qpop</strong>等命令在补丁列表上游移（出栈和入栈），入栈的补丁转化为Hg版本库的提交，补丁出栈会从Hg版本库移走最新的提交。</p>
<p>使用“Hg+MQ”相比Subversion的卖主分支的好处在于：</p>
<ul>
<li><p class="first">针对不同需求的定制开发，其提交被限定在各自独立的补丁文件之中。</p>
<p>针对同一个需求的定制开发，无论多少次的更改都体现为补丁文件的变化，而补丁文件本身也是被版本控制的。</p>
</li>
<li><p class="first">各个补丁之间是顺序依赖关系，形成一个Quilt格式的补丁列表。</p>
</li>
<li><p class="first">迁移至上游新版本的过程是：先将所有补丁“出栈”，再将上游新版本提交到主线，然后依次将补丁“入栈”。</p>
<p>因为上游新版本的代码上下文改变等原因，补丁入栈可能会遇到冲突，只要在解决冲突完毕后，执行<strong class="command">hg qref</strong>即可。</p>
</li>
<li><p class="first">向上游新版本迁移过程的工作量降低了，是因为提交都按照定制的需求分类了
（不同的补丁），每个补丁都可以视为一个功能分支。</p>
</li>
</ul>
<p>但是当需要在定制开发上进行多人协作的时候，“Hg+MQ”弊病就显现了。因为“Hg+MQ”工作模式下，定制开发的成果是一个补丁库，在补丁库上进行协作难度非常大，当发生冲突的时候，补丁文件本身的冲突解决难度相当大。这就引发了我们第三次版本控制系统大迁移。</p>
<p>2009年，目光锁定在Topgit上。TopGit的项目名称是来自于Topic Git的简写，是基于Git用脚本语言开发的辅助工具，是用于管理多个Git的特性分支的工具。Topgit可以非常简单的实现“变基”——迁移至上游新版本。</p>
<p>Topgit的主要特点有：</p>
<ul class="simple">
<li>上游代码库位于开发主线（如：<tt class="docutils literal"><span class="pre">master</span></tt>分支），每一个定制开发都对应于一条Git分支（<tt class="docutils literal"><span class="pre">refs/heads/t/feature_name</span></tt>）。</li>
<li>特性分支之间的依赖关系不像“Hg+MQ”简单的逐一依赖模式，而是可以任意设定分支之间的依赖。</li>
<li>特性分支和其依赖的分支可以转出为Quilt格式的补丁列表。</li>
<li>因为针对某一需求的定制开发在特定的分支中，可以多人协同参与，和正常的Git开发别无二致。</li>
</ul>
</div>
<div class="section" id="id2">
<h2>4.3.2. Topgit原理<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>图22-2是一个近似的Topgit实现图（略去了重要的<tt class="docutils literal"><span class="pre">top-bases</span></tt>分支）。</p>
<div class="figure">
<a class="reference internal image-reference" href="../images/topgit-topic-branch.png"><img alt="../images/topgit-topic-branch.png" src="../images/topgit-topic-branch.png" style="width: 435.0px; height: 153.0px;" /></a>
<p class="caption">图22-2：Topgit特性分支关系图</p>
</div>
<p>在图22-2中，主线上的<tt class="docutils literal"><span class="pre">v1.0</span></tt>是上游的版本的一次提交。特性分支A和C都直接依赖主线master，而特性分支B则依赖特性分支A。提交M1是特定分支B因为特性分支A更新而做的一次迁移。提交M2和M4，则分别是特性分支A和C因为上游出现了新版本<tt class="docutils literal"><span class="pre">v2.0</span></tt>而做的迁移。当然特性分支B也要做相应的迁移，是为M3。</p>
<p>上述的描述非常粗糙，因为这样的设计很难实现特性分支导出为补丁文件。例如特性分支B的补丁，实际上应该是M3和M2之间的差异，而绝不是M3到a2之间的差异。Topgit为了能够实现分支导出为补丁，又为每个特性的开发引入了一个特殊的引用（<tt class="docutils literal"><span class="pre">refs/top-bases/*</span></tt>），用于追踪分支依赖的“变基”。这些特性分支的基准分支也形成了复杂的分支关系图，如图22-3所示。</p>
<div class="figure">
<a class="reference internal image-reference" href="../images/topgit-topic-base-branch.png"><img alt="../images/topgit-topic-base-branch.png" src="../images/topgit-topic-base-branch.png" style="width: 502.0px; height: 170.0px;" /></a>
<p class="caption">图22-3：Topgit特性分支的基准分支关系图</p>
</div>
<p>把图22-2和图22-3两张分支图重合，就可以获得各个特性分支在任一点的特性补丁文件。</p>
<p>上面的特性分支B还只是依赖一个分支，如果出现一个分支依赖多个特性分支的话，情况就会更加的复杂，更会体现出这种设计方案的精妙。</p>
<p>Topgit还在每个特性分支工作区的根目录引入两个文件，用以记录分支的依赖以及关于此分支的说明。</p>
<ul>
<li><p class="first">文件<tt class="file docutils literal"><span class="pre">.topdeps</span></tt>记录该分支所依赖的分支列表。</p>
<p>该文件通过<strong class="command">tg create</strong>命令在创建特性分支时自动创建，或者通过<strong class="command">tg depend add</strong>命令来添加新依赖。</p>
</li>
<li><p class="first">文件<tt class="file docutils literal"><span class="pre">.topmsg</span></tt>记录该分支的描述信息。</p>
<p>该文件通过<strong class="command">tg create</strong>命令在创建特性分支时创建，也可以手动编辑。</p>
</li>
</ul>
</div>
<div class="section" id="id3">
<h2>4.3.3. Topgit的安装<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>Topgit的可执行命令只有一个<strong class="command">tg</strong>。其官方参考手册见：<a class="reference external" href="http://repo.or.cz/w/topgit.git?a=blob;f=README">http://repo.or.cz/w/topgit.git?a=blob;f=README</a>。</p>
<p>安装官方的Topgit版本，直接克隆官方的版本库，执行<strong class="command">make</strong>即可。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git clone git://repo.or.cz/topgit.git
$ cd topgit
$ make
$ make install
</pre></div>
</div>
<p>缺省会把可执行文件<strong class="command">tg</strong>安装在<tt class="file docutils literal"><span class="pre">$HOME/bin</span></tt>（用户主目录下的<tt class="file docutils literal"><span class="pre">bin</span></tt>目录）下，如果没有将<tt class="file docutils literal"><span class="pre">~/bin</span></tt>加入环境变量<tt class="docutils literal"><span class="pre">$PATH</span></tt>中，可能无法执行<strong class="command">tg</strong>。如果具有root权限，也可以将<strong class="command">tg</strong>安装在系统目录中。</p>
<div class="highlight-python"><div class="highlight"><pre>$ prefix=/usr make
$ sudo prefix=/usr make install
</pre></div>
</div>
<p>作者对Topgit做了一些增强和改进，在后面的章节予以介绍。如果想安装改进的版本，需要预先安装<strong class="command">quilt</strong>补丁管理工具。然后进行如下操作。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git clone git://github.com/ossxp-com/topgit.git
$ cd topgit
$ QUILT_PATCHES=debian/patches quilt push -a
$ prefix=/usr make
$ sudo prefix=/usr make install
</pre></div>
</div>
<p>如果用的是Ubuntu或者Debian Linux操作系统，还可以这么安装。</p>
<ul>
<li><p class="first">先安装Debian/Ubuntu打包依赖的相关工具软件。</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo aptitude install quilt debhelper build-essential fakeroot dpkg-dev
</pre></div>
</div>
</li>
<li><p class="first">再调用<strong class="command">dpkg-buildpackage</strong>命令，编译出DEB包，再安装。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git clone git://github.com/ossxp-com/topgit.git
$ cd topgit
$ dpkg-buildpackage -b -rfakeroot
$ sudo dpkg -i ../topgit_*.deb
</pre></div>
</div>
</li>
<li><p class="first">安装完毕后，重新加载命令行补齐，可以更方便的使用<strong class="command">tg</strong>命令。</p>
<div class="highlight-python"><div class="highlight"><pre>$ . /etc/bash_completion
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="id4">
<h2>4.3.4. Topgit的使用<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>通过前面的原理部分，可以发现Topgit为管理特性分支，所引入的配置文件和基准分支都是和Git兼容的。</p>
<ul class="simple">
<li>在<tt class="docutils literal"><span class="pre">refs/top-bases/</span></tt>命名空间下的引用，用于记录分支的变基历史。</li>
<li>在特性分支的工作区根目录引入两个文件<tt class="file docutils literal"><span class="pre">.topdeps</span></tt>和<tt class="file docutils literal"><span class="pre">.topmsg</span></tt>，用于记录分支依赖和说明。</li>
<li>引入新的钩子脚本<tt class="file docutils literal"><span class="pre">hooks/pre-commit</span></tt>，用于在提交时检查分支依赖有没有发生循环等。</li>
</ul>
<p>Topgit的命令行的一般格式为：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tg</span> <span class="p">[</span><span class="n">global_option</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">subcmd</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">command_options</span><span class="o">...</span><span class="p">]</span> <span class="p">[</span><span class="n">arguments</span><span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<ul>
<li><p class="first">在子命令前为全局选项，目前可用全局选项只有<tt class="docutils literal"><span class="pre">-r</span> <span class="pre">&lt;remote&gt;</span></tt>。</p>
<p><tt class="docutils literal"><span class="pre">-r</span> <span class="pre">&lt;remote&gt;</span></tt>可选项，用于设定分支跟踪的远程服务器。默认为<tt class="docutils literal"><span class="pre">origin</span></tt>。</p>
</li>
<li><p class="first">子命令后可以跟命令相关的可选选项，和参数。</p>
</li>
</ul>
<div class="section" id="tg-help">
<h3>4.3.4.1. <strong class="command">tg help</strong>命令<a class="headerlink" href="#tg-help" title="永久链接至标题">¶</a></h3>
<p><strong class="command">tg help</strong>命令显示帮助信息。当在<strong class="command">tg help</strong>后面提供子命令名称，可以获得该子命令详细的帮助信息。</p>
</div>
<div class="section" id="tg-create">
<h3>4.3.4.2. <strong class="command">tg create</strong>命令<a class="headerlink" href="#tg-create" title="永久链接至标题">¶</a></h3>
<p><strong class="command">tg create</strong>命令用于创建新的特性分支。用法：</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] create NAME [DEPS...|-r RNAME]
</pre></div>
</div>
<p>其中：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">NAME</span></tt>是新的特性分支的分支名，必须提供。一般约定俗成，<tt class="docutils literal"><span class="pre">NAME</span></tt>以<tt class="docutils literal"><span class="pre">t/</span></tt>前缀开头，以标明此分支是一个Topgit特性分支。</li>
<li><tt class="docutils literal"><span class="pre">DEPS...</span></tt>是可选的一个或多个依赖分支名。如果不提供依赖分支名，则使用当前分支作为新的特性分支的依赖分支。</li>
<li><tt class="docutils literal"><span class="pre">-r</span> <span class="pre">RNAME</span></tt>选项，将远程分支作为依赖分支。不常用。</li>
</ul>
<p><strong class="command">tg create</strong>命令会创建新的特性分支<tt class="docutils literal"><span class="pre">refs/heads/NAME</span></tt>，跟踪变基分支<tt class="docutils literal"><span class="pre">refs/top-bases/NAME</span></tt>，并且在项目根目录下创建文件<tt class="file docutils literal"><span class="pre">.topdeps</span></tt>和<tt class="file docutils literal"><span class="pre">.topmsg</span></tt>。会提示用户编辑<tt class="file docutils literal"><span class="pre">.topmsg</span></tt>文件，输入详细的特性分支描述信息。</p>
<p>例如在一个示例版本库，分支master下输入命令：</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg create t/feature1
tg: Automatically marking dependency on master
tg: Creating t/feature1 base from master...
Switched to a new branch &#39;t/feature1&#39;
tg: Topic branch t/feature1 set up. Please fill .topmsg now and make initial commit.
tg: To abort: git rm -f .top* &amp;&amp; git checkout master &amp;&amp; tg delete t/feature1
</pre></div>
</div>
<p>提示信息中以“tg:”开头的是Topgit产生的说明。其中提示用户编辑<tt class="file docutils literal"><span class="pre">.topmsg</span></tt>文件，然后执行一次提交完成Topgit特性分支的创建。</p>
<p>如果想撤销此次操作，删除项目根目录下的<tt class="file docutils literal"><span class="pre">.top*</span></tt>文件，切换到master分支，然后执行<strong class="command">tg delete t/feature1</strong>命令删除<tt class="docutils literal"><span class="pre">t/feature1</span></tt>分支以及变基跟踪分支<tt class="docutils literal"><span class="pre">refs/top-bases/t/feature1</span></tt>。</p>
<p>输入<strong class="command">git status</strong>可以看到当前已经切换到<tt class="docutils literal"><span class="pre">t/feature1</span></tt>分支，并且Topgit已经创建了<tt class="file docutils literal"><span class="pre">.topdeps</span></tt>和<tt class="file docutils literal"><span class="pre">.topmsg</span></tt>文件，并已将这两个文件加入到暂存区。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git status
# On branch t/feature1
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       new file:   .topdeps
#       new file:   .topmsg
#
$ cat .topdeps
master
</pre></div>
</div>
<p>打开<tt class="file docutils literal"><span class="pre">.topmsg</span></tt>文件，会看到下面内容（前面增加了行号）：</p>
<div class="highlight-python"><div class="highlight"><pre>1   From: Jiang Xin &lt;jiangxin@ossxp.com&gt;
2   Subject: [PATCH] t/feature1
3
4   &lt;patch description&gt;
5
6   Signed-off-by: Jiang Xin &lt;jiangxin@ossxp.com&gt;
</pre></div>
</div>
<p>其中第2行是关于该特性分支的简短描述，第4行是详细描述，可以写多行。</p>
<p>编辑完成，别忘了提交，提交之后才完成Topgit分支的创建。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git add -u
$ git commit -m &quot;create tg branch t/feature1&quot;
</pre></div>
</div>
<p><strong>创建时指定依赖分支</strong></p>
<p>如果这时想创建一个新的特性分支<tt class="docutils literal"><span class="pre">t/feature2</span></tt>，并且也是要依赖<tt class="docutils literal"><span class="pre">master</span></tt>，注意需要在命令行中提供<tt class="docutils literal"><span class="pre">master</span></tt>作为第二个参数，以设定依赖分支。因为当前所处的分支为<tt class="docutils literal"><span class="pre">t/feature1</span></tt>，如果不提供指定的依赖分支会自动依赖当前分子。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg create t/feature2 master
$ git commit -m &quot;create tg branch t/feature2&quot;
</pre></div>
</div>
<p>下面的命令将创建<tt class="docutils literal"><span class="pre">t/feature3</span></tt>分支，该分支依赖<tt class="docutils literal"><span class="pre">t/feature1</span></tt>和<tt class="docutils literal"><span class="pre">t/feature2</span></tt>。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg create t/feature3 t/feature1 t/feature2
$ git commit -m &quot;create tg branch t/feature3&quot;
</pre></div>
</div>
</div>
<div class="section" id="tg-info">
<h3>4.3.4.3. <strong class="command">tg info</strong>命令<a class="headerlink" href="#tg-info" title="永久链接至标题">¶</a></h3>
<p><strong class="command">tg info</strong>命令用于显示当前分支或指定的Topgit分支的信息。用法：</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] info [NAME]
</pre></div>
</div>
<p>其中<tt class="docutils literal"><span class="pre">NAME</span></tt>是可选的Topgit分支名。例如执行下面的命令会显示分支<tt class="docutils literal"><span class="pre">t/feature3</span></tt>的信息：</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg info
Topic Branch: t/feature3 (1/1 commit)
Subject: [PATCH] t/feature3
Base: 0fa79a5
Depends: t/feature1
         t/feature2
Up-to-date.
</pre></div>
</div>
<p>切换到<tt class="docutils literal"><span class="pre">t/feature1</span></tt>分支，做一些修改，并提交。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git checkout t/feature1
hack...
$ git commit -m &quot;hacks in t/feature1.&quot;
</pre></div>
</div>
<p>然后再来看<tt class="docutils literal"><span class="pre">t/feature3</span></tt>的状态：</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg info t/feature3
Topic Branch: t/feature3 (1/1 commit)
Subject: [PATCH] t/feature3
Base: 0fa79a5
Depends: t/feature1
         t/feature2
Needs update from:
        t/feature1 (1/1 commit)
</pre></div>
</div>
<p>状态信息显示<tt class="docutils literal"><span class="pre">t/feature3</span></tt>不再是最新的状态（Up-to-date），因为依赖的分支包含新的提交，而需要从<tt class="docutils literal"><span class="pre">t/feature1</span></tt>获取更新。</p>
</div>
<div class="section" id="tg-update">
<h3>4.3.4.4. <strong class="command">tg update</strong>命令<a class="headerlink" href="#tg-update" title="永久链接至标题">¶</a></h3>
<p><strong class="command">tg update</strong>命令用于更新分支，即从依赖的分支或上游跟踪的分支获取最新的提交合并到当前分支。同时也更新在<tt class="docutils literal"><span class="pre">refs/top-bases/</span></tt>命名空间下的跟踪变基分支。</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] update [NAME]
</pre></div>
</div>
<p>其中<tt class="docutils literal"><span class="pre">NAME</span></tt>是可选的Topgit分支名。下面就对需要更新的<tt class="docutils literal"><span class="pre">t/feature3</span></tt>分支执行<strong class="command">tg update</strong>命令。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git checkout t/feature3
$ tg update
tg: Updating base with t/feature1 changes...
Merge made by recursive.
 feature1 |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
 create mode 100644 feature1
tg: Updating t/feature3 against new base...
Merge made by recursive.
 feature1 |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
 create mode 100644 feature1
</pre></div>
</div>
<p>从上面的输出信息可以看出执行了两次分支合并操作，一次是针对<tt class="docutils literal"><span class="pre">refs/top-bases/t/feature3</span></tt>引用指向的跟踪变基分支，另外一次针对的是<tt class="docutils literal"><span class="pre">refs/heads/t/feature3</span></tt>特性分支。</p>
<p>执行<strong class="command">tg update</strong>命令因为要涉及到分支的合并，因此并非每次都会成功。例如在<tt class="docutils literal"><span class="pre">t/feature3</span></tt>和<tt class="docutils literal"><span class="pre">t/feature1</span></tt>同时对同一个文件（如<tt class="docutils literal"><span class="pre">feature1</span></tt>）进行修改。然后在<tt class="docutils literal"><span class="pre">t/feature3</span></tt>中再执行<strong class="command">tg update</strong>可能就会报错，进入冲突解决状态。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg update t/feature3
tg: Updating base with t/feature1 changes...
Merge made by recursive.
 feature1 |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
tg: Updating t/feature3 against new base...
Auto-merging feature1
CONFLICT (content): Merge conflict in feature1
Automatic merge failed; fix conflicts and then commit the result.
tg: Please commit merge resolution. No need to do anything else
tg: You can abort this operation using `git reset --hard` now
tg: and retry this merge later using `tg update`.
</pre></div>
</div>
<p>可以看出第一次对<tt class="docutils literal"><span class="pre">refs/top-bases/t/feature3</span></tt>引用指向的跟踪变基分支成功合并，但在对<tt class="docutils literal"><span class="pre">t/feature3</span></tt>特性分支进行合并是出错。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg info
Topic Branch: t/feature3 (3/2 commits)
Subject: [PATCH] t/feature3
Base: 37dcb62
* Base is newer than head! Please run `tg update`.
Depends: t/feature1
         t/feature2
Up-to-date.

$ tg summary
        t/feature1                      [PATCH] t/feature1
 0      t/feature2                      [PATCH] t/feature2
&gt;     B t/feature3                      [PATCH] t/feature3

$ git status
# On branch t/feature3
# Unmerged paths:
#   (use &quot;git add/rm &lt;file&gt;...&quot; as appropriate to mark resolution)
#
#       both modified:      feature1
#
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</pre></div>
</div>
<p>通过<strong class="command">tg info</strong>命令可以看出当前分支状态是Up-to-date，但是之前有提示：分支的基（Base）要比头（Head）新，请执行<strong class="command">tg update</strong>命令。这时如果执行<strong class="command">tg summary</strong>命令的话，可以看到<tt class="docutils literal"><span class="pre">t/feature3</span></tt>处于B（Break）状态。用<strong class="command">git status</strong>命令，可以看出因为两个分支同时修改了文件<tt class="file docutils literal"><span class="pre">feature1</span></tt>导致冲突。</p>
<p>可以编辑<tt class="file docutils literal"><span class="pre">feature1</span></tt>文件，或者调用冲突解决工具解决冲突，之后再提交，才真正完成此次<strong class="command">tg update</strong>。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git mergetool
$ git commit -m &quot;resolved conflict with t/feature1.&quot;

$ tg info
Topic Branch: t/feature3 (4/2 commits)
Subject: [PATCH] t/feature3
Base: 37dcb62
Depends: t/feature1
         t/feature2
Up-to-date.
</pre></div>
</div>
</div>
<div class="section" id="tg-summary">
<h3>4.3.4.5. <strong class="command">tg summary</strong>命令<a class="headerlink" href="#tg-summary" title="永久链接至标题">¶</a></h3>
<p><strong class="command">tg summary</strong>命令用于显示Topgit管理的特性分支的列表及各个分支的状态。用法：</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] summary [-t | --sort | --deps | --graphviz]
</pre></div>
</div>
<p>不带任何参数执行<strong class="command">tg summary</strong>是最常用的Topgit命令。在介绍无参数的<strong class="command">tg summary</strong>命令之前，先看看其他简单的用法。</p>
<p>使用<tt class="docutils literal"><span class="pre">-t</span></tt>参数只显示特性分支列表。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg summary -t
t/feature1
t/feature2
t/feature3
</pre></div>
</div>
<p>使用<tt class="docutils literal"><span class="pre">--deps</span></tt>参数会显示Topgit特性分支，及其依赖的分支。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg summary  --deps
t/feature1 master
t/feature2 master
t/feature3 t/feature1
t/feature3 t/feature2
</pre></div>
</div>
<p>使用<tt class="docutils literal"><span class="pre">--sort</span></tt>参数按照分支依赖的顺序显示分支列表，除了Topgit分支外，依赖的非Topgit分支也会显示：</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg summary  --sort
t/feature3
t/feature2
t/feature1
master
</pre></div>
</div>
<p>使用<tt class="docutils literal"><span class="pre">--graphviz</span></tt>会输出GraphViz格式文件，可以用于显示特性分支之间的关系。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg summary --graphviz | dot -T png -o topgit.png
</pre></div>
</div>
<p>生成的特性分支关系图如图22-4所示。</p>
<div class="figure">
<a class="reference internal image-reference" href="../images/topgit-graphviz.png"><img alt="../images/topgit-graphviz.png" src="../images/topgit-graphviz.png" style="width: 485.0px; height: 293.0px;" /></a>
<p class="caption">图22-4：Topgit特性分支依赖关系图</p>
</div>
<p>不带任何参数执行<strong class="command">tg summary</strong>会显示分支列表及状态。这是最常用的Topgit命令之一。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg summary
        t/feature1                      [PATCH] t/feature1
 0      t/feature2                      [PATCH] t/feature2
&gt;       t/feature3                      [PATCH] t/feature3
</pre></div>
</div>
<p>其中:</p>
<ul class="simple">
<li>标记“&gt;”：（<tt class="docutils literal"><span class="pre">t/feature3</span></tt>分支之前的大于号）用于标记当前所处的特性分支。</li>
<li>标记“0”：（<tt class="docutils literal"><span class="pre">t/feature2</span></tt>分支前的数字0）含义是该分支中没有提交，这一个建立后尚未使用或废弃的分支。</li>
<li>标记“D”：表明该分支处于过时（out-of-date）状态。可能是一个或多个依赖的分支包含了新的提交，尚未合并到此特性分支。可以用<strong class="command">tg info</strong>命令看出到底是由于哪个依赖分支的改动导致该特性分支处于过时状态。</li>
<li>标记“B”：之前演示中出现过，表明该分支处于Break状态，即可能由于冲突未解决或者其他原因导致该特性分支的基（base）相对该分支的头（head）不匹配。<tt class="docutils literal"><span class="pre">refs/top-bases</span></tt>下的跟踪变基分支迁移了，但是特性分支未完成迁移。</li>
<li>标记“!”：表明该特性分支所依赖的分支不存在。</li>
<li>标记“l”：表明该特性分支只存在于本地，不存在于远程跟踪服务器。</li>
<li>标记“r”：表明该特性分支既存在于本地，又存在于远程跟踪服务器，并且两者匹配。</li>
<li>标记“L”：表明该特性分支，本地的要被远程跟踪服务器要新。</li>
<li>标记“R”：表明该特性分支，远程跟踪服务器的要被本地的新。</li>
<li>如果没有出现“l/r/L/R”：表明该版本库尚未设置远程跟踪版本库（没有remote）。</li>
<li>一般带有标记“r”的是最常见的，也是最正常的。</li>
</ul>
<p>下面通过<strong class="command">tg remote</strong>为测试版本库建立一个对应的远程跟踪版本库，然后就能在<strong class="command">tg summary</strong>的输出中看到标识符“l/r”等。</p>
</div>
<div class="section" id="tg-remote">
<h3>4.3.4.6. <strong class="command">tg remote</strong>命令<a class="headerlink" href="#tg-remote" title="永久链接至标题">¶</a></h3>
<p><strong class="command">tg remote</strong>命令用于为远程跟踪版本库设置Topgit的特性分支的关联，在和该远程版本库进行<tt class="docutils literal"><span class="pre">fetch</span></tt>、<tt class="docutils literal"><span class="pre">pull</span></tt>等操作时能够同步Topgit相关分支。</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] remote [--populate] [REMOTE]
</pre></div>
</div>
<p>其中<tt class="docutils literal"><span class="pre">REMOTE</span></tt>为远程跟踪版本库的名称，如“origin”，会自动在该远程源的配置中增加<tt class="docutils literal"><span class="pre">refs/top-bases</span></tt>下引用的同步。下面的示例中前面用加号标记的行就是当执行<strong class="command">tg remote origin</strong>后增加的设置。</p>
<div class="highlight-python"><div class="highlight"><pre> [remote &quot;origin&quot;]
        url = /path/to/repos/tgtest.git
        fetch = +refs/heads/*:refs/remotes/origin/*
+       fetch = +refs/top-bases/*:refs/remotes/origin/top-bases/*
</pre></div>
</div>
<p>如果使用<tt class="docutils literal"><span class="pre">--populate</span></tt>参数，除了会向上面那样设置缺省的Topgit远程版本库外，会自动执行<strong class="command">git fetch</strong>命令，然后还会为新的Topgit特性分支在本地创建新的分支，以及其对应的跟踪分支。</p>
<p>当执行<strong class="command">tg</strong>命令时，如果不用<tt class="docutils literal"><span class="pre">-r</span> <span class="pre">remote</span></tt>全局参数，默认使用缺省的Topgit远程版本库。</p>
<p>下面为前面测试的版本库设置一个远程的跟踪版本库。</p>
<p>先创建一个裸版本库<tt class="docutils literal"><span class="pre">tgtest.git</span></tt>。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git init --bare /path/to/repos/tgtest.git
Initialized empty Git repository in /path/to/repos/tgtest.git/
</pre></div>
</div>
<p>然后在测试版本库中注册名为<tt class="docutils literal"><span class="pre">origin</span></tt>的远程版本库为刚刚创建的版本库。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git remote add origin /path/to/repos/tgtest.git
</pre></div>
</div>
<p>执行<strong class="command">git push</strong>，将主线同步到远程的版本库。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git push origin master
Counting objects: 7, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (7/7), 585 bytes, done.
Total 7 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (7/7), done.
To /path/to/repos/tgtest.git
 * [new branch]      master -&gt; master
</pre></div>
</div>
<p>之后通过<strong class="command">tg remote</strong>命令告诉Git这个远程版本库需要跟踪Topgit分支。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg remote --populate origin
</pre></div>
</div>
<p>会在当前的版本库的<tt class="file docutils literal"><span class="pre">.git/config</span></tt>文件中添加设置（以加号开头的行）：</p>
<div class="highlight-python"><div class="highlight"><pre> [remote &quot;origin&quot;]
        url = /path/to/repos/tgtest.git
        fetch = +refs/heads/*:refs/remotes/origin/*
+       fetch = +refs/top-bases/*:refs/remotes/origin/top-bases/*
+[topgit]
+       remote = origin
</pre></div>
</div>
<p>这时再执行<strong class="command">tg summary</strong>会看到分支前面都有标记“l”，即本地提交比远程版本库要新。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg summary
  l     t/feature1                      [PATCH] t/feature1
 0l     t/feature2                      [PATCH] t/feature2
&gt; l     t/feature3                      [PATCH] t/feature3
</pre></div>
</div>
<p>将<tt class="docutils literal"><span class="pre">t/feature2</span></tt>的特性分支推送到远程版本库。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg push t/feature2
Counting objects: 5, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (4/4), 457 bytes, done.
Total 4 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (4/4), done.
To /path/to/repos/tgtest.git
 * [new branch]      t/feature2 -&gt; t/feature2
 * [new branch]      refs/top-bases/t/feature2 -&gt; refs/top-bases/t/feature2
</pre></div>
</div>
<p>再来看看<strong class="command">tg summary</strong>的输出，会看到<tt class="docutils literal"><span class="pre">t/feature2</span></tt>的标识变为“r”，即远程和本地相同步。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg summary
  l     t/feature1                      [PATCH] t/feature1
 0r     t/feature2                      [PATCH] t/feature2
&gt; l     t/feature3                      [PATCH] t/feature3
</pre></div>
</div>
<p>使用<strong class="command">tg push &#8211;all</strong>(改进过的Topgit)，会将所有的topgit分支推送到远程版本库。之后再来看<strong class="command">tg summary</strong>的输出。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg summary
  r     t/feature1                      [PATCH] t/feature1
 0r     t/feature2                      [PATCH] t/feature2
&gt; r     t/feature3                      [PATCH] t/feature3
</pre></div>
</div>
<p>如果版本库设置了多个远程版本库，要针对每一个远程版本库执行<strong class="command">tg remote &lt;REMOTE&gt;</strong>，但只能有一个远程的源用<tt class="docutils literal"><span class="pre">--populate</span></tt>参数调用<strong class="command">tg remote</strong>将其设置为缺省的远程版本库。</p>
</div>
<div class="section" id="tg-push">
<h3>4.3.4.7. <strong class="command">tg push</strong>命令<a class="headerlink" href="#tg-push" title="永久链接至标题">¶</a></h3>
<p>在前面<strong class="command">tg remote</strong>的介绍中，已经看到了<strong class="command">tg push</strong>命令。<strong class="command">tg push</strong>命令用于将Topgit特性分支及对应的变基跟踪分支推送到远程版本库。用法：</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] push [--dry-run] [--no-deps] [--tgish-only] [--all|branch*]
</pre></div>
</div>
<p><strong class="command">tg push</strong>命令后面的参数指定要推送给远程服务器的分支列表，如果省略则推送当前分支。改进的<strong class="command">tg push</strong>可以不提供任何分支，只提供<tt class="docutils literal"><span class="pre">--all</span></tt>参数就可以将所有Topgit特性分支推送到远程版本库。</p>
<p>参数<tt class="docutils literal"><span class="pre">--dry-run</span></tt>是测试执行效果，不真正执行。参数<tt class="docutils literal"><span class="pre">--no-deps</span></tt>的含义是不推送依赖的分支，缺省推送。参数<tt class="docutils literal"><span class="pre">--tgish-only</span></tt>的含义是只推送Topgit特性分支，缺省指定的所有分支都进行推送。</p>
</div>
<div class="section" id="tg-depend">
<h3>4.3.4.8. <strong class="command">tg depend</strong>命令<a class="headerlink" href="#tg-depend" title="永久链接至标题">¶</a></h3>
<p><strong class="command">tg depend</strong>命令目前仅实现了为当前的Topgit特性分支增加新的依赖。用法：</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] depend add NAME
</pre></div>
</div>
<p>会将<tt class="docutils literal"><span class="pre">NAME</span></tt>加入到文件<tt class="file docutils literal"><span class="pre">.topdeps</span></tt>中，并将<tt class="docutils literal"><span class="pre">NAME</span></tt>分支向该特性分支以及变基跟踪分支进行合并操作。虽然Topgit可以检查到分支的循环依赖，但还是要注意合理的设置分支的依赖，合并重复的依赖。</p>
</div>
<div class="section" id="tg-base">
<h3>4.3.4.9. <strong class="command">tg base</strong>命令<a class="headerlink" href="#tg-base" title="永久链接至标题">¶</a></h3>
<p><strong class="command">tg base</strong>命令用于显示特性分支的基（base）当前的commit-id。</p>
</div>
<div class="section" id="tg-delete">
<h3>4.3.4.10. <strong class="command">tg delete</strong>命令<a class="headerlink" href="#tg-delete" title="永久链接至标题">¶</a></h3>
<p><strong class="command">tg delete</strong>命令用于删除Topgit特性分支以及其对应的变基跟踪分支。用法：</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] delete [-f] NAME
</pre></div>
</div>
<p>缺省只删除没有改动的分支，即标记为“0”的分支，除非使用<tt class="docutils literal"><span class="pre">-f</span></tt>参数。</p>
<p>目前此命令尚不能自动清除其分支中对删除分支的依赖，还需要手工调整<tt class="file docutils literal"><span class="pre">.topdeps</span></tt>文件，删除不存在分支的依赖。</p>
</div>
<div class="section" id="tg-patch">
<h3>4.3.4.11. <strong class="command">tg patch</strong>命令<a class="headerlink" href="#tg-patch" title="永久链接至标题">¶</a></h3>
<p><strong class="command">tg patch</strong>命令通过比较特性分支及其变基跟踪分支的差异，显示该特性分支的补丁。用法：</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] patch [-i | -w] [NAME]
</pre></div>
</div>
<p>其中参数<tt class="docutils literal"><span class="pre">-i</span></tt>显示暂存区和变基跟踪分支的差异。参数<tt class="docutils literal"><span class="pre">-w</span></tt>显示工作区和变基跟踪分支的差异。</p>
<p><strong class="command">tg patch</strong>命令存在的一个问题是只有在工作区的根执行才能够正确显示。这个缺陷已经在我改进的Topgit中被改正。</p>
</div>
<div class="section" id="tg-export">
<h3>4.3.4.12. <strong class="command">tg export</strong>命令<a class="headerlink" href="#tg-export" title="永久链接至标题">¶</a></h3>
<p><strong class="command">tg export</strong>命令用于导出特性分支及其依赖，便于向上游贡献。可以导出Quilt格式的补丁列表，或者顺序提交到另外的分支中。用法：</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] export ([--collapse] NEWBRANCH | [--all | -b BRANCH1,BRANCH2...] --quilt DIRECTORY | --linearize NEWBRANCH)
</pre></div>
</div>
<p>这个命令有三种导出方法。</p>
<ul>
<li><p class="first">将所有的Topgit特性分支压缩为一个提交到新的分支。</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] export --collapse NEWBRAQNCH
</pre></div>
</div>
</li>
<li><p class="first">将所有的Topgit特性分支按照线性顺序提交到一个新的分支中。</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] export --linearize NEWBRANCH
</pre></div>
</div>
</li>
<li><p class="first">将指定的Topgit分支（一个或多个）及其依赖分支转换为Quilt格式的补丁，保存到指定目录中。</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] export -b BRANCH1,BRANCH2... --quilt DIRECTORY
</pre></div>
</div>
</li>
</ul>
<p>在导出为Quilt格式补丁的时候，如果想将所有的分支导出，必须用<tt class="docutils literal"><span class="pre">-b</span></tt>参数将分支全部罗列（或者分支的依赖关系将所有分支囊括），这对于需要导出所有分支非常不方便。我改进的Topgit通过<tt class="docutils literal"><span class="pre">--all</span></tt>参数，实现导出所有分支。</p>
</div>
<div class="section" id="tg-import">
<h3>4.3.4.13. <strong class="command">tg import</strong>命令<a class="headerlink" href="#tg-import" title="永久链接至标题">¶</a></h3>
<p><strong class="command">tg import</strong>命令将分支的提交转换为Topgit特性分支，每个分支称为一个特性分支，各个特性分支线性依赖。用法：</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] import [-d BASE_BRANCH] {[-p PREFIX] RANGE...|-s NAME COMMIT}
</pre></div>
</div>
<p>如果不使用<tt class="docutils literal"><span class="pre">-d</span></tt>参数，特性分支以当前分支为依赖。特性分支名称自动生成，使用约定俗成的<tt class="docutils literal"><span class="pre">t/</span></tt>作为前缀，也可以通过<tt class="docutils literal"><span class="pre">-p</span></tt>参数指定其他前缀。可以通过<tt class="docutils literal"><span class="pre">-s</span></tt>参数设定特性分支的名称。</p>
</div>
<div class="section" id="tg-log">
<h3>4.3.4.14. <strong class="command">tg log</strong>命令<a class="headerlink" href="#tg-log" title="永久链接至标题">¶</a></h3>
<p><strong class="command">tg log</strong>命令显示特性分支的提交历史，并忽略合并引入的提交。</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] log [NAME] [-- GIT LOG OPTIONS...]
</pre></div>
</div>
<p><strong class="command">tg log</strong>命令实际是对:command`git log`命令的封装。这个命令通过<tt class="docutils literal"><span class="pre">--no-merges</span></tt>和<tt class="docutils literal"><span class="pre">--first-parent</span></tt>参数调用<strong class="command">git log</strong>，虽然屏蔽了大量因和依赖分支合并而引入的依赖分支的提交日志，但是同时也屏蔽了合并到该特性分支的其他贡献者的提交。</p>
</div>
<div class="section" id="tg-mail">
<h3>4.3.4.15. <strong class="command">tg mail</strong>命令<a class="headerlink" href="#tg-mail" title="永久链接至标题">¶</a></h3>
<p><strong class="command">tg mail</strong>命令将当前分支或指定特性分支的补丁以邮件型式外发。用法：</p>
<div class="highlight-python"><div class="highlight"><pre>tg [...] mail [-s SEND_EMAIL_ARGS] [-r REFERENCE_MSGID] [NAME]
</pre></div>
</div>
<p><strong class="command">tg mail</strong>调用<strong class="command">git send-email</strong>发送邮件，参数<tt class="docutils literal"><span class="pre">-s</span></tt>用于向该命令传递参数（需要用双引号括起来）。邮件中的目的地址从patch文件头中的<tt class="docutils literal"><span class="pre">To</span></tt>、<tt class="docutils literal"><span class="pre">Cc</span></tt>和<tt class="docutils literal"><span class="pre">Bcc</span></tt>等字段获取。参数<tt class="docutils literal"><span class="pre">-r</span></tt>引用回复邮件的id以便正确生成<tt class="docutils literal"><span class="pre">in-reply-to</span></tt>邮件头。</p>
<p>注意：此命令可能会发送多封邮件，可以通过如下设置在调用<strong class="command">git send-email</strong>命令发送邮件时进行确认。</p>
<div class="highlight-python"><div class="highlight"><pre>git config sendemail.confirm always
</pre></div>
</div>
</div>
<div class="section" id="tg-graph">
<h3>4.3.4.16. <strong class="command">tg graph</strong>命令<a class="headerlink" href="#tg-graph" title="永久链接至标题">¶</a></h3>
<p><strong class="command">tg graph</strong>命令并非官方提供的命令，而是源自一个补丁，实现文本方式的Topgit分支图。当然这个文本分支图没有<strong class="command">tg summary &#8211;graphviz</strong>生成的那么漂亮。</p>
</div>
</div>
<div class="section" id="topgit-hacks">
<h2>4.3.5. Topgit hacks<a class="headerlink" href="#topgit-hacks" title="永久链接至标题">¶</a></h2>
<p>在Topgit的使用中陆续发现一些不合用的地方，于是便使用Topgit特性分支的方式来改进Topgit自身的代码。在群英汇博客上，介绍了这几个改进，参见：<a class="reference external" href="http://blog.ossxp.com/tag/topgit/">http://blog.ossxp.com/tag/topgit/</a>。</p>
<p>下面就以此为例，介绍如何参与一个Topgit管理下的项目的开发。改进的Topgit版本库地址为：git://github.com/ossxp-com/topgit.git。</p>
<p>首先克隆该版本库。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git clone git://github.com/ossxp-com/topgit.git
$ cd topgit
</pre></div>
</div>
<p>查看远程分支。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git branch -r
origin/HEAD -&gt; origin/master
origin/master
origin/t/debian_locations
origin/t/export_quilt_all
origin/t/fast_tg_summary
origin/t/graphviz_layout
origin/t/tg_completion_bugfix
origin/t/tg_graph_ascii_output
origin/t/tg_patch_cdup
origin/t/tg_push_all
origin/tgmaster
</pre></div>
</div>
<p>看到远程分支中出现了熟悉的以<tt class="docutils literal"><span class="pre">t/</span></tt>为前缀的Topgit分支，说明这个版本库是一个Topgit管理的定制开发版本库。那么为了能够获取Topgit的变基跟踪分支，需要用<strong class="command">tg remote</strong>命令对缺省的<tt class="docutils literal"><span class="pre">origin</span></tt>远程版本库注册一下。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg remote --populate origin
tg: Remote origin can now follow TopGit topic branches.
tg: Populating local topic branches from remote &#39;origin&#39;...
From git://github.com/ossxp-com/topgit
 * [new branch]      refs/top-bases/t/debian_locations -&gt; origin/top-bases/t/debian_locations
 * [new branch]      refs/top-bases/t/export_quilt_all -&gt; origin/top-bases/t/export_quilt_all
 * [new branch]      refs/top-bases/t/fast_tg_summary -&gt; origin/top-bases/t/fast_tg_summary
 * [new branch]      refs/top-bases/t/graphviz_layout -&gt; origin/top-bases/t/graphviz_layout
 * [new branch]      refs/top-bases/t/tg_completion_bugfix -&gt; origin/top-bases/t/tg_completion_bugfix
 * [new branch]      refs/top-bases/t/tg_graph_ascii_output -&gt; origin/top-bases/t/tg_graph_ascii_output
 * [new branch]      refs/top-bases/t/tg_patch_cdup -&gt; origin/top-bases/t/tg_patch_cdup
 * [new branch]      refs/top-bases/t/tg_push_all -&gt; origin/top-bases/t/tg_push_all
tg: Adding branch t/debian_locations...
tg: Adding branch t/export_quilt_all...
tg: Adding branch t/fast_tg_summary...
tg: Adding branch t/graphviz_layout...
tg: Adding branch t/tg_completion_bugfix...
tg: Adding branch t/tg_graph_ascii_output...
tg: Adding branch t/tg_patch_cdup...
tg: Adding branch t/tg_push_all...
tg: The remote &#39;origin&#39; is now the default source of topic branches.
</pre></div>
</div>
<p>执行<strong class="command">tg summary</strong>看一下本地Topgit特性分支状态。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg summary
  r  !  t/debian_locations              [PATCH] make file locations Debian-compatible
  r  !  t/export_quilt_all              [PATCH] t/export_quilt_all
  r  !  t/fast_tg_summary               [PATCH] t/fast_tg_summary
  r  !  t/graphviz_layout               [PATCH] t/graphviz_layout
  r  !  t/tg_completion_bugfix          [PATCH] t/tg_completion_bugfix
  r     t/tg_graph_ascii_output         [PATCH] t/tg_graph_ascii_output
  r  !  t/tg_patch_cdup                 [PATCH] t/tg_patch_cdup
  r  !  t/tg_push_all                   [PATCH] t/tg_push_all
</pre></div>
</div>
<p>怎么？出现了感叹号？记得前面在介绍<strong class="command">tg summary</strong>命令的章节中提到过，感叹号的出现说明该特性分支依赖的分支丢失。用<strong class="command">tg info</strong>查看一下某个特性分支。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg info t/export_quilt_all
Topic Branch: t/export_quilt_all (6/4 commits)
Subject: [PATCH] t/export_quilt_all
Base: 8b0f1f9
Remote Mate: origin/t/export_quilt_all
Depends: tgmaster
MISSING: tgmaster
Up-to-date.
</pre></div>
</div>
<p>原来该特性分支依赖<tt class="docutils literal"><span class="pre">tgmaster</span></tt>分支，而不是master分支。远程存在<tt class="docutils literal"><span class="pre">tgmaster</span></tt>分支而本地尚不存在。于是在本地建立<tt class="docutils literal"><span class="pre">tgmaster</span></tt>跟踪分支。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git checkout tgmaster
Branch tgmaster set up to track remote branch tgmaster from origin.
Switched to a new branch &#39;tgmaster&#39;
</pre></div>
</div>
<p>这回<strong class="command">tg summary</strong>的输出正常了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg summary
  r     t/debian_locations              [PATCH] make file locations Debian-compatible
  r     t/export_quilt_all              [PATCH] t/export_quilt_all
  r     t/fast_tg_summary               [PATCH] t/fast_tg_summary
  r     t/graphviz_layout               [PATCH] t/graphviz_layout
  r     t/tg_completion_bugfix          [PATCH] t/tg_completion_bugfix
  r     t/tg_graph_ascii_output         [PATCH] t/tg_graph_ascii_output
  r     t/tg_patch_cdup                 [PATCH] t/tg_patch_cdup
  r     t/tg_push_all                   [PATCH] t/tg_push_all
</pre></div>
</div>
<p>通过下面命令创建图形化的分支图。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg summary --graphviz | dot -T png -o topgit.png
</pre></div>
</div>
<p>生成的特性分支关系图如图22-5所示。</p>
<div class="figure">
<a class="reference internal image-reference" href="../images/topgit-hacks.png"><img alt="../images/topgit-hacks.png" src="../images/topgit-hacks.png" style="width: 717.0px; height: 653.0px;" /></a>
<p class="caption">图22-5：Topgit改进项目的特性分支依赖关系图</p>
</div>
<p>其中：</p>
<ul class="simple">
<li>特性分支<tt class="docutils literal"><span class="pre">t/export_quilt_all</span></tt>，为<strong class="command">tg export &#8211;quilt</strong>命令增加<tt class="docutils literal"><span class="pre">--all</span></tt>选项，以便导出所有特性分支。</li>
<li>特性分支<tt class="docutils literal"><span class="pre">t/fast_tg_summary</span></tt>，主要是改进<tt class="docutils literal"><span class="pre">tg</span></tt>命令补齐时分支的显示速度，当特性分支接近上百个时差异非常明显。</li>
<li>特性分支<tt class="docutils literal"><span class="pre">t/graphviz_layout</span></tt>，改进了分支的图形输出格式。</li>
<li>特性分支<tt class="docutils literal"><span class="pre">t/tg_completion_bugfix</span></tt>，解决了命令补齐的一个 Bug。</li>
<li>特性分支<tt class="docutils literal"><span class="pre">t/tg_graph_ascii_output</span></tt>，源自Bert Wesarg的贡献，非常巧妙地实现了文本化的分支图显示，展示了gvpr命令的强大功能。</li>
<li>特性分支<tt class="docutils literal"><span class="pre">t/tg_patch_cdup</span></tt>，解决了在项目的子目录下无法执行<strong class="command">tg patch</strong>的问题。</li>
<li>特性分支<tt class="docutils literal"><span class="pre">t/tg_push_all</span></tt>，通过为<strong class="command">tg push</strong>增加<tt class="docutils literal"><span class="pre">--all</span></tt>选项，解决了当<tt class="docutils literal"><span class="pre">tg</span></tt>从0.7升级到0.8后，无法批量向上游推送特性分支的问题。</li>
</ul>
<p>下面展示一下如何跟踪上游的最新改动，并迁移到新的上游版本。分支<tt class="docutils literal"><span class="pre">tgmaster</span></tt>用于跟踪上游的Topgit分支，以<tt class="docutils literal"><span class="pre">t/</span></tt>开头的分支是对Topgit改进的特性分支，而<tt class="docutils literal"><span class="pre">master</span></tt>分支实际上是导出Topgit补丁文件并负责编译特定Linux平台发行包的分支。</p>
<p>把官方的Topgit分支以<tt class="docutils literal"><span class="pre">upstream</span></tt>的名称加入为新的远程版本库。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git remote add upstream git://repo.or.cz/topgit.git
</pre></div>
</div>
<p>然后将<tt class="docutils literal"><span class="pre">upstream</span></tt>远程版本的<tt class="docutils literal"><span class="pre">master</span></tt>分支合并到本地的<tt class="docutils literal"><span class="pre">tgmaster</span></tt>分支。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git pull upstream master:tgmaster
From git://repo.or.cz/topgit
   29ab4cf..8b0f1f9  master     -&gt; tgmaster
</pre></div>
</div>
<p>此时再执行<strong class="command">tg summary</strong>会发现所有的Topgit分支都多了一个标记“D”，表明因为依赖分支的更新导致Topgit特性分支过时了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg summary
  r D   t/debian_locations              [PATCH] make file locations Debian-compatible
  r D   t/export_quilt_all              [PATCH] t/export_quilt_all
  r D   t/fast_tg_summary               [PATCH] t/fast_tg_summary
  r D   t/graphviz_layout               [PATCH] t/graphviz_layout
  r D   t/tg_completion_bugfix          [PATCH] t/tg_completion_bugfix
  r D   t/tg_graph_ascii_output         [PATCH] t/tg_graph_ascii_output
  r D   t/tg_patch_cdup                 [PATCH] t/tg_patch_cdup
  r D   t/tg_push_all                   [PATCH] t/tg_push_all
</pre></div>
</div>
<p>依次对各个分支执行<strong class="command">tg update</strong>，完成对更新的依赖分支的合并。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg update t/export_quilt_all
...
</pre></div>
</div>
<p>对各个分支完成更新后，会发现<strong class="command">tg summary</strong>的输出中，标识过时的“D”标记变为“L”，即本地比远程服务器分支要新。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tg summary
  rL    t/debian_locations              [PATCH] make file locations Debian-compatible
  rL    t/export_quilt_all              [PATCH] t/export_quilt_all
  rL    t/fast_tg_summary               [PATCH] t/fast_tg_summary
  rL    t/graphviz_layout               [PATCH] t/graphviz_layout
  rL    t/tg_completion_bugfix          [PATCH] t/tg_completion_bugfix
  rL    t/tg_graph_ascii_output         [PATCH] t/tg_graph_ascii_output
  rL    t/tg_patch_cdup                 [PATCH] t/tg_patch_cdup
  rL    t/tg_push_all                   [PATCH] t/tg_push_all
</pre></div>
</div>
<p>执行<strong class="command">tg push &#8211;all</strong>就可以实现将所有Topgit特性分支推送到远程服务器上。当然需要具有提交权限才可以。</p>
</div>
<div class="section" id="id5">
<h2>4.3.6. Topgit使用中的注意事项<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p><strong>经常运行:command:`tg remote &#8211;populate`获取他人创建的特性分支</strong></p>
<p>运行命令<strong class="command">git fetch origin</strong>和远程版本库（origin）同步，只能将他人创建的Topgit特性分支在本地以<tt class="docutils literal"><span class="pre">refs/remotes/origin/t/&lt;branch-name&gt;</span></tt>的名称保存，而不能自动在本地建立分支。</p>
<p>当版本库是使用Topgit维护的话，应该在和远程版本库同步的时候使用执行<strong class="command">tg remote &#8211;populate origin</strong>。这条命令会做两件事情：</p>
<ul class="simple">
<li>自动调用<strong class="command">git fetch origin</strong>获取远程<tt class="docutils literal"><span class="pre">origin</span></tt>版本库的新的提交和引用。</li>
<li>检查<tt class="file docutils literal"><span class="pre">refs/remotes/origin/top-bases/</span></tt>下的所有引用，如果是新的、在本地（<tt class="docutils literal"><span class="pre">refs/top-bases/</span></tt>）尚不存在，说明有其他人创建了新的特性分支。Topgit会据此自动的在本地创建新的特性分支。</li>
</ul>
<p><strong>适时的调整特性分支的依赖关系</strong></p>
<p>例如前面示例的Topgit库的依赖关系，各个分支可能的依赖文件内容如下。</p>
<ul>
<li><p class="first">分支<tt class="docutils literal"><span class="pre">t/feature1</span></tt>的<tt class="file docutils literal"><span class="pre">.topdeps</span></tt>文件</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">master</span>
</pre></div>
</div>
</li>
<li><p class="first">分支<tt class="docutils literal"><span class="pre">t/feature2</span></tt>的<tt class="file docutils literal"><span class="pre">.topdeps</span></tt>文件</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">master</span>
</pre></div>
</div>
</li>
<li><p class="first">分支<tt class="docutils literal"><span class="pre">t/feature3</span></tt>的<tt class="file docutils literal"><span class="pre">.topdeps</span></tt>文件</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span><span class="o">/</span><span class="n">feature1</span>
<span class="n">t</span><span class="o">/</span><span class="n">feature2</span>
</pre></div>
</div>
</li>
</ul>
<p>如果分支<tt class="docutils literal"><span class="pre">t/feature3</span></tt>的<tt class="file docutils literal"><span class="pre">.topdeps</span></tt>文件是这样的，可能就会存在问题。</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="n">master</span>
<span class="n">t</span><span class="o">/</span><span class="n">feature1</span>
<span class="n">t</span><span class="o">/</span><span class="n">feature2</span>
</pre></div>
</div>
</div></blockquote>
<p>问题出在<tt class="docutils literal"><span class="pre">t/feature3</span></tt>依赖的其他分支已经依赖了<tt class="docutils literal"><span class="pre">master</span></tt>分支。虽然不会造成致命的影响，但是在特定情况下这种重复会造成不便。例如在<tt class="docutils literal"><span class="pre">master</span></tt>分支更新后，可能由于代码重构的比较厉害，在特性分支迁移时会造成冲突，如在<tt class="docutils literal"><span class="pre">t/feature1</span></tt>分支执行<strong class="command">tg update</strong>会遇到冲突，当辛苦完成冲突解决并提交后，在<tt class="docutils literal"><span class="pre">t/feature3</span></tt>执行<strong class="command">tg update</strong>时因为先依赖的是<tt class="docutils literal"><span class="pre">master</span></tt>分支，会先在<tt class="docutils literal"><span class="pre">master</span></tt>分支上对<tt class="docutils literal"><span class="pre">t/feature3</span></tt>分支进行变基，肯定会遇到和<tt class="docutils literal"><span class="pre">t/feature1</span></tt>相同的冲突，还要再重复地解决一次。</p>
<p>如果在<tt class="file docutils literal"><span class="pre">.topdeps</span></tt>文件中将对<tt class="docutils literal"><span class="pre">master</span></tt>分支的重复的依赖删除，就不会出现上面的重复进行冲突解决的问题了。</p>
<p>同样的道理，如果<tt class="docutils literal"><span class="pre">t/feature3</span></tt>的<tt class="file docutils literal"><span class="pre">.topdeps</span></tt>文件写成这样，效果也将不同：</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="n">t</span><span class="o">/</span><span class="n">feature2</span>
<span class="n">t</span><span class="o">/</span><span class="n">feature1</span>
</pre></div>
</div>
</div></blockquote>
<p>依赖的顺序不同会造成变基的顺序也不同，同样也会产生重复的冲突解决。因此当发现重复的冲突时，可以取消变基操作，修改特性分支的<tt class="file docutils literal"><span class="pre">.topdeps</span></tt>文件，调整文件内容（删除重复分支，调整分支顺序）并提交，然后在执行<strong class="command">tg update</strong>继续变基操作。</p>
<p><strong>Topgit特性分支的里程碑和分支管理</strong></p>
<p>Topgit本身就是对特性分支进行管理的软件。Topgit的某个时刻的开发状态是所有Topgit管理下的分支（包括跟踪分支）整体的状态。如果需要对Topgit所有相关的分支进行跟踪管理该如何实现呢？</p>
<p>例如master主线由于提交了上游的新版本而改动，在对各个Topgit特性分支执行<strong class="command">tg update</strong>时，搞的一团糟，而又不小心执行了<strong class="command">tg push &#8211;all</strong>，这下无论本地和远程都处于混乱的状态。</p>
<p>使用里程碑（tags）来管理是不可能的，因为tag只能针对一个分支做标记而不能标记所有的分支。</p>
<p>使用克隆是唯一的方法。即针对不同的上游建立不同的Git库，通过不同的克隆实现针对不同上游版本特性分支开发的管理。例如一旦上游出现新版本，就从当前版本库建立一个克隆，或者用于保存当前上游版本的特性开发状态，或者用于新的上游版本的特性开发。</p>
<p>也许还可以通过其他方法实现，例如将Topgit所有相关分支都复制到一个特定的引用目录中，如<tt class="file docutils literal"><span class="pre">refs/top-tags/v1.0/</span></tt>用于实现特性分支的里程碑记录。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="040-submodule-model.html" title="4.4. 子模组协同模型"
             >下一页</a> |</li>
        <li class="right" >
          <a href="020-distribute-model.html" title="4.2. 金字塔式协同模型"
             >上一页</a> |</li>
        <li><a href="../index.html">GotGit</a> &raquo;</li>
          <li><a href="index.html" >4. Git协同模型</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>
      <br />
      全部内容以 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons 署名-非商业性使用-相同方式共享 3.0 协议发布</a>.
      <br />
        &copy; Copyright 2011, 蒋鑫。
      使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3 创建。

    </div>
  </body>
</html>