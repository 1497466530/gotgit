
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>4.6. Android式多版本库协同 &mdash; GotGit</title>
    
    <link rel="stylesheet" href="../static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="/stylesheets/master.css" type="text/css" />
    <link rel="stylesheet" href="/stylesheets/syntax.css" type="text/css" />
    <link rel="stylesheet" href="../static/worldhello.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/translations.js"></script>
    <link rel="top" title="GotGit" href="../index.html" />
    <link rel="up" title="4. Git协同模型" href="index.html" />
    <link rel="next" title="4.7. Git和SVN协同模型" href="070-git-svn.html" />
    <link rel="prev" title="4.5. 子树合并" href="050-subtree-model.html" /> 
  </head>
  <body>
    <div id='header'>
      <h1><a href='/'>World Hello</a></h1>

      <div id='menu'>
        <ul>
          <li><a href='/' id='home-link' title='Home'>首页</a></li>
          <li><a href='/blog.html' id='blog-link' title='Blog'>博客</a></li>
          <li><a href='/doc/' id='docs-link' title='Docs'>文章</a></li>
          <li><a href='/about.html' id='about-link' title='About'>关于</a></li>
          <li><a href='http://github.com/gotgit' target='_blank' title='GitHub' rel='me' id='github-link'>GitHub</a></li>
          <li><a href='http://weibo.com/gotgit' title='微博' target='_blank' id='weibo-link'>微博</a></li>
        </ul>
      </div>
    </div>

    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="070-git-svn.html" title="4.7. Git和SVN协同模型"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="050-subtree-model.html" title="4.5. 子树合并"
             accesskey="P">上一页</a> |</li>
        <li><a href="../index.html">GotGit</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">4. Git协同模型</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">4.6. Android式多版本库协同</a><ul>
<li><a class="reference internal" href="#repo">4.6.1. 关于repo</a></li>
<li><a class="reference internal" href="#id1">4.6.2. 安装repo</a></li>
<li><a class="reference internal" href="#id2">4.6.3. repo和清单库的初始化</a></li>
<li><a class="reference internal" href="#id3">4.6.4. 清单库和清单文件</a></li>
<li><a class="reference internal" href="#id4">4.6.5. 同步项目</a></li>
<li><a class="reference internal" href="#id5">4.6.6. 建立Android代码库本地镜像</a></li>
<li><a class="reference internal" href="#id6">4.6.7. Repo的命令集</a><ul>
<li><a class="reference internal" href="#repo-init">4.6.7.1. <strong class="command">repo init</strong>命令</a></li>
<li><a class="reference internal" href="#repo-sync">4.6.7.2. <strong class="command">repo sync</strong>命令</a></li>
<li><a class="reference internal" href="#repo-start">4.6.7.3. <strong class="command">repo start</strong>命令</a></li>
<li><a class="reference internal" href="#repo-status">4.6.7.4. <strong class="command">repo status</strong>命令</a></li>
<li><a class="reference internal" href="#repo-checkout">4.6.7.5. <strong class="command">repo checkout</strong>命令</a></li>
<li><a class="reference internal" href="#repo-branches">4.6.7.6. <strong class="command">repo branches</strong>命令</a></li>
<li><a class="reference internal" href="#repo-diff">4.6.7.7. <strong class="command">repo diff</strong>命令</a></li>
<li><a class="reference internal" href="#repo-stage">4.6.7.8. <strong class="command">repo stage</strong>命令</a></li>
<li><a class="reference internal" href="#repo-upload">4.6.7.9. <strong class="command">repo upload</strong>命令</a></li>
<li><a class="reference internal" href="#repo-download">4.6.7.10. <strong class="command">repo download</strong>命令</a></li>
<li><a class="reference internal" href="#repo-rebase">4.6.7.11. <strong class="command">repo rebase</strong>命令</a></li>
<li><a class="reference internal" href="#repo-prune">4.6.7.12. <strong class="command">repo prune</strong>命令</a></li>
<li><a class="reference internal" href="#repo-abandon">4.6.7.13. <strong class="command">repo abandon</strong>命令</a></li>
<li><a class="reference internal" href="#id7">4.6.7.14. 其他命令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">4.6.8. Repo命令的工作流</a></li>
<li><a class="reference internal" href="#id9">4.6.9. 好东西不能Android独享</a><ul>
<li><a class="reference internal" href="#repo-gerrit">4.6.9.1. Repo+Gerrit模式</a></li>
<li><a class="reference internal" href="#id10">4.6.9.2. Repo无审核模式</a></li>
<li><a class="reference internal" href="#id11">4.6.9.3. 改进的Repo无审核模式</a><ul>
<li><a class="reference internal" href="#id12">4.6.9.3.1. 下载改造后的repo引导脚本</a></li>
<li><a class="reference internal" href="#repogithub">4.6.9.3.2. 用repo从Github上检出测试项目</a></li>
<li><a class="reference internal" href="#repo-configpushurl">4.6.9.3.3. 用<strong class="command">repo config</strong>命令设置pushurl</a></li>
<li><a class="reference internal" href="#id13">4.6.9.3.4. 创建本地工作分支</a></li>
<li><a class="reference internal" href="#push">4.6.9.3.5. PUSH到远程服务器</a></li>
<li><a class="reference internal" href="#id14">4.6.9.3.6. 在远程服务器创建新分支</a></li>
<li><a class="reference internal" href="#id15">4.6.9.3.7. 通过不同的清单库版本，切换到不同分支</a></li>
<li><a class="reference internal" href="#id16">4.6.9.3.8. 切换到清单库里程碑版本</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="050-subtree-model.html"
                        title="上一章">4.5. 子树合并</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="070-git-svn.html"
                        title="下一章">4.7. Git和SVN协同模型</a></p>
  <h3>本页</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/04-git-model/060-android-model.txt"
           rel="nofollow">显示源代码</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>快速搜索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="转向" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    输入相关的术语，模块，类或者函数名称进行搜索
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="android">
<h1>4.6. Android式多版本库协同<a class="headerlink" href="#android" title="永久链接至标题">¶</a></h1>
<p>Android是谷歌（Google）开发的适合手持设备的操作系统，提供了当前最为吸引眼球的开源的手机操作平台，大有超越苹果（Apple.com）的专有的iOS的趋势。而Android的源代码就是使用Git进行维护的。Android项目在使用Git进行源代码管理上有两个伟大的创造，一个是用Python语言开发名为repo的命令行工具用于多版本库的管理，另外一个是用Java开发的名为Gerrit的代码审核服务器。本节重点介绍repo是如何管理多代码库的。</p>
<p>Android的源代码的Git库有160多个（截止至2010年10月）：</p>
<ul>
<li><p class="first">Android的版本库管理工具repo：</p>
<p>git://android.git.kernel.org/tools/repo.git</p>
</li>
<li><p class="first">保存GPS配置文件的版本库</p>
<p>git://android.git.kernel.org/device/common.git</p>
</li>
<li><p class="first">160多个其他的版本库...</p>
</li>
</ul>
<p>如果要是把160多个版本库都列在这里，恐怕各位的下巴会掉下来。那么为什么Android的版本库这么多呢？怎么管理这么复杂的版本库呢？</p>
<p>Android版本库众多的原因，主要原因是版本库太大以及Git不能部分检出。Android的版本库有接近2个GB之多。如果所有的东西都放在一个库中，而某个开发团队感兴趣的可能就是某个驱动，或者是某个应用，却要下载如此庞大的版本库，是有些说不过去。</p>
<p>好了，既然接受了Android有多达160多个版本库这一事实，那么Android是不是用之前介绍的“子模组”方式组织起来的呢？如果真的用“子模组”方式来管理这160个代码库，可能就需要如此管理：</p>
<ul class="simple">
<li>建立一个索引版本库，在该版本库中，通过子模组方式，将一个一个的目录对应到160多个版本库。</li>
<li>当对此索引版本库执行克隆操作后，再执行<strong class="command">git submodule init</strong>命令。</li>
<li>当执行<strong class="command">git submodule update</strong>命令时，开始分别克隆这160多个版本库。</li>
<li>如果想修改某个版本库中的内容，需要进入到相应的子模组目录，执行切换分支的操作。因为子模组是以某个固定提交的状态存在的，是不能更改的，必须先切换到某个工作分支后，才能进行修改和提交。</li>
<li>如果要将所有的子模组都切换到某个分支（如master）进行修改，必须自己通过脚本对这160多个版本库一一切换。</li>
<li>Android有多个版本：android-1.0、android-1.5、...、android-2.2_r1.3、...如何维护这么多的版本呢？也许索引库要通过分支和里程碑，和子模组的各个不同的提交状态进行对应。但是由于子模组的状态只是一个提交ID，如何能够动态指定到分支，真的给不出答案。</li>
</ul>
<p>幸好，上面只是假设。聪明的Android程序设计师一早就考虑到了Git子模组的局限性以及多版本库管理的问题，开发出了repo这一工具。</p>
<p>关于repo有这么一则小故事：Android之父安迪·鲁宾在回应乔布斯关于Android太开放导致开发维护更麻烦的言论时，在Twitter（<a class="reference external" href="http://twitter.com/Arubin">http://twitter.com/Arubin</a>）上留了下面这段简短的话：</p>
<div class="highlight-python"><div class="highlight"><pre>the definition of open: &quot;mkdir android ; cd android ; repo init -u git://android.git.kernel.org/platform/manifest.git ; repo sync ; make&quot;
</pre></div>
</div>
<p>是的，就是repo让Android的开发变得如此简单。</p>
<div class="section" id="repo">
<h2>4.6.1. 关于repo<a class="headerlink" href="#repo" title="永久链接至标题">¶</a></h2>
<p>Repo是Google开发的用于管理Android版本库的一个工具。Repo并不是用于取代Git，是用Python对Git进行了一定的封装，简化了对多个Git版本库的管理。对于repo管理的任何一个版本库，都还是需要使用Git命令进行操作。</p>
<p>repo的使用过程大致如下：</p>
<ul class="simple">
<li>运行<strong class="command">repo init</strong>命令，克隆Android的一个清单库。这个清单库和前面假设的“子模组”方式工作的索引库不同，是通过XML技术建立的版本库清单。</li>
<li>清单库中的<tt class="file docutils literal"><span class="pre">manifest.xml</span></tt>文件，列出了160多个版本库的克隆方式。包括版本库的地址和工作区地址的对应关系，以及分支的对应关系。</li>
<li>运行<strong class="command">repo sync</strong>命令，开始同步，即分别克隆这160多个版本库到本地的工作区中。</li>
<li>同时对160多个版本库执行切换分支操作，切换到某个分支。</li>
</ul>
</div>
<div class="section" id="id1">
<h2>4.6.2. 安装repo<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>首先下载repo的引导脚本，可以使用wget、curl甚至浏览器从地址<a class="reference external" href="http://android.git.kernel.org/repo">http://android.git.kernel.org/repo</a>下载。把repo脚本设置为可执行，并复制到可执行的路径中。在Linux上可以用下面的指令将repo下载并复制到用户主目录的<tt class="file docutils literal"><span class="pre">bin</span></tt>目录下。</p>
<div class="highlight-python"><div class="highlight"><pre>$ curl http://android.git.kernel.org/repo &gt; ~/bin/repo
$ chmod a+x ~/bin/repo
</pre></div>
</div>
<p>为什么说下载的repo只是一个引导脚本（bootstrap）而不是直接称为repo呢？因为repo的大部分功能代码不在其中，下载的只是一个帮助完成整个repo程序的继续下载和加载工具。如果您是一个程序员，对repo的执行比较好奇，可以一起分析一下repo引导脚本。否则可以跳到下一节。</p>
<p>看看repo引导脚本的前几行（为方便描述，把注释和版权信息过滤掉了），会发现一个神奇的魔法：</p>
<div class="highlight-python"><div class="highlight"><pre>1   #!/bin/sh
2
3   REPO_URL=&#39;git://android.git.kernel.org/tools/repo.git&#39;
4   REPO_REV=&#39;stable&#39;
5
6   magic=&#39;--calling-python-from-/bin/sh--&#39;
7   &quot;&quot;&quot;exec&quot; python -E &quot;$0&quot; &quot;$@&quot; &quot;&quot;&quot;#$magic&quot;
8   if __name__ == &#39;__main__&#39;:
9     import sys
10    if sys.argv[-1] == &#39;#%s&#39; % magic:
11      del sys.argv[-1]
12  del magic
</pre></div>
</div>
<p>Repo引导脚本是用什么语言开发的？这是一个问题。</p>
<ul class="simple">
<li>第1行，有经验的Linux开发者会知道此脚本是用Shell脚本语言开发的。</li>
<li>第7行，是这个魔法的最神奇之处。既是一条合法的shell语句，又是一条合法的python语句。</li>
<li>第7行作为shell语句，执行<strong class="command">exec</strong>，用python调用本脚本，并替换本进程。三引号在这里相当于一个空字串和一个单独的引号。</li>
<li>第7行作为python语句，三引号定义的是一个字符串，字符串后面是一个注释。</li>
<li>实际上第1行到第7行，即是合法的shell语句又是合法的python语句。从第8行开始后面都是python脚本了。</li>
<li>Repo引导脚本无论是使用shell执行，或是用python执行，效果都相当于使用python执行此脚本。</li>
</ul>
<p><strong>Repo真正的位置在哪里？</strong></p>
<p>在引导脚本repo的<tt class="docutils literal"><span class="pre">main</span></tt>函数，首先调用`` _FindRepo``函数，从当前目录开始依次向上递归查找<tt class="file docutils literal"><span class="pre">.repo/repo/main.py</span></tt>文件。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">orig_args</span><span class="p">):</span>
  <span class="n">main</span><span class="p">,</span> <span class="nb">dir</span> <span class="o">=</span> <span class="n">_FindRepo</span><span class="p">()</span>
</pre></div>
</div>
<p>函数<tt class="docutils literal"><span class="pre">_FindRepo</span></tt>返回找到的<tt class="file docutils literal"><span class="pre">.repo/repo/main.py</span></tt>脚本文件，以及包含<tt class="file docutils literal"><span class="pre">repo/main.py</span></tt>的<tt class="file docutils literal"><span class="pre">.repo</span></tt>目录。如果找到<tt class="file docutils literal"><span class="pre">.repo/repo/main.py</span></tt>脚本，则把程序的控制权交给<tt class="file docutils literal"><span class="pre">.repo/repo/main.py</span></tt>脚本。（省略了在repo开发库中执行情况的判断）</p>
<p>在下载repo引导脚本后，没有初始化之前，当然不会存在<tt class="file docutils literal"><span class="pre">.repo/repo/main.py</span></tt>脚本，这时必须进行初始化操作。</p>
</div>
<div class="section" id="id2">
<h2>4.6.3. repo和清单库的初始化<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>下载并保存repo引导脚本后，建立一个工作目录，这个工作目录将作为Android的工作区目录。在工作目录中执行<strong class="command">repo init -u &lt;url&gt;</strong>完成repo完整的下载以及项目清单版本库（manifest.git）的下载。</p>
<div class="highlight-python"><div class="highlight"><pre>$ mkdir working-directory-name
$ cd working-directory-name
$ repo init -u git://android.git.kernel.org/platform/manifest.git
</pre></div>
</div>
<p>命令<strong class="command">repo init</strong>要完成如下操作：</p>
<ul>
<li><p class="first">完成repo这一工具的完整下载，因为现在有的不过是repo的引导程序。</p>
<p>初始化操作会从Android的代码中克隆<tt class="docutils literal"><span class="pre">repo.git</span></tt>库，到当前目录下的<tt class="file docutils literal"><span class="pre">.repo/repo</span></tt>目录下。在完成repo.git克隆之后，<cite>repo init</cite>命令会将控制权交给工作区的<tt class="file docutils literal"><span class="pre">.repo/repo/main.py</span></tt>这个刚刚从<tt class="docutils literal"><span class="pre">repo.git</span></tt>库克隆来的脚本文件，继续进行初始化。</p>
</li>
<li><p class="first">克隆 android 的清单库 manifest.git（地址来自于 -u 参数）。</p>
<p>克隆的清单库位于<tt class="file docutils literal"><span class="pre">.repo/manifests.git</span></tt>中，并本地克隆到<tt class="file docutils literal"><span class="pre">.repo/manifests</span></tt>。清单文件<tt class="file docutils literal"><span class="pre">.repo/manifest.xml</span></tt>是符号链接指向<tt class="file docutils literal"><span class="pre">.repo/manifests/default.xml</span></tt>。</p>
</li>
<li><p class="first">提问用户的姓名和邮件地址，如果和Git缺省的用户名、邮件地址不同，则记录在<tt class="file docutils literal"><span class="pre">.repo/manifests.git</span></tt>库的 config 文件中。</p>
</li>
<li><p class="first">命令<strong class="command">repo init</strong>还可以附带<tt class="docutils literal"><span class="pre">--mirror</span></tt>参数，以建立和上游Android的版本库一模一样的镜像。会在后面的章节介绍。</p>
</li>
</ul>
<p><strong>从哪里下载repo.git？</strong></p>
<p>在repo引导脚本的前几行，定义了缺省的repo.git的版本库位置以及要检出的缺省分支。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">REPO_URL</span><span class="o">=</span><span class="s">&#39;git://android.git.kernel.org/tools/repo.git&#39;</span>
<span class="n">REPO_REV</span><span class="o">=</span><span class="s">&#39;stable&#39;</span>
</pre></div>
</div>
<p>如果不想从缺省任务获取repo，或者不想获取稳定版（stable分支）的repo，可以在<strong class="command">repo init</strong>命令中通过下面的参数覆盖缺省的设置，从指定的源地址克隆repo代码库。</p>
<ul class="simple">
<li>参数<tt class="docutils literal"><span class="pre">--repo-url</span></tt>，用于设定repo的版本库地址。</li>
<li>参数<tt class="docutils literal"><span class="pre">--repo-branch</span></tt>，用于设定要检出的分支。</li>
<li>参数<tt class="docutils literal"><span class="pre">--no-repo-verify</span></tt>，设定不要对repo的里程碑签名进行严格的验证。</li>
</ul>
<p>实际上，完成<tt class="docutils literal"><span class="pre">repo.git</span></tt>版本库的克隆，这个repo引导脚本就江郎才尽了，<tt class="docutils literal"><span class="pre">init</span></tt>命令的后续处理（以及其他命令）都交给刚刚克隆出来的<tt class="file docutils literal"><span class="pre">.repo/repo/main.py</span></tt>来继续执行。</p>
<p><strong>清单库是什么？从哪里下载？</strong></p>
<p>清单库实际上只包含一个<tt class="file docutils literal"><span class="pre">default.xml</span></tt>文件。这个XML文件定义了多个版本库和本地地址的映射关系，是repo工作的指引文件。所以在使用repo引导脚本进行初始化的时候，必须通过<tt class="docutils literal"><span class="pre">-u</span></tt>参数指定清单库的源地址。</p>
<p>清单库的下载，是通过<strong class="command">repo init</strong>命令初始化时，用<tt class="docutils literal"><span class="pre">-u</span></tt>参数指定清单库的位置。例如repo针对Android代码库进行初始化时执行的命令：</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo init -u git://android.git.kernel.org/platform/manifest.git
</pre></div>
</div>
<p>Repo引导脚本的`` init``命令可以使用下列和清单库相关的参数：</p>
<ul class="simple">
<li>参数<tt class="docutils literal"><span class="pre">-u</span></tt>（<tt class="docutils literal"><span class="pre">--manifest-url</span></tt>）：设定清单库的Git服务器地址。</li>
<li>参数<tt class="docutils literal"><span class="pre">-b</span></tt>（<tt class="docutils literal"><span class="pre">--manifest-branch</span></tt>）：检出清单库特定分支。</li>
<li>参数<tt class="docutils literal"><span class="pre">--mirror</span></tt>：只在repo第一次初始化的时候使用，以和Android服务器同样的结构在本地建立镜像。</li>
<li>参数<tt class="docutils literal"><span class="pre">-m</span></tt>（<tt class="docutils literal"><span class="pre">--manifest-name</span></tt>）：当有多个清单文件，可以指定清单库的某个清单文件为有效的清单文件。缺省为<tt class="file docutils literal"><span class="pre">default.xml</span></tt>。</li>
</ul>
<p>Repo初始化命令（repo init）可以执行多次：</p>
<ul class="simple">
<li>不带参数的执行<strong class="command">repo init</strong>，从上游的清单库获取新的清单文件<tt class="file docutils literal"><span class="pre">default.xml</span></tt>。</li>
<li>使用参数<tt class="docutils literal"><span class="pre">-u</span></tt>（<tt class="docutils literal"><span class="pre">--manifest-url</span></tt>）执行<strong class="command">repo init</strong>，会重新设定上游的清单库地址，并重新同步。</li>
<li>使用参数<tt class="docutils literal"><span class="pre">-b</span></tt>（<tt class="docutils literal"><span class="pre">--manifest-branch</span></tt>）执行<strong class="command">repo init</strong>，会使用清单库的不同分支，以便在使用<strong class="command">repo sync</strong>时将项目同步到不同的里程碑。</li>
<li>但是不能使用<tt class="docutils literal"><span class="pre">--mirror</span></tt>命令，该命名只能在第一次初始化时执行。那么如何将已经按照工作区模式同步的版本库转换为镜像模式呢？会在后面看到一个解决方案。</li>
</ul>
</div>
<div class="section" id="id3">
<h2>4.6.4. 清单库和清单文件<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>当执行完毕<strong class="command">repo init</strong>之后，工作目录内空空如也。实际上有一个<tt class="file docutils literal"><span class="pre">.repo</span></tt>目录。在该目录下除了一个包含repo的实现的repo库克隆外，就是manifest库的克隆，以及一个符号链接链接到清单库中的<tt class="file docutils literal"><span class="pre">default.xml</span></tt>文件。</p>
<div class="highlight-python"><div class="highlight"><pre>$ ls -lF .repo/
drwxr-xr-x 3 jiangxin jiangxin 4096 2010-10-11 18:57 manifests/
drwxr-xr-x 8 jiangxin jiangxin 4096 2010-10-11 10:08 manifests.git/
lrwxrwxrwx 1 jiangxin jiangxin   21 2010-10-11 10:07 manifest.xml -&gt; manifests/default.xml
drwxr-xr-x 7 jiangxin jiangxin 4096 2010-10-11 10:07 repo/
</pre></div>
</div>
<p>在工作目录下的<tt class="file docutils literal"><span class="pre">.repo/manifest.xml</span></tt>文件就是Android项目的众多版本库的清单文件。Repo命令的操作，都要参考这个清单文件。</p>
<p>打开清单文件，会看到如下内容：</p>
<div class="highlight-python"><div class="highlight"><pre>  1  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
  2  &lt;manifest&gt;
  3    &lt;remote  name=&quot;korg&quot;
  4             fetch=&quot;git://android.git.kernel.org/&quot;
  5             review=&quot;review.source.android.com&quot; /&gt;
  6    &lt;default revision=&quot;master&quot;
  7             remote=&quot;korg&quot; /&gt;
  8
  9    &lt;project path=&quot;build&quot; name=&quot;platform/build&quot;&gt;
 10      &lt;copyfile src=&quot;core/root.mk&quot; dest=&quot;Makefile&quot; /&gt;
 11    &lt;/project&gt;
 12
 13    &lt;project path=&quot;bionic&quot; name=&quot;platform/bionic&quot; /&gt;

       ...

181  &lt;/manifest&gt;
</pre></div>
</div>
<p>这个文件不太复杂，是么？</p>
<ul class="simple">
<li>这个XML的顶级元素是<tt class="docutils literal"><span class="pre">manifest</span></tt>，见第2行和第181行。</li>
<li>第3行通过一个remote元素，定义了名为korg（kernel.org缩写）的源，其Git库的基址为<tt class="docutils literal"><span class="pre">git://android.git.kernel.org/</span></tt>，还定义了代码审核服务器的地址<tt class="docutils literal"><span class="pre">review.source.android.com</span></tt>。还可以定义更多的remote元素，这里只定义了一个。</li>
<li>第6行用于设置各个项目缺省的远程源地址（remote）为korg，缺省的分支为<tt class="docutils literal"><span class="pre">master</span></tt>。当然各个项目（project元素）可以定义自己的remote和revision覆盖该缺省配置。</li>
<li>第9行定义一个项目，该项目的远程版本库相对路径为：&#8221;platform/build&#8221;，在工作区克隆的位置为：&#8221;build&#8221;。</li>
<li>第10行，即project元素的子元素copyfile，定义了项目克隆后的一个附加动作：拷贝文件从<tt class="file docutils literal"><span class="pre">core/root.mk</span></tt>至<tt class="file docutils literal"><span class="pre">Makefile</span></tt>。</li>
<li>第13行后后续的100多行定义了其他160个项目，都是采用类似的project元素语法。<tt class="docutils literal"><span class="pre">name</span></tt>参数定义远程版本库的相对路径，<tt class="docutils literal"><span class="pre">path</span></tt>参数定义克隆到本地工作区的路径。</li>
<li>还可以出现<tt class="docutils literal"><span class="pre">manifest-server</span></tt>元素，其<tt class="docutils literal"><span class="pre">url</span></tt>属性定义了通过XMLRPC提供实时更新清单的服务器URL。只有当执行<strong class="command">repo sync &#8211;smart-sync</strong>的时候，才会检查该值，并用动态获取的manifest覆盖掉缺省的清单。</li>
</ul>
</div>
<div class="section" id="id4">
<h2>4.6.5. 同步项目<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>在工作区，执行下面的命令，会参照<tt class="file docutils literal"><span class="pre">.repo/manifest.xml</span></tt>清单文件，将项目所有相关的版本库全部克隆出来。不过最好请在读完本节内容之后再尝试执行这条命令。</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo sync
</pre></div>
</div>
<p>对于Android，这个操作需要通过网络传递接近2个GB的内容，如果带宽不是很高的话，可能会花掉几个小时甚至是一天的时间。</p>
<p>也可以仅克隆感兴趣的项目，在<strong class="command">repo sync</strong>后面跟上项目的名称。项目的名称来自于<tt class="file docutils literal"><span class="pre">.repo/manifest.xml</span></tt>这个XML文件中project元素的name属性值。例如克隆<tt class="docutils literal"><span class="pre">platform/build</span></tt>项目：</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo sync platform/build
</pre></div>
</div>
<p>Repo有一个功能可以在这里展示。就是repo支持通过本地清单，对缺省的清单文件进行补充以及覆盖。即可以在<tt class="file docutils literal"><span class="pre">.repo</span></tt>目录下创建<tt class="file docutils literal"><span class="pre">local_manifest.xml</span></tt>文件，其内容会和<tt class="file docutils literal"><span class="pre">.repo/manifest.xml</span></tt>文件的内容进行合并。</p>
<p>在工作目录下运行下面的命令，可以创建一个本地清单文件。这个本地定制的清单文件来自缺省文件，但是删除了<tt class="docutils literal"><span class="pre">remote</span></tt>元素和<tt class="docutils literal"><span class="pre">default</span></tt>元素，并将所有的<tt class="docutils literal"><span class="pre">project</span></tt>元素都重命名为<tt class="docutils literal"><span class="pre">remove-project</span></tt>元素。这实际相当于对原有的清单文件“取反”。</p>
<div class="highlight-python"><div class="highlight"><pre>$ sed -e &#39;/&lt;remote/,+4 d&#39; -e &#39;s/&lt;project/&lt;remove-project/g&#39; \
  -e &#39;s/project&gt;/remove-project&gt;/g&#39; \
  &lt; .repo/manifest.xml &gt; .repo/local_manifest.xml
</pre></div>
</div>
<p>用下面的这条命令可以看到repo运行时实际获取到的清单。这个清单来自于<tt class="file docutils literal"><span class="pre">.repo/manifest.xml</span></tt>和<tt class="file docutils literal"><span class="pre">.repo/local_manifest.xml</span></tt>两个文件的汇总。</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo manifest -o -
</pre></div>
</div>
<p>当执行<strong class="command">repo sync</strong>命令时，实际上就是依据合并后的清单文件进行同步。如果清单中的项目被自定义清单全部“取反”，执行同步就不会同步任何项目，甚至会删除已经完成同步的项目。</p>
<p>本地定制的清单文件<tt class="file docutils literal"><span class="pre">local_manifest.xml</span></tt>支持前面介绍的清单文件的所有语法，需要注意的是：</p>
<ul class="simple">
<li>不能出现重复定义的<tt class="docutils literal"><span class="pre">remote</span></tt>元素。这就是为什么上面的脚本要删除来自缺省<tt class="docutils literal"><span class="pre">manifest.xml</span></tt>的<tt class="docutils literal"><span class="pre">remote</span></tt>元素。</li>
<li>不能出现<tt class="docutils literal"><span class="pre">default</span></tt>元素，仅为全局仅能有一个。</li>
<li>不能出现重复的<tt class="docutils literal"><span class="pre">project</span></tt>定义（<tt class="docutils literal"><span class="pre">name</span></tt>属性不能相同），但是可以通过<tt class="docutils literal"><span class="pre">remove-project</span></tt>元素将缺省清单中定义的<tt class="docutils literal"><span class="pre">project</span></tt>删除再重新定义。</li>
</ul>
<p>试着编辑<tt class="file docutils literal"><span class="pre">.repo/local_manifest.xml</span></tt>，在其中再添加几个<tt class="docutils literal"><span class="pre">project</span></tt>元素，然后试着用<strong class="command">repo sync</strong>命令进行同步。</p>
</div>
<div class="section" id="id5">
<h2>4.6.6. 建立Android代码库本地镜像<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>Android为企业提供一个新的市场，无论大企业，小企业都是处于同一个起跑线上。研究Android尤其是Android系统核心或者是驱动的开发，首先需要做的就是本地克隆建立一套Android版本库管理机制。因为Android的代码库是那么庞杂，如果一个开发团队每个人都去执行<strong class="command">repo init -u</strong>，再执行<strong class="command">repo sync</strong>从Android服务器克隆版本库的话，多大的网络带宽恐怕都不够用。唯一的办法是本地建立一个Android版本库的镜像。</p>
<p>建立本地镜像非常简单，就是在执行<strong class="command">repo init -u</strong>初始化的时候，附带上<tt class="docutils literal"><span class="pre">--mirror</span></tt>参数。</p>
<div class="highlight-python"><div class="highlight"><pre>$ mkdir android-mirror-dir
$ cd android-mirror-dir
$ repo init --mirror -u git://android.git.kernel.org/platform/manifest.git
</pre></div>
</div>
<p>之后执行<strong class="command">repo sync</strong>就可以安装Android的Git服务器方式来组织版本库，创建一个Android版本库镜像。</p>
<p>实际上附带了<tt class="docutils literal"><span class="pre">--mirror</span></tt>参数执行<strong class="command">repo init -u</strong>命令，会在克隆的<tt class="file docutils literal"><span class="pre">.repo/manifests.git</span></tt>下的<tt class="file docutils literal"><span class="pre">config</span></tt>中记录配置信息：</p>
<div class="highlight-python"><div class="highlight"><pre>[repo]
    mirror = true
</pre></div>
</div>
<p><strong>从Android的工作区到代码库镜像</strong></p>
<p>在初始化repo工作区时，如果使用不带<tt class="docutils literal"><span class="pre">--mirror</span></tt>参数的<strong class="command">repo init -u</strong>，并完成代码同步后，如果再次执行<strong class="command">repo init</strong>并附带了<tt class="docutils literal"><span class="pre">--mirror</span></tt>参数，repo 会报错退出：“fatal: &#8211;mirror not supported on existing client”。实际上<tt class="docutils literal"><span class="pre">--mirror</span></tt>参数只能对尚未初始化的repo工作区执行。</p>
<p>那么如果之前没有用镜像的方法同步Android版本库，难道要为创建代码库镜像再重新执行一次repo同步么？要知道重新同步一份Android版本库是非常慢的。我就遇到了这个问题。</p>
<p>不过既然有<tt class="file docutils literal"><span class="pre">manifest.xml`</span></tt>文件，完全可以对工作区进行反向操作，将工作区转换为镜像服务器的结构。下面就是一个示例脚本，这个脚本利用了已有的repo代码进行实现，所以看着很简洁。8-)</p>
<p>脚本<tt class="file docutils literal"><span class="pre">work2mirror.py</span></tt>如下：</p>
<div class="highlight-python"><div class="highlight"><pre>#!/usr/bin/python
# -*- coding: utf-8 -*-

import os, sys, shutil

cwd = os.path.abspath( os.path.dirname( __file__ ) )
repodir = os.path.join( cwd, &#39;.repo&#39; )
S_repo = &#39;repo&#39;
TRASHDIR = &#39;old_work_tree&#39;

if not os.path.exists( os.path.join(repodir, S_repo) ):
    print &gt;&gt; sys.stderr, &quot;Must run under repo work_dir root.&quot;
    sys.exit(1)

sys.path.insert( 0, os.path.join(repodir, S_repo) )
from manifest_xml import XmlManifest

manifest = XmlManifest( repodir )

if manifest.IsMirror:
    print &gt;&gt; sys.stderr, &quot;Already mirror, exit.&quot;
    sys.exit(1)

trash = os.path.join( cwd, TRASHDIR )

for project in manifest.projects.itervalues():
    # 移动旧的版本库路径到镜像模式下新的版本库路径
    newgitdir = os.path.join( cwd, &#39;%s.git&#39; % project.name )
    if os.path.exists( project.gitdir ) and project.gitdir != newgitdir:
        if not os.path.exists( os.path.dirname(newgitdir) ):
            os.makedirs( os.path.dirname(newgitdir) )
        print &quot;Rename %s to %s.&quot; % (project.gitdir, newgitdir)
        os.rename( project.gitdir, newgitdir )

    # 移动工作区到待删除目录
    if project.worktree and os.path.exists( project.worktree ):
        newworktree = os.path.join( trash, project.relpath )
        if not os.path.exists( os.path.dirname(newworktree) ):
            os.makedirs( os.path.dirname(newworktree) )
        print &quot;Move old worktree %s to %s.&quot; % (project.worktree, newworktree )
        os.rename( project.worktree, newworktree )

    if os.path.exists ( os.path.join( newgitdir, &#39;config&#39; ) ):
        # 修改版本库的配置
        os.chdir( newgitdir )
        os.system( &quot;git config core.bare true&quot; )
        os.system( &quot;git config remote.korg.fetch &#39;+refs/heads/*:refs/heads/*&#39;&quot; )

        # 删除 remotes 分支，因为作为版本库镜像不需要 remote 分支
        if os.path.exists ( os.path.join( newgitdir, &#39;refs&#39;, &#39;remotes&#39; ):
            print &quot;Delete &quot; + os.path.join( newgitdir, &#39;refs&#39;, &#39;remotes&#39; )
            shutil.rmtree( os.path.join( newgitdir, &#39;refs&#39;, &#39;remotes&#39;) )

# 设置 menifest 为镜像
mp = manifest.manifestProject
mp.config.SetString(&#39;repo.mirror&#39;, &#39;true&#39;)
</pre></div>
</div>
<p>使用方法很简单，只要将脚本放在Android工作区下，执行就可以了。执行完毕会将原有工作区的目录移动到<tt class="file docutils literal"><span class="pre">old_work_tree</span></tt>子目录下，在确认原有工作区没有未提交的数据后，直接删除<tt class="file docutils literal"><span class="pre">old_work_tree</span></tt>即可。</p>
<div class="highlight-python"><div class="highlight"><pre>$ python work2mirror.py
</pre></div>
</div>
<p><strong>创建新的清单库，或修改原有清单库</strong></p>
<p>建立了Android代码库的本地镜像后，如果不对<tt class="docutils literal"><span class="pre">manifest</span></tt>清单版本库进行定制，在使用<strong class="command">repo sync</strong>同步代码的时候，仍然使用Android官方的代码库同步代码，使得本地的镜像版本库形同虚设。解决办法是创建一个自己的<tt class="docutils literal"><span class="pre">manifest</span></tt>库，或者在原有清单库中建立一个分支加以修改。如果创建新的清单库，参考Android上游的<tt class="docutils literal"><span class="pre">manifest</span></tt>清单库进行创建。</p>
</div>
<div class="section" id="id6">
<h2>4.6.7. Repo的命令集<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>Repo命令实际上是Git命令的简单或者复杂的封装。每一个repo命令都对应于repo源码树中<tt class="file docutils literal"><span class="pre">subcmds</span></tt>目录下的一个同名的Python脚本。每一个repo命令都可以通过下面的命令获得帮助。</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo help &lt;command&gt;
</pre></div>
</div>
<p>通过阅读代码，可以更加深入的了解repo命令的封装。</p>
<div class="section" id="repo-init">
<h3>4.6.7.1. <strong class="command">repo init</strong>命令<a class="headerlink" href="#repo-init" title="永久链接至标题">¶</a></h3>
<p><strong class="command">repo init</strong>命令，主要完成检出清单版本库（<tt class="docutils literal"><span class="pre">manifest.git</span></tt>），以及配置Git用户的用户名和邮件地址的工作。</p>
<p>实际上，完全可以进入到<tt class="file docutils literal"><span class="pre">.repo/manifests</span></tt>目录，用git命令操作清单库。对<tt class="docutils literal"><span class="pre">manifests</span></tt>的修改不会因为执行<strong class="command">repo init</strong>而丢失，除非是处于未跟踪状态。</p>
</div>
<div class="section" id="repo-sync">
<h3>4.6.7.2. <strong class="command">repo sync</strong>命令<a class="headerlink" href="#repo-sync" title="永久链接至标题">¶</a></h3>
<p><strong class="command">repo sync</strong>命令用于参照清单文件克隆或者同步版本库。如果某个项目版本库尚不存在，则执行<strong class="command">repo sync</strong>命令相当于执行<strong class="command">git clone</strong>。如果项目版本库已经存在，则相当于执行下面的两个命令：</p>
<ul>
<li><p class="first">git remote update</p>
<p>相当于对每一个remote源执行<tt class="docutils literal"><span class="pre">fetch</span></tt>操作。</p>
</li>
<li><p class="first">git rebase origin/branch</p>
<p>针对当前分支的跟踪分支，执行<tt class="docutils literal"><span class="pre">rebase</span></tt>操作。不采用<tt class="docutils literal"><span class="pre">merge</span></tt>而是采用<tt class="docutils literal"><span class="pre">rebase</span></tt>，目的是减少提交数量，方便评审(Gerrit)。</p>
</li>
</ul>
</div>
<div class="section" id="repo-start">
<h3>4.6.7.3. <strong class="command">repo start</strong>命令<a class="headerlink" href="#repo-start" title="永久链接至标题">¶</a></h3>
<p><strong class="command">repo start</strong>命令实际上是对<strong class="command">git checkout -b</strong>命令的封装。为指定的项目或者所有项目（若使用<tt class="docutils literal"><span class="pre">--all</span></tt>参数），以清单文件中为项目设定的分支或里程碑为基础，创建特性分支。特性分支的名称由命令的第一个参数指定。相当于执行<strong class="command">git checkout -b</strong>。</p>
<p>用法:</p>
<div class="highlight-python"><div class="highlight"><pre>repo start &lt;newbranchname&gt; [--all | &lt;project&gt;...]
</pre></div>
</div>
</div>
<div class="section" id="repo-status">
<h3>4.6.7.4. <strong class="command">repo status</strong>命令<a class="headerlink" href="#repo-status" title="永久链接至标题">¶</a></h3>
<p><strong class="command">repo status</strong>命令实际上是对<strong class="command">git diff-index</strong>、<strong class="command">git diff-files</strong>命令的封装，同时显示暂存区的状态和本地文件修改的状态。</p>
<p>用法：</p>
<div class="highlight-python"><div class="highlight"><pre>repo status [&lt;project&gt;...]
</pre></div>
</div>
<p>示例输出：</p>
<div class="highlight-python"><div class="highlight"><pre>project repo/                                   branch devwork
 -m     subcmds/status.py
 ...
</pre></div>
</div>
<p>上面示例输出显示了repo项目的<tt class="docutils literal"><span class="pre">devwork</span></tt>分支的修改状态。</p>
<ul>
<li><p class="first">每个小节的首行显示项目名称，以及所在分支名称。</p>
</li>
<li><p class="first">之后显示该项目中文件变更状态。头两个字母显示变更状态，后面显示文件名或者其他变更信息。</p>
</li>
<li><p class="first">第一个字母表示暂存区的文件修改状态。</p>
<p>其实是<strong class="command">git-diff-index</strong>命令输出中的状态标识，并用大写显示。</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-</span></tt>：没有改变</li>
<li><tt class="docutils literal"><span class="pre">A</span></tt>：添加          （不在HEAD中，  在暂存区                ）</li>
<li><tt class="docutils literal"><span class="pre">M</span></tt>：修改          （  在HEAD中，  在暂存区，内容不同      ）</li>
<li><tt class="docutils literal"><span class="pre">D</span></tt>：删除          （  在HEAD中，不在暂存区                ）</li>
<li><tt class="docutils literal"><span class="pre">R</span></tt>：重命名        （不在HEAD中，  在暂存区，路径修改      ）</li>
<li><tt class="docutils literal"><span class="pre">C</span></tt>：拷贝          （不在HEAD中，  在暂存区，从其他文件拷贝）</li>
<li><tt class="docutils literal"><span class="pre">T</span></tt>：文件状态改变  （  在HEAD中，  在暂存区，内容相同      ）</li>
<li><tt class="docutils literal"><span class="pre">U</span></tt>：未合并，需要冲突解决</li>
</ul>
</li>
<li><p class="first">第二个字母表示工作区文件的更改状态。</p>
<p>其实是<strong class="command">git-diff-files</strong>命令输出中的状态标识，并用小写显示。</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-</span></tt>：新/未知       （不在暂存区，  在工作区                ）</li>
<li><tt class="docutils literal"><span class="pre">m</span></tt>：修改          （  在暂存区，  在工作区，被修改        ）</li>
<li><tt class="docutils literal"><span class="pre">d</span></tt>：删除          （  在暂存区，不在工作区                ）</li>
</ul>
</li>
<li><p class="first">两个表示状态的字母后面，显示文件名信息。如果有文件重命名还会显示改变前后的文件名以及文件的相似度。</p>
</li>
</ul>
</div>
<div class="section" id="repo-checkout">
<h3>4.6.7.5. <strong class="command">repo checkout</strong>命令<a class="headerlink" href="#repo-checkout" title="永久链接至标题">¶</a></h3>
<p><strong class="command">repo checkout</strong>命令实际上是对<strong class="command">git checkout</strong>命令的封装。检出之前由<strong class="command">repo start</strong>创建的分支。</p>
<p>用法：</p>
<div class="highlight-python"><div class="highlight"><pre>repo checkout &lt;branchname&gt; [&lt;project&gt;...]
</pre></div>
</div>
</div>
<div class="section" id="repo-branches">
<h3>4.6.7.6. <strong class="command">repo branches</strong>命令<a class="headerlink" href="#repo-branches" title="永久链接至标题">¶</a></h3>
<p><strong class="command">repo branches</strong>命令读取各个项目的分支列表并汇总显示。该命令实际上是通过直接读取<tt class="file docutils literal"><span class="pre">.git/refs</span></tt>目录下的引用来获取分支列表，以及分支的发布状态等。</p>
<p>用法：</p>
<div class="highlight-python"><div class="highlight"><pre>repo branches [&lt;project&gt;...]
</pre></div>
</div>
<p>输出示例：</p>
<div class="highlight-python"><div class="highlight"><pre>*P nocolor                   | in repo
   repo2                     |
</pre></div>
</div>
<ul>
<li><p class="first">第一个字段显示分支的状态：是否是当前分支，分支是否发布到代码审核服务器上？</p>
</li>
<li><p class="first">第一个字母若显示星号(*)，含义是此分支为当前分支</p>
</li>
<li><p class="first">第二个字母若为大写字母<tt class="docutils literal"><span class="pre">P</span></tt>，则含义是分支所有提交都发布到代码审核服务器上了。</p>
</li>
<li><p class="first">第二个字母若为小写字母<tt class="docutils literal"><span class="pre">p</span></tt>，则含义是只有部分提交被发布到代码审核服务器上。</p>
</li>
<li><p class="first">若不显示<tt class="docutils literal"><span class="pre">P</span></tt>或者<tt class="docutils literal"><span class="pre">p</span></tt>，则表明分支尚未发布。</p>
</li>
<li><p class="first">第二个字段为分支名。</p>
</li>
<li><p class="first">第三个字段为以竖线（|）开始的字符串，表示该分支存在于哪些项目中。</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">|</span> <span class="pre">in</span> <span class="pre">all</span> <span class="pre">projects</span></tt></p>
<p>该分支处于所有项目中。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">|</span> <span class="pre">in</span> <span class="pre">project1</span> <span class="pre">project2</span></tt></p>
<p>该分支只在特定项目中定义。如：<tt class="docutils literal"><span class="pre">project1</span></tt>、<tt class="docutils literal"><span class="pre">project2</span></tt>。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">|</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">project1</span></tt></p>
</li>
</ul>
<blockquote>
<div><p>该分支不存在于这些项目中。即除了<tt class="docutils literal"><span class="pre">project1</span></tt>项目外，其他项目都包含此分支。</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="repo-diff">
<h3>4.6.7.7. <strong class="command">repo diff</strong>命令<a class="headerlink" href="#repo-diff" title="永久链接至标题">¶</a></h3>
<p><strong class="command">repo diff</strong>命令实际上是对<strong class="command">git diff</strong>命令的封装，用以分别显示各个项目工作区下的文件差异。</p>
<p>用法：</p>
<div class="highlight-python"><div class="highlight"><pre>repo diff [&lt;project&gt;...]
</pre></div>
</div>
</div>
<div class="section" id="repo-stage">
<h3>4.6.7.8. <strong class="command">repo stage</strong>命令<a class="headerlink" href="#repo-stage" title="永久链接至标题">¶</a></h3>
<p><strong class="command">repo stage</strong>命令实际上是对<strong class="command">git add &#8211;interactive</strong>命令的封装，用以对各个项目工作区中的改动（修改、添加等）进行挑选以加入暂存区。</p>
<p>用法：</p>
<div class="highlight-python"><div class="highlight"><pre>repo stage -i [&lt;project&gt;...]
</pre></div>
</div>
</div>
<div class="section" id="repo-upload">
<h3>4.6.7.9. <strong class="command">repo upload</strong>命令<a class="headerlink" href="#repo-upload" title="永久链接至标题">¶</a></h3>
<p><strong class="command">repo upload</strong>命令相当于<strong class="command">git push</strong>，但是又有很大的不同。执行<strong class="command">repo upload</strong>不是将版本库改动推送到克隆时的远程服务器，而是推送到代码审查服务器（由Gerrit软件架设）的特殊引用上，使用的是SSH协议（特殊端口）。代码审核服务器会对推送的提交进行特殊处理，将新的提交显示为一个待审核的修改集，并进入代码审查流程。只有当审核通过，才会合并到官方正式的版本库中。</p>
<p>用法：</p>
<div class="highlight-python"><div class="highlight"><pre>repo upload [--re --cc] {[&lt;project&gt;]... | --replace &lt;project&gt;}

参数：
  -h, --help            显示帮助信息。
  -t                    发送本地分支名称到 Gerrit 代码审核服务器。
  --replace             发送此分支的更新补丁集。注意使用该参数，只能指定一个项目。
  --re=REVIEWERS, --reviewers=REVIEWERS
                        要求由指定的人员进行审核。
  --cc=CC               同时发送通知到如下邮件地址。
</pre></div>
</div>
<p><strong>确定推送服务器的端口</strong></p>
<p>分支改动的推送是发给代码审核服务器，而不是下载代码的服务器。使用的协议是SSH协议，但是使用的并非标准端口。如何确认代码审核服务器上提供的特殊SSH端口呢？</p>
<p>在执行<strong class="command">repo upload</strong>命令时，repo会通过访问代码审核Web服务器的 <tt class="docutils literal"><span class="pre">/ssh_info</span></tt>的URL获取SSH服务端口，缺省29418。这个端口，就是<strong class="command">repo upload</strong>发起推送的服务器的SSH服务端口。</p>
<p><strong>修订集修改后重新传送</strong></p>
<p>当已经通过<strong class="command">repo upload</strong>命令在代码审查服务器上提交了一个修订集，会得到一个修订号。关于此次修订的相关讨论会发送到提交者的邮箱中。如果修订集有误没有通过审核，可以重新修改代码，再次向代码审核服务器上传修订集。</p>
<p>一个修订集修改后再次上传，如果修订集的ID不变是非常有用的，因为这样相关的修订集都在代码审核服务器的同一个界面中显示。</p>
<p>在执行<strong class="command">repo upload</strong>时会弹出一个编辑界面，提示在方括号中输入修订集编号，否则会在代码审查服务器上创建新的ID。有一个办法可以不用手工输入修订集，如下：</p>
<div class="highlight-python"><div class="highlight"><pre>repo upload --replace project_name
</pre></div>
</div>
<p>当使用<tt class="docutils literal"><span class="pre">--replace</span></tt>参数后，repo会检查本地版本库名为<tt class="docutils literal"><span class="pre">refs/published/branch_name</span></tt>的特殊引用（上一次提交的修订），获得其对应的提交SHA1哈希值。然后在代码审核服务器的<tt class="docutils literal"><span class="pre">refs/changes/</span></tt>命名空间下的特殊引用中寻找和提交SHA1哈希值匹配的引用，找到的匹配引用其名称中就所包含有变更集ID，直接用此变更集ID作为新的变更集ID提交到代码审核服务器。</p>
<p><strong>Gerrit服务器魔法</strong></p>
<p><strong class="command">repo upload</strong>命令执行推送，实际上会以类似如下的命令行格式进行调用：</p>
<div class="highlight-python"><div class="highlight"><pre>git push --receive-pack=&#39;gerrit receive-pack --reviewer charlie@example.com&#39; \
         ssh://review.example.com:29418/project HEAD:refs/for/master
</pre></div>
</div>
<p>当Gerrit服务器接收到<strong class="command">git push</strong>请求后，会自动将对分支的提交转换为修订集，显示于Gerrit的提交审核界面中。Gerrit的魔法破解的关键点就在于<strong class="command">git push</strong>命令的<tt class="docutils literal"><span class="pre">--receive-pack</span></tt>参数。即提交交由<strong class="command">gerrit-receive-pack</strong>命令执行，进入非标准的Git处理流程，将提交转换为在<tt class="docutils literal"><span class="pre">refs/changes</span></tt>命名空间下的引用，而不在<tt class="docutils literal"><span class="pre">refs/for</span></tt>命名空间下创建引用。</p>
</div>
<div class="section" id="repo-download">
<h3>4.6.7.10. <strong class="command">repo download</strong>命令<a class="headerlink" href="#repo-download" title="永久链接至标题">¶</a></h3>
<p><strong class="command">repo download</strong>命令主要用于代码审核者下载和评估贡献者提交的修订。贡献者的修订在Git版本库中以<tt class="docutils literal"><span class="pre">refs/changes/&lt;changeid&gt;/&lt;patchset&gt;</span></tt>引用方式命名（缺省的patchset为1），和其他Git引用一样，用<strong class="command">git fetch</strong>获取，该引用所指向的最新的提交就是贡献者待审核的修订。使用<strong class="command">repo download</strong>命令实际上就是用<strong class="command">git fetch</strong>获取到对应项目的<tt class="docutils literal"><span class="pre">refs/changes/&lt;changeid&gt;/patchset&gt;</span></tt>引用，并自动切换到对应的引用上。</p>
<p>用法：</p>
<div class="highlight-python"><div class="highlight"><pre>repo download {project change[/patchset]}...
</pre></div>
</div>
</div>
<div class="section" id="repo-rebase">
<h3>4.6.7.11. <strong class="command">repo rebase</strong>命令<a class="headerlink" href="#repo-rebase" title="永久链接至标题">¶</a></h3>
<p><strong class="command">repo rebase</strong>命令实际上是对<strong class="command">git rebase</strong>命令的封装，该命令的参数也作为<strong class="command">git rebase</strong>命令的参数。但 -i 参数仅当对一个项执行时有效。</p>
<p>用法：</p>
<div class="highlight-python"><div class="highlight"><pre>命令行: repo rebase {[&lt;project&gt;...] | -i &lt;project&gt;...}

参数:
  -h, --help          显示帮助并退出
  -i, --interactive   交互式的变基（仅对一个项目时有效）
  -f, --force-rebase  向 git rebase 命令传递 --force-rebase 参数
  --no-ff             向 git rebase 命令传递 -no-ff 参数
  -q, --quiet         向 git rebase 命令传递 --quiet 参数
  --autosquash        向 git rebase 命令传递 --autosquash  参数
  --whitespace=WS     向 git rebase 命令传递 --whitespace  参数
</pre></div>
</div>
</div>
<div class="section" id="repo-prune">
<h3>4.6.7.12. <strong class="command">repo prune</strong>命令<a class="headerlink" href="#repo-prune" title="永久链接至标题">¶</a></h3>
<p><strong class="command">repo prune</strong>命令实际上是对<strong class="command">git branch -d</strong>命令的封装，该命令用于扫描项目的各个分支，并删除已经合并的分支。</p>
<p>用法：</p>
<div class="highlight-python"><div class="highlight"><pre>repo prune [&lt;project&gt;...]
</pre></div>
</div>
</div>
<div class="section" id="repo-abandon">
<h3>4.6.7.13. <strong class="command">repo abandon</strong>命令<a class="headerlink" href="#repo-abandon" title="永久链接至标题">¶</a></h3>
<p>相比<strong class="command">repo prune</strong>命令，<strong class="command">repo abandon</strong>命令更具破坏性，因为<strong class="command">repo abandon</strong>是对<strong class="command">git branch -D</strong>命令的封装。该命令非常危险，直接删除分支，请慎用。</p>
<p>用法：</p>
<div class="highlight-python"><div class="highlight"><pre>repo abandon &lt;branchname&gt; [&lt;project&gt;...]
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>4.6.7.14. 其他命令<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first"><strong class="command">repo grep</strong></p>
<p>相当于对<strong class="command">git grep</strong>的封装，用于在项目文件中进行内容查找。</p>
</li>
<li><p class="first"><strong class="command">repo smartsync</strong></p>
<p>相当于用<tt class="docutils literal"><span class="pre">-s</span></tt>参数执行<strong class="command">repo sync</strong>。</p>
</li>
<li><p class="first"><strong class="command">repo forall</strong></p>
<p>迭代器，可以对repo管理的项目进行迭代。</p>
</li>
<li><p class="first"><strong class="command">repo manifest</strong></p>
<p>显示<tt class="file docutils literal"><span class="pre">manifest</span></tt>文件内容。</p>
</li>
<li><p class="first"><strong class="command">repo version</strong></p>
<p>显示repo的版本号。</p>
</li>
<li><p class="first"><strong class="command">repo selfupdate</strong></p>
<dl class="docutils">
<dt>用于repo自身的更新。如果提供<tt class="docutils literal"><span class="pre">--repo-upgraded</span></tt>参数，还会更新各个</dt>
<dd><p class="first last">项目的钩子脚本。</p>
</dd>
</dl>
</li>
</ul>
</div>
</div>
<div class="section" id="id8">
<h2>4.6.8. Repo命令的工作流<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>图25-1是repo的工作流，每一个代码贡献都起始于<strong class="command">repo start</strong>创建本地工作分支，最终都以<strong class="command">repo upload</strong>命令将代码补丁发布于代码审核服务器。</p>
<div class="figure">
<a class="reference internal image-reference" href="../images/repo-workflow.png"><img alt="../images/repo-workflow.png" src="../images/repo-workflow.png" style="width: 633.6px; height: 301.6px;" /></a>
<p class="caption">图25-1：repo工作流</p>
</div>
</div>
<div class="section" id="id9">
<h2>4.6.9. 好东西不能Android独享<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>通过前面的介绍能够体会到repo的精巧——repo巧妙的实现了多Git版本库的管理。因为repo使用了清单版本库，所以repo这一工具并没有被局限于Android项目，可以在任何项目中使用。下面就介绍三种repo的使用模式，将repo引入自己的（非Android）项目中，其中第三种repo使用模式是用作者改造后的repo实现脱离Gerrit服务器进行推送。</p>
<div class="section" id="repo-gerrit">
<h3>4.6.9.1. Repo+Gerrit模式<a class="headerlink" href="#repo-gerrit" title="永久链接至标题">¶</a></h3>
<p>Repo和Gerrit是Android代码管理的两大支柱。正如前面在repo工作流中介绍的，部分的repo命令从Git服务器读取，这个Git服务器可以是只读的版本库控制服务器，还有部分repo命令（<strong class="command">repo upload</strong>、<strong class="command">repo download</strong>）访问的则是代码审核服务器，其中<strong class="command">repo upload</strong>命令还要向代码审核服务器进行<strong class="command">git push</strong>操作。</p>
<p>在使用未经改动的repo来维护自己的项目（多个版本库组成）时，必须搭建Gerrit代码审核服务器。</p>
<p>搭建项目的版本控制系统环境的一般方法为：</p>
<ul class="simple">
<li>用git-daemon或者http服务搭建Git服务器。具体搭建方法参见第5篇“搭建Git服务器”相关章节。</li>
<li>导入<tt class="docutils literal"><span class="pre">repo.git</span></tt>工具库。非必须，只是为了减少不必要的互联网操作。</li>
<li>还可以在内部http服务器维护一个定制的repo引导脚本。非必须。</li>
<li>建立Gerrit代码审核服务器。会在第5篇第32章“Gerrit代码审核服务器”中介绍Gerrit的安装和使用。</li>
<li>将相关的子项目代码库一一创建。</li>
<li>建立一个<tt class="docutils literal"><span class="pre">manifest.git</span></tt>清单库，其中<tt class="docutils literal"><span class="pre">remote</span></tt>元素的<tt class="docutils literal"><span class="pre">fetch</span></tt>属性指向只读Git服务器地址，<tt class="docutils literal"><span class="pre">review</span></tt>属性指向代码审核服务器地址。</li>
</ul>
<p>示例如下：</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;manifest&gt;
  &lt;remote  name=&quot;example&quot;
           fetch=&quot;git://git.example.net/&quot;
           review=&quot;review.example.net&quot; /&gt;
  &lt;default revision=&quot;master&quot;
           remote=&quot;example&quot; /&gt;

  ...
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id10">
<h3>4.6.9.2. Repo无审核模式<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>Gerrit代码审核服务器部署比较麻烦，更不要说因为Gerrit用户界面的学习和用户使用习惯的更改而带来的困难了。在一个固定的团队内部使用repo可能真的没有必要使用Gerrit，因为团队成员都应该熟悉Git的操作，团队成员的编程能力都可信，单元测试质量由提交者保证，集成测试由单独的测试团队进行，即团队拥有一套完整、成型的研发工作流，引入Gerrit并非必要。</p>
<p>脱离了Gerrit服务器，直接跟Git服务器打交道，repo可以工作么？是的，可以利用<strong class="command">repo forall</strong>迭代器实现多项目代码的PUSH，其中有如下关键点需要重点关注。</p>
<ul>
<li><p class="first"><strong class="command">repo start</strong>命令创建本地分支时，需要使用和上游同样的分支名。</p>
<p>如果使用不同的分支名，上传时需要提供复杂的引用描述。下面的示例先通过<strong class="command">repo manifest</strong>命令确认上游清单库缺省的分支名为<tt class="docutils literal"><span class="pre">master</span></tt>，再使用该分支名（<tt class="docutils literal"><span class="pre">master</span></tt>）作为本地分支名执行<strong class="command">repo start</strong>。示例如下：</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo manifest -o - | grep default
  &lt;default remote=&quot;bj&quot; revision=&quot;master&quot;/&gt;

$ repo start master --all
</pre></div>
</div>
</li>
<li><p class="first">推送不能使用<strong class="command">repo upload</strong>，而需要使用<strong class="command">git push</strong>命令。</p>
<p>可以利用<strong class="command">repo forall</strong>迭代器实现批命令方式执行。例如：</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo forall -c git push
</pre></div>
</div>
</li>
<li><p class="first">如果清单库中的上游Git库地址用的是只读地址，需要为本地版本库一一更改上游版本库地址。</p>
<p>可以使用<tt class="docutils literal"><span class="pre">forall</span></tt>迭代器，批量为版本库设置<strong class="command">git push</strong>时的版本库地址。下面的命令使用了环境变量<tt class="docutils literal"><span class="pre">$REPO_PROJECT</span></tt>是实现批量设置的关键。</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo forall -c \
  &#39;git remote set-url --push bj android@bj.ossxp.com:android/${REPO_PROJECT}.git&#39;
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="id11">
<h3>4.6.9.3. 改进的Repo无审核模式<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>前面介绍的使用<strong class="command">repo forall</strong>迭代器实现在无审核服务器情况下向上游推送提交，只是权宜之计，尤其是用<strong class="command">repo start</strong>建立工作分支要求和上游一致，实在是有点强人所难。</p>
<p>我改造了repo，增加了两个新的命令<strong class="command">repo config</strong>和<strong class="command">repo push</strong>，让repo可以脱离Gerrit服务器直接向上游推送。代码托管在Github上：<a class="reference external" href="http://github.com/ossxp-com/repo.git">http://github.com/ossxp-com/repo.git</a>。下面简单介绍一下如何使用改造之后的repo。</p>
<div class="section" id="id12">
<h4>4.6.9.3.1. 下载改造后的repo引导脚本<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h4>
<p>建议使用改造后的repo引导脚本替换原脚本，否则在执行<strong class="command">repo init</strong>命令需要提供额外的<tt class="docutils literal"><span class="pre">--no-repo-verify</span></tt>参数，以及<tt class="docutils literal"><span class="pre">--repo-url</span></tt>和<tt class="docutils literal"><span class="pre">--repo-branch</span></tt>参数。</p>
<div class="highlight-python"><div class="highlight"><pre>$ curl http://github.com/ossxp-com/repo/raw/master/repo &gt; ~/bin/repo
$ chmod a+x ~/bin/repo
</pre></div>
</div>
</div>
<div class="section" id="repogithub">
<h4>4.6.9.3.2. 用repo从Github上检出测试项目<a class="headerlink" href="#repogithub" title="永久链接至标题">¶</a></h4>
<p>如果安装了改造后的repo引导脚本，使用下面的命令初始化repo及清单库。</p>
<div class="highlight-python"><div class="highlight"><pre>$ mkdir test
$ cd test
$ repo init -u git://github.com/ossxp-com/manifest.git
$ repo sync
</pre></div>
</div>
<p>如果用的是标准的（未经改造的）repo引导脚本，用下面的命令。</p>
<div class="highlight-python"><div class="highlight"><pre>$ mkdir test
$ cd test
$ repo init --repo-url=git://github.com/ossxp-com/repo.git \
  --repo-branch=master --no-repo-verify \
  -u git://github.com/ossxp-com/manifest.git
$ repo sync
</pre></div>
</div>
<p>当子项目代码全部同步完成后，执行make命令。可以看到各个子项目的版本以及清单库的版本。</p>
<div class="highlight-python"><div class="highlight"><pre>$ make
Version of test1:    1:0.2-dev
Version of test2:    2:0.2
Version of manifest: current
</pre></div>
</div>
</div>
<div class="section" id="repo-configpushurl">
<h4>4.6.9.3.3. 用<strong class="command">repo config</strong>命令设置pushurl<a class="headerlink" href="#repo-configpushurl" title="永久链接至标题">¶</a></h4>
<p>现在如果进入到各个子项目目录，是无法成功执行<strong class="command">git push</strong>命令的，因为上游Git库的地址是一个只读访问的URL，无法提供写服务。可以用新增的<strong class="command">repo config</strong>命令设置当执行<strong class="command">git push</strong>时的URL地址。</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo config repo.pushurl ssh://git@github.com/ossxp-com/
</pre></div>
</div>
<p>设置成功后，可以使用<strong class="command">repo config repo.pushurl</strong>查看设置。</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo config repo.pushurl
ssh://git@github.com/ossxp-com/
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h4>4.6.9.3.4. 创建本地工作分支<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h4>
<p>使用下面的命令创建一个工作分支<tt class="docutils literal"><span class="pre">jiangxin</span></tt>。</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo start jiangxin --all
</pre></div>
</div>
<p>使用<strong class="command">repo branches</strong>命令可以查看当前所有的子项目都属于<tt class="docutils literal"><span class="pre">jiangxin</span></tt>分支</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo branches
*  jiangxin                  | in all projects
</pre></div>
</div>
<p>参照下面的方法修改<tt class="docutils literal"><span class="pre">test/test1</span></tt>子项目。对<tt class="docutils literal"><span class="pre">test/test2</span></tt>项目也作类似修改。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cd test/test1
$ echo &quot;1:0.2-jiangxin&quot; &gt; version
$ git diff
diff --git a/version b/version
index 37c65f8..a58ac04 100644
--- a/version
+++ b/version
@@ -1 +1 @@
-1:0.2-dev
+1:0.2-jiangxin
$ repo status
# on branch jiangxin
project test/test1/                             branch jiangxin
 -m     version
$ git add -u
$ git commit -m &quot;0.2-dev -&gt; 0.2-jiangxin&quot;
</pre></div>
</div>
<p>执行<strong class="command">make</strong>命令，看看各个项目的改变。</p>
<div class="highlight-python"><div class="highlight"><pre>$ make
Version of test1:    1:0.2-jiangxin
Version of test2:    2:0.2-jiangxin
Version of manifest: current
</pre></div>
</div>
</div>
<div class="section" id="push">
<h4>4.6.9.3.5. PUSH到远程服务器<a class="headerlink" href="#push" title="永久链接至标题">¶</a></h4>
<p>直接执行<strong class="command">repo push</strong>就可以将各个项目的改动进行推送。</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo push
</pre></div>
</div>
<p>如果有多个项目同时进行了改动，为了避免出错，会弹出编辑器显示因为包含改动而需要推送的项目列表。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Uncomment the branches to upload:</span>
<span class="c">#</span>
<span class="c"># project test/test1/:</span>
<span class="c">#  branch jiangxin ( 1 commit, Mon Oct 25 18:04:51 2010 +0800):</span>
<span class="c">#         4f941239 0.2-dev -&gt; 0.2-jiangxin</span>
<span class="c">#</span>
<span class="c"># project test/test2/:</span>
<span class="c">#  branch jiangxin ( 1 commit, Mon Oct 25 18:06:51 2010 +0800):</span>
<span class="c">#         86683ece 0.2-dev -&gt; 0.2-jiangxin</span>
</pre></div>
</div>
<p>每一行前面的井号是注释，会被忽略。将希望推送的分支前的注释去掉，就可以将该项目的分支执行推送动作。下面的操作中，把其中的两个分支的注释都去掉了，这两个项目当前分支的改动会推送到上游服务器。</p>
<div class="highlight-python"><div class="highlight"><pre># Uncomment the branches to upload:


#
# project test/test1/:
branch jiangxin ( 1 commit, Mon Oct 25 18:04:51 2010 +0800):
#         4f941239 0.2-dev -&gt; 0.2-jiangxin
#
# project test/test2/:
branch jiangxin ( 1 commit, Mon Oct 25 18:06:51 2010 +0800):
#         86683ece 0.2-dev -&gt; 0.2-jiangxin
</pre></div>
</div>
<p>保存退出（如果使用vi编辑器，输入<tt class="docutils literal"><span class="pre">&lt;ESC&gt;:wq</span></tt>执行保存退出）后，马上开始对选择的各个项目执行<strong class="command">git push</strong>。</p>
<div class="highlight-python"><div class="highlight"><pre>Counting objects: 5, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 293 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To ssh://git@github.com/ossxp-com/test1.git
   27aee23..4f94123  jiangxin -&gt; master
Counting objects: 5, done.
Writing objects: 100% (3/3), 261 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To ssh://git@github.com/ossxp-com/test2.git
   7f0841d..86683ec  jiangxin -&gt; master

--------------------------------------------
[OK    ] test/test1/     jiangxin
[OK    ] test/test2/     jiangxin
</pre></div>
</div>
<p>从推送的命令输出可以看出来本地的工作分支<tt class="docutils literal"><span class="pre">jiangxin</span></tt>的改动被推送的远程服务器的<tt class="docutils literal"><span class="pre">master</span></tt>分支（本地工作分支跟踪的上游分支）。</p>
<p>再次执行<strong class="command">repo push</strong>，会显示没有项目需要推送。</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo push
no branches ready for upload
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h4>4.6.9.3.6. 在远程服务器创建新分支<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h4>
<p>如果想在服务器上创建一个新的分支，该如何操作呢？如下使用<tt class="docutils literal"><span class="pre">--new_branch</span></tt>参数调用<strong class="command">repo push</strong>命令。</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo start feature1 --all
$ repo push --new_branch
</pre></div>
</div>
<p>经过同样的编辑操作之后，自动调用<strong class="command">git push</strong>，在服务器上创建新分支<tt class="docutils literal"><span class="pre">feature1</span></tt>。</p>
<div class="highlight-python"><div class="highlight"><pre>Total 0 (delta 0), reused 0 (delta 0)
To ssh://git@github.com/ossxp-com/test1.git
 * [new branch]      feature1 -&gt; feature1
Total 0 (delta 0), reused 0 (delta 0)
To ssh://git@github.com/ossxp-com/test2.git
 * [new branch]      feature1 -&gt; feature1

--------------------------------------------
[OK    ] test/test1/     feature1
[OK    ] test/test2/     feature1
</pre></div>
</div>
<p>用<strong class="command">git ls-remote</strong>命令查看远程版本库的分支，会发现远程版本库中已经建立了新的分支。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git ls-remote git://github.com/ossxp-com/test1.git refs/heads/*
4f9412399bf8093e880068477203351829a6b1fb        refs/heads/feature1
4f9412399bf8093e880068477203351829a6b1fb        refs/heads/master
b2b246b99ca504f141299ecdbadb23faf6918973        refs/heads/test-0.1
</pre></div>
</div>
<p>注意到<tt class="docutils literal"><span class="pre">feature1</span></tt>和<tt class="docutils literal"><span class="pre">master</span></tt>分支引用指向相同的SHA1哈希值，这是因为<tt class="docutils literal"><span class="pre">feature1</span></tt>分支是直接从<tt class="docutils literal"><span class="pre">master</span></tt>分支创建的。</p>
</div>
<div class="section" id="id15">
<h4>4.6.9.3.7. 通过不同的清单库版本，切换到不同分支<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h4>
<p>换用不同的清单库，需要建立新的工作区，并且在执行<strong class="command">repo init</strong>时，通过<tt class="docutils literal"><span class="pre">-b</span></tt>参数指定清单库的分支。</p>
<div class="highlight-python"><div class="highlight"><pre>$ mkdir test-0.1
$ cd test-0.1
$ repo init -u git://github.com/ossxp-com/manifest.git -b test-0.1
$ repo sync
</pre></div>
</div>
<p>当子项目代码全部同步完成后，执行<strong class="command">make</strong>命令。可以看到各个子项目的版本以及清单库的版本不同于之前的输出。</p>
<div class="highlight-python"><div class="highlight"><pre>$ make
Version of test1:    1:0.1.4
Version of test2:    2:0.1.3-dev
Version of manifest: current-2-g12f9080
</pre></div>
</div>
<p>可以用<strong class="command">repo manifest</strong>命令来查看清单库。</p>
<div class="highlight-python"><div class="highlight"><pre>$ repo manifest -o -
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;manifest&gt;
  &lt;remote fetch=&quot;git://github.com/ossxp-com/&quot; name=&quot;github&quot;/&gt;

  &lt;default remote=&quot;github&quot; revision=&quot;refs/heads/test-0.1&quot;/&gt;

  &lt;project name=&quot;test1&quot; path=&quot;test/test1&quot;&gt;
    &lt;copyfile dest=&quot;Makefile&quot; src=&quot;root.mk&quot;/&gt;
  &lt;/project&gt;
  &lt;project name=&quot;test2&quot; path=&quot;test/test2&quot;/&gt;
&lt;/manifest&gt;
</pre></div>
</div>
<p>仔细看上面的清单文件，可以注意到缺省的版本指向到<tt class="docutils literal"><span class="pre">refs/heads/test-0.1</span></tt>引用所指向的分支<tt class="docutils literal"><span class="pre">test-0.1</span></tt>。</p>
<p>如果在子项目中修改、提交，然后使用<strong class="command">repo push</strong>会将改动推送的远程版本库的<tt class="docutils literal"><span class="pre">test-0.1</span></tt>分支中。</p>
</div>
<div class="section" id="id16">
<h4>4.6.9.3.8. 切换到清单库里程碑版本<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h4>
<p>执行如下命令，可以查看清单库包含的里程碑版本：</p>
<div class="highlight-python"><div class="highlight"><pre>$ git ls-remote --tags git://github.com/ossxp-com/manifest.git
43e5783a58b46e97270785aa967f09046734c6ab        refs/tags/current
3a6a6da36840e716a14d52252e7b40e6ba6cbdea        refs/tags/current^{}
4735d32613eb50a6c3472cc8087ebf79cc46e0c0        refs/tags/v0.1
fb1a1b7302a893092ce8b356e83170eee5863f43        refs/tags/v0.1^{}
b23884d9964660c8dd34b343151aaf968a744400        refs/tags/v0.1.1
9c4c287069e29d21502472acac34f28896d7b5cc        refs/tags/v0.1.1^{}
127d9789cd4312ed279a7fa683c43eec73d2b28b        refs/tags/v0.1.2
47aaa83866f6d910a118a9a19c2ac3a2a5819b3e        refs/tags/v0.1.2^{}
af3abb7ed0a9ef7063e9d814510c527287c92ef6        refs/tags/v0.1.3
99c69bcfd7e2e7737cc62a7d95f39c6b9ffaf31a        refs/tags/v0.1.3^{}
</pre></div>
</div>
<p>可以从任意里程碑版本的清单库初始化整个项目。</p>
<div class="highlight-python"><div class="highlight"><pre>$ mkdir v0.1.2
$ cd v0.1.2
$ repo init -u git://github.com/ossxp-com/manifest.git -b refs/tags/v0.1.2
$ repo sync
</pre></div>
</div>
<p>当子项目代码全部同步完成后，执行<strong class="command">make</strong>命令。可以看到各个子项目的版本以及清单库的版本不同于之前的输出。</p>
<div class="highlight-python"><div class="highlight"><pre>$ make
Version of test1:    1:0.1.2
Version of test2:    2:0.1.2
Version of manifest: v0.1.2
</pre></div>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="070-git-svn.html" title="4.7. Git和SVN协同模型"
             >下一页</a> |</li>
        <li class="right" >
          <a href="050-subtree-model.html" title="4.5. 子树合并"
             >上一页</a> |</li>
        <li><a href="../index.html">GotGit</a> &raquo;</li>
          <li><a href="index.html" >4. Git协同模型</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>
      <br />
      全部内容以 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons 署名-非商业性使用-相同方式共享 3.0 协议发布</a>.
      <br />
        &copy; Copyright 2011, 蒋鑫。
      使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3 创建。

    </div>
  </body>
</html>