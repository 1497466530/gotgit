爱上 Git 的理由
****************

本章通过一些典型应用，展示 Git 作为版本控制系统的独特用法。对于不熟悉版本控制系统的读者可以通过这些示例对版本控制拥有感性的认识。如果是有经验的读者，示例中的和SVN的对照可以让读者体会到 Git 的神奇和强大。期待在这里列举的不全面的 Git 闪亮特性能够让读者爱上 Git。

每日的工作备份
===========================

当我开始撰写本书时才知道写书是一个辛苦活，如何让辛苦的工作不会因为笔记本硬盘的意外损坏而丢失？如何防范灾害而不让一个篮子里的鸡蛋都毁于一旦？下面就介绍一下我在写本书时，如何使用 Git 进行文稿的备份。

.. figure:: images/meet-git/work-backup.png
   :scale: 65

   图：利用 Git 做数据的备份

我的笔记本在公司的局域网里的IP是 192.168.0.100，公司的Git服务器IP地址是 192.168.0.2。公司使用动态IP上网因而没有固定的外网IP，但是公司在数据中心有托管服务器，拥有固定IP地址，其中一台服务器用作Git服务器镜像。

我的写书习惯大概是这样：一般在写完一个小节，或者是画完一张图，我会执行下面的命令执行一次提交。每一天平均提交3-5次。

::

  $ git add -u    # 如果创建了新文件，最好执行 git add -i 命令。
  $ git commit

在下班后，我会执行一次推送操作，将我在本地Git版本库中的提交同步到公司的Git服务器上。相当于图中的步骤1。

::

  $ git push

因为公司的Git服务器和异地数据中心的Git服务器建立了镜像，所以每当我向公司内网服务器推送的时候，就会自动触发从内网服务器到外网Git服务器的镜像操作。相当于图中的步骤2，步骤2是自动执行的无需人工干预。图中标记为 mirror 的版本库就是Git镜像版本库，该版本库只向普通用户提供只读访问的服务，而不能对其进行写操作（推送）。

从上图中可以看出，我的每日工作保存有三个拷贝，一个在笔记本中，一个在公内网的服务器上，还有一个在外网的镜像版本库中。鸡蛋装在了三个篮子里。

异地协同工作
===========================

为了能够加快写书的进度，熬夜是必须的，这就出现了公司和家两地工作同步的问题。下面的图用于说明我是如何解决两地工作同步的问题的。


.. figure:: images/meet-git/workflow.png
   :scale: 65

   图：利用 Git 实现异地工作协同

我在家里的电脑IP地址是 10.0.0.100。如果打算在家里工作的话，首先要做的就是上图中步骤3的操作：从 mirror 版本库同步数据到本地。只需要一条命令就好了：

::

  $ git pull mirror master

然后在家里的电脑上编辑书稿，提交。当准备完成一天的工作时，就执行下面的命令，相当于上图中步骤4的操作：将在家中的提交推送到标记为 home 的版本库中。

::

  $ git push home

为什么还要再引入另外的一个版本库呢？使用 mirror 版本库不好么？不要忘了 mirror 版本库是一个镜像库，不能提供写操作。

当一早到公司后，开始动笔写书之前，先要执行上图中步骤5的操作，从 home 版本库将家里做的提交同步到公司的电脑中。

::

  $ git pull home master

公司的小崔是我这本书的忠实读者，我每有新章节出来，他都会执行图中步骤6的工作，从公司内网服务器获取我最新的文稿。

::

  $ git pull

一旦发现文字错误，小崔会直接在文稿中修改，然后推送到公司的服务器上（图中步骤7）。当然他的这个推送也会自动同步到外网的 mirror 版本库。

::

  $ git push


而我只要执行 `git pull` 操作就可以获得小崔对我文稿的修订（图中步骤8）。采用这种工作方式，文稿竟然拥有6个拷贝，比狡兔还要多三窟。


现场版本库创建
===========================

**需求** ：

  有的时候，为了调试方便，可能要直接在软件部署的目录内进行现场修改。为了对修改进行追踪，就需要临时创建版本库，以便在修改完毕后能将改动以补丁文件的方式回传到工作机，并注入正式的版本库中。

**Subversion** ：

  需要在另外的目录下建立版本库，再检出空版本库到当前目录下，添加文件，提交。

  * 建库

    ::

      $ svnadmin create /path/to/repos/project1

  * 检出

    ::
    
      $ svn checkout file:///path/to/repos/project1 .

  * 添加文件并提交

    ::

      $ svn add *
      $ svn ci -m "initialized"

**Git** ：

  Git相比Subversion省去了检出的步骤，而且不会在工作目录引入多余的 .svn 目录等，关于引入 .svn 目录的危害后面会介绍。

  * 现场版本库创建

    ::

      $ git init

  * 添加文件并提交

    ::

      $ git add .
      $ git commit -m "initialized"

.. tip:: 只要通过简单的配置 `git commit` 就可简写为 `git ci` ，会在后面的“Git配置”章节中介绍。

避免引入辅助目录
=================

很多版本控制系统，都要在工作区中引入辅助目录或文件，如Subversion要在工作区的每一个子目录下都创建 `.svn` 目录，CVS要在工作区的每一个子目录下都创建 `CVS` 目录。

这些辅助目录如果出现在服务器尤其是Web服务器上是危险的，会因为这些辅助目录下的 `Entries` 文件暴露出目录下的文件列表，让管理员精心配置的禁止目录浏览的努力白费。

还有Subversion的.svn 辅助目录下还存在文件的原始拷贝，在文件搜索时会出现两份。如果在Subversion的工作区用 `grep` 命令执行过内容搜索，就会明白指的是什么。

Git没有这个问题，不会在子目录下引入讨厌的辅助目录或文件（ `.gitignore` 文件不算）。当然Git还是要在工作区的顶级目录下创建名为 `.git` 的目录（版本库目录），不过如果你认为唯一的一个 `.git` 目录也过于碍眼，你将其放到工作区之外的任意目录。一旦这么做了，你在执行Git命令时，要通过命令行(--git-dir=)或者环境变量 GIT_DIR 为工作区指定版本库目录，甚至还有指定工作区目录。

而且 Git 提供 `git grep` 命令，也不会因为一个 `.git` 目录对搜索造成影响。

重写提交说明
==============

很多人，可能如我一样，在敲下回车之后，在发现提交说明中出现了错别字，或者忘记写关联的 BugID。这就需要重写提交说明。

Subversion的提交说明缺省是禁止更改的，因为不可恢复。我建议Subversion管理员只有在配置了版本库更改外发通知邮件之后，才开放提交说明更改的功能。在我开发并开源在 SourceForge 上的 pySvnManager 项目，提供了Subversion版本库图形化的钩子管理，会简化管理员的配置工作。

即使在管理员开放了提交说明更改，也是挺复杂的，因为命令行够复杂：

::

  $ svn ps --revprop -r <REV> svn:log "new log message..." 

Git 修改提交说明很简单（修改最新的提交），而且提交说明的修改也是被追踪的。

Git 修改最新提交的提交说明，最简单：

::

  $ git commit --amend

会进入提交说明编辑界面，修改原来的提交说明，直到满意为止。

Git 修改某个历史提交的提交说明，没有这么简单，但也还可以接受。例如修改 <commit-id> 所标识的提交：

::

  $ git rebase -i <commit-id>^


想吃后悔药
============

例如不小心提交的数据中包含一个不应该检入的虚拟机文件——大约有1个GB！这时候，是多么希望这个世界上有后悔药卖啊。

Subversion 遇到这个问题该怎么办呢？删除错误加入的大文件，再提交，虽然表面上去掉了这个文件，但是历史中依然存在。管理员可能是受影响最大的人，因为他要为服务器的空间占用以及版本库备份操心。所以你还应该向管理员坦白，让他帮你在服务器端彻底删除。我要告诉你的是，对于管理员，这并不是一个简单的活。

Subversion管理员要是没有历史备份的话，只能从头用 `svnadmin dump` 导出整个版本库，再用 `svndumpfilter` 命令过滤掉不应检入的大文件，然后用 `svnadmin load` 重建版本库。我省略了一些窍门，因为窍门要说清楚的话，这本书就不是讲 Git，而是讲 Subversion 了。 

如果你用Git，一切非常简单，而且你也不必去祈求管理员，因为没有管理员，或者说你就是管理员。

如果是最新的提交引入了不该提交的大文件: winxp.img。只需执行下面的命令：

::

  $ git rm --cached winxp.img
  $ git commit --amend

如果是历史版本，例如在 <commit-id> 所标识的提交中引入的文件：

::

  $ git rebase -i <commit-id>^


更好用的提交列表
======================


    需求：同时针对多个 feature/bugfix 修改代码，需要只对部分更改提交
    SVN 有 change list 功能，但是不会有人用，因为麻烦
    Git 缺省只对加入 stage 的文件进行提交。效果是： 可以随意更改提交清单，甚至对一个文件的部分更改进行提交！
    只提交修改的文件，新增文件不管： git add -u
    所有修改包括添加和删除： git add -A

更好用的差异比较
=================

    需求： 更改一个文件，得到和版本库的差异容易，可以得到和我刚才更改（未提交）的差异么？
    SVN？ never
    Git？ git diff; git diff --cached;  git diff HEAD


    --word-diff


工作进度保存
==============

当前修改尚不能提交，而需要暂时切换到其它分支，而又不破坏现有文件的更改？

    需求： 当前分支的修改只进行了一半，但是有需要切换到其它分支，查看或者修改。
    SVN 该怎么办呢？ 1. svn diff > somefile; svn revert -R; svn switch ; ...
    SVN 数据恢复的时候？ svn switch ...; patch -p1 < somefile; 而且要注意二进制文件会丢失！
    Git 呢？ git stash; git co BranchName; ...; git co master; git stash pop

移动办公的提交
=======================

    需求： 出差在客户现场，发现软件 bug，需要修改代码，重新生成版本？
    SVN： 所有的更改均保留在本地，不能提交，没有历史修改记录，也没有备份！
    Git？ 随时提交，多次提交；完整的历史；回到公司，一次性同步到公司的版本库

上游软件的定制开发
====================

    需求，基于上游软件的二次开发，如何保持自有的功能分支能够迁移到新的上游版本？
    SVN？ vendor branch 和 一个 trunk
    SVN 的问题是： 所有定制混杂在一个分支，造成向新版本迁移困难重重
    Git？ topgit 和 quilt 补丁管理系统

快
======

    您有项目托管在 sourceforge.net 上么？ 或者你要通过互联网访问公司的代码服务器？
    SVN 的提交速度慢，而且提交进度不可见，查看历史更慢
    Git？ 太快了，而且可以看到提交的进度
    Git 查看历史？ 本地！

无处不在的分页器
==================


