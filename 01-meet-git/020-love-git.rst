爱上 Git 的理由
===============

如果你正在使用、熟悉一款版本控制工具，那么本章会向你展示一些你让你激动不已的Git特性，让你立刻爱上Git。

在下面的特性展示中，我拿 Subversion 这一被广泛使用的传统的集中式版本控制系统作为对照，相信其他版本控制系统的用户也能够体会到Git的神奇。

现场版本库创建
---------------------------

**需求** ：

  有的时候，为了调试方便，可能要直接在软件部署的目录内进行现场修改。为了对修改进行追踪，就需要临时创建版本库，以便在修改完毕后能将改动以补丁文件的方式回传到工作机，并注入正式的版本库中。

**Subversion** ：

  需要在另外的目录下建立版本库，再检出空版本库到当前目录下，添加文件，提交。

  * 建库

    ::

      $ svnadmin create /path/to/repos

  * 检出

    ::
    
      $ svn checkout file:///path/to/repos .

  * 添加文件并提交

    ::

      $ svn add *
      $ svn ci -m "initialized"

**Git** ：

  Git相比Subversion省去了检出的步骤，而且不会在工作目录引入多余的 .svn 目录等，关于引入 .svn 目录的危害后面会介绍。

  * 现场版本库创建

    ::

      $ git init

  * 添加文件并提交

    ::

      $ git add .
      $ git commit -m "initialized"

.. tip:: 只要通过简单的配置 `git commit` 就可简写为 `git ci` ，我们会在后面的“Git配置”章节中介绍。

避免引入辅助目录
----------------
很多版本控制系统，都要在工作区中引入辅助目录或文件，如Subversion要在工作区的每一个子目录下都创建 `.svn` 目录，CVS要在工作区的每一个子目录下都创建 `CVS` 目录。

这些辅助目录如果出现在服务器尤其是Web服务器上是危险的，会因为这些辅助目录下的 `Entries` 文件暴露出目录下的文件列表，让管理员精心配置的禁止目录浏览的努力白费。

还有Subversion的.svn 辅助目录下还存在文件的原始拷贝，在文件搜索时会出现两份。如果你在Subversion的工作区用 `grep` 命令执行过内容搜索，你就会明白我指的是什么。

Git没有这个问题，不会在子目录下引入讨厌的辅助目录或文件（ `.gitignore` 文件不算）。当然Git还是要在工作区的顶级目录下创建名为 `.git` 的目录（版本库目录），不过如果你认为唯一的一个 `.git` 目录也过于碍眼，你将其放到工作区之外的任意目录。一旦这么做了，你在执行Git命令时，要通过命令行(--git-dir=)或者环境变量 GIT_DIR 为工作区指定版本库目录，甚至还有指定工作区目录。

而且 Git 提供 `git grep` 命令，也不会因为一个 `.git` 目录对搜索造成影响。

重写提交说明
------------
很多人，可能如我一样，在敲下回车之后，在发现提交说明中出现了错别字，或者忘记写关联的 BugID。这就需要重写提交说明。

Subversion的提交说明缺省是禁止更改的，因为不可恢复。我建议Subversion管理员只有在配置了版本库更改外发通知邮件之后，才开放提交说明更改的功能。在我开发并开源在 SourceForge 上的 pySvnManager 项目，提供了Subversion版本库图形化的钩子管理，会简化管理员的配置工作。

即使在管理员开放了提交说明更改，也是挺复杂的，因为命令行够复杂：

::

  $ svn ps --revprop -r <REV> svn:log "new log message..." 

Git 修改提交说明很简单（修改最新的提交），而且提交说明的修改也是被追踪的。

Git 修改最新提交的提交说明，最简单：

::

  $ git commit --amend

会进入提交说明编辑界面，修改原来的提交说明，直到满意为止。

Git 修改某个历史提交的提交说明，没有这么简单，但也还可以接受。例如修改 <commit-id> 所标识的提交：

::

  $ git rebase -i <commit-id>^


想吃后悔药
----------

例如你不小心提交的数据中包含一个不应该检入的虚拟机文件——大约有1个GB！这时候，是多么希望这个世界上有后悔药卖啊。

Subversion 遇到这个问题该怎么办呢？删除错误加入的大文件，再提交，虽然表面上去掉了这个文件，但是历史中依然存在。管理员可能是受影响最大的人，因为他要为服务器的空间占用以及版本库备份操心。所以你还应该向管理员坦白，让他帮你在服务器端彻底删除。我要告诉你的是，对于管理员，这并不是一个简单的活。

Subversion管理员要是没有历史备份的话，只能从头用 `svnadmin dump` 导出整个版本库，再用 `svndumpfilter` 命令过滤掉不应检入的大文件，然后用 `svnadmin load` 重建版本库。我省略了一些窍门，因为窍门要说清楚的话，这本书就不是讲 Git，而是讲 Subversion 了。 

如果你用Git，一切非常简单，而且你也不必去祈求管理员，因为没有管理员，或者说你就是管理员。

如果是最新的提交引入了不该提交的大文件: winxp.img。只需执行下面的命令：

::

  $ git rm --cached winxp.img
  $ git commit --amend

如果是历史版本，例如在 <commit-id> 所标识的提交中引入的文件：

::

  $ git rebase -i <commit-id>^


更好用的 change list
---------------------

    需求：同时针对多个 feature/bugfix 修改代码，需要只对部分更改提交
    SVN 有 change list 功能，但是不会有人用，因为麻烦
    Git 缺省只对加入 stage 的文件进行提交。效果是： 可以随意更改提交清单，甚至对一个文件的部分更改进行提交！
    只提交修改的文件，新增文件不管： git add -u
    所有修改包括添加和删除： git add -A

更好用的 differ
----------------

    需求： 更改一个文件，得到和版本库的差异容易，可以得到和我刚才更改（未提交）的差异么？
    SVN？ never
    Git？ git diff; git diff --cached;  git diff HEAD

当前修改尚不能提交，而需要暂时切换到其它分支，而又不破坏现有文件的更改？
-------------------------------------------------------------------------

    需求： 当前分支的修改只进行了一半，但是有需要切换到其它分支，查看或者修改。
    SVN 该怎么办呢？ 1. svn diff > somefile; svn revert -R; svn switch ; ...
    SVN 数据恢复的时候？ svn switch ...; patch -p1 < somefile; 而且要注意二进制文件会丢失！
    Git 呢？ git stash; git co BranchName; ...; git co master; git stash pop

出差办公，一样可以提交
----------------------

    需求： 出差在客户现场，发现软件 bug，需要修改代码，重新生成版本？
    SVN： 所有的更改均保留在本地，不能提交，没有历史修改记录，也没有备份！
    Git？ 随时提交，多次提交；完整的历史；回到公司，一次性同步到公司的版本库

基于上游软件的定制
-------------------

    需求，基于上游软件的二次开发，如何保持自有的功能分支能够迁移到新的上游版本？
    SVN？ vendor branch 和 一个 trunk
    SVN 的问题是： 所有定制混杂在一个分支，造成向新版本迁移困难重重
    Git？ topgit 和 quilt 补丁管理系统

快
---

    您有项目托管在 sourceforge.net 上么？ 或者你要通过互联网访问公司的代码服务器？
    SVN 的提交速度慢，而且提交进度不可见，查看历史更慢
    Git？ 太快了，而且可以看到提交的进度
    Git 查看历史？ 本地！

Pager everywhere
-----------------


对 Git 的误解和担忧
====================

* 版本库和工作区混在一起，不是很容易误删除版本库？

  你可以将版本库克隆并经常保持同步，起到了数据备份的作用

  版本库被越多的人克隆，越安全，也越不需要备份，因为鸡蛋装在好多篮子里了。

* 提交可以随时撤销，不安全？

  撤销前如果他人和版本库同步，实际上撤销只是本地库的变更，不会造成对他人的影响

  而且撤销记录在 log 中，可以通过特定手段恢复

* 版本库检出到本地不叫检出，叫克隆？

  svn checkout == git clone
  
  git 的 checkout 实际上是将 .git 目录（版本库），检出到工作区。实际上相当于

* 没有部分检出

  不能像 svn 那样检出版本库的一部分

  只能克隆全部版本库，或者0

  submodule？ 或者 git-svn？

* 命令行和 SVN 不兼容？

  git config 进行兼容性设置

  Git 的配置，命令行不再古怪

* Git 的版本号不是从1开始顺序增长的？


