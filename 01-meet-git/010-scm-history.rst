版本控制的前世和今生
====================

任何新鲜事务，都是从无到有，从简陋到完善。现代社会，世界大同，我们已经几乎看不到蛮荒的影子，可能只能通过想像神游那个刀耕火种、男耕女织的简单岁月。

版本控制的历史也有几十年，从无到有，从以 CVS/SVN为代表的集中式版本控制到以 Hg、Git 为代表的分布式版本控制。但版本控制却非常有趣和特别，因为他的历史一直在社会的各个角落（研发团队）重演着，惊人相似。

黑暗的史前时代
---------------

人们谈及远古，总爱以黑暗形容。黑暗实际上指的秩序和工具的匮乏而不是自然。单以自然环境而论，因工业化和城市化进程对环境的破坏，现今才是最黑暗的年代。 

对软件开发来说也是如此，遥远的 C 语言一统天下的日子，要比今天选 Java，选 .Net，还是选择脚本语言的多选题要简单的多。但是从工具和秩序上讲，过去的年代是黑暗的。

看看我经历的版本控制的“史前时代”。在大学里，分散在各个软盘中的代码拷贝，最终会被搞糊涂，不知道哪个软盘中的代码是最优的，因为最新并非最优，失败的重构会毁掉原来尚能运作的代码。工作后的第一年，代码的管理并未改观，还是以简单的目录拷贝作为备份，三四个程序员的代码利用文件服务器共享进行协同，公共类库和头文件往往被互相覆盖，痛苦不堪。很明显，你可以看出来，那时我们并没有使用版本控制工具。我真的不想告诉你们这一切是发生在 2000 年前后——那时 CVS 已经诞生 14 年，而我那时对 CVS 还一无所知。

实际上，即便是在 CVS 出现之前的“史前时代”，已经出现了非常好用的源码比较和补丁工具： diff 和 patch，他们今天仍然非常有用。实际上在 1991-2002 年之间，Linus Tolvars一直顽固的用 diff 和 patch 管理着 Linux 的代码，即使不断有人提醒他 CVS 的存在。

那么我们来看看 diff 和 patch，因为熟悉它们，对我们理解版本控制系统（差异存储），使用版本控制系统（代码比较和冲突合并）都有莫大好住。

**命令 diff 用于比较两个文本文件或目录的差异**

我们先来构造两个文件：

* 文件 `hello`

  ::

    应该杜绝文章中的错别宇。
    
    但是无论使用
    * 全拼，双拼
    * 还是五笔
    
    是人就有可能犯错，软件更是如此。
    
    犯了错，就要扣工资！
    
    改正的成本可能会很高。


* 文件 `world`

  ::

    应该杜绝文章中的错别字。
    
    但是无论使用
    * 全拼，双拼
    * 还是五笔
    
    是人就有可能犯错，软件更是如此。
    
    改正的成本可能会很高。
    
    但是“只要眼球足够多，所有Bug都好捉”，
    这就是开源的哲学之一。

我们对这两个文件执行 diff 命令，并通过输出重定向，将差异保存在 `diff.txt` 文件中。

::

  $ diff -u hello world > diff.txt

.. hint:: diff 命令后的 -u 参数很重要，决定了差异输出是否带有上下文。

打开 diff.txt，我们会看到：

::

  --- hello       2010-09-21 17:45:33.551610940 +0800
  +++ world       2010-09-21 17:44:46.343610465 +0800
  @@ -1,4 +1,4 @@
  -应该杜绝文章中的错别宇。
  +应该杜绝文章中的错别字。
   
   但是无论使用
   * 全拼，双拼
  @@ -6,6 +6,7 @@
   
   是人就有可能犯错，软件更是如此。
   
  -犯了错，就要扣工资！
  -
   改正的成本可能会很高。
  +
  +但是“只要眼球足够多，所有Bug都好捉”，
  +这就是开源的哲学之一。

从中，我们可以看到：

* 文件头的前两行，分别是做比较的原始文件和目标文件及时间戳

  比较的原始文件将在下面用减号(-)标识，比较的目标文件将在下面用加号(+)标识

* 然后是差异小节。每个差异小节以一行差异定位语句开始。差异定位语句前后分别用两个@ 进行标识。

  定位语句中 `-1,4` 的含义是：下面的差异内容，相当于从原始文件的第 1 行开始，共 4 行

  定位语句中 `+1,4` 的含义是：下面的差异内容，相当于从目标文件的第 1 行开始，共 4 行

* 命令 `diff` 是基于行比较，所以即使改正了一个字，也显示为一整行的修改

* 第二个差异小节的差异内容共有：两行以减号标识的行，三行以加号标识的行，四行以一个空格开始的行

  空白开始的行相当于前后没有改变的行，以减号开始的行，相当于原始文件包含但目标文件删除的行，总共 6 行。

  以加号开始的行，相当于原始文件中没有但目标文件中包含的行，加上没有改变的行，总共 7 行。

  因此这个差异小节的定位语句 `@@ -6,6 +6,7 @@` 看起来就不再像看天书了吧。

**命令 patch 相当于 diff 的反向操作**

有了 `hello` 和 `diff.txt` 文件，我们可以放心的将 `world` 文件删除。用下面的命令可以还原 `world` 文件：

::

  $ cp hello world
  $ patch world < diff.txt

或者我们也可以保留 `world` 和 `diff.txt` 文件，将原始的 `hello` 文件删除。用下面的命令可以还原 `hello` 文件：

::

  $ cp world hello
  $ patch -R hello < diff.txt

命令 `diff` 和 `patch` 还可以对目录进行比较操作，这也就是 Linus Tolvars 在 1991-2002 年用以维护 Linux 不同版本间差异的办法。你也可以用此命令，在没有版本控制系统的情况下，将改动前后的差异记录并保存，并可以将差异文件注入版本控制系统（如果有的话）。

但要注意 `diff` 和 `patch` 的一个局限：不能对二进制文件进行处理。对二进制文件的修改和添加会在 diff 差异文件中缺失，进而丢失对二进制文件的改动或添加。

大概是 Linus Tolvars 深受其害，在 Git 中，特意设计了新的 diff 格式，补充了对二进制的支持等功能。

* 二进制文件以 base64 编码方式出现在 diff 差异文件中
* 支持文件改名操作。即文件改名不再笨拙的显示为一个文件的全部删除和一个新文件的逐行添加，而是简单的 rename 语句做标识

CVS 开启了版本控制大爆发
-------------------------

CVS 诞生于 1986 年，是教授和学生的一个开发项目中，根据需要用脚本语言从 RCS 工具封装得来。1988 年用 C 语言重新实现。

by Dick Grune.  --- Dick Grune's website <http://www.cs.vu.nl/~dick/CVS.html#History>

这么伟大的工具，诞生在三个人的项目中，而且是产生在学校。联想到 互联网的诞生就是源自一群研究生，不得不感叹中国教育和学术环境的改善有多么大的空间。 如果能够解放高校的创造力，中国将会是一番如何气象。

CVS 源自于 RCS，即使在重新实现后，后端的数据存储结构依然采用 RCS 的文件格式。RCS 实际上就是单独的一个文件的版本控制系统。一个 RCS 文件以 ,v 作为扩展名，保存对应文件的历次更改历史，历次更改差异保存。我在 2008 年写的一个 SVN 管理后台 pySvnManager，实际上也采用了 RCS 作为 SVN 授权文件的变更记录“数据库”。

在 2001 年，我正为 CVS 激动不已的时候，公司领导要求采用和公司在美国研发机构采用同样的版本控制解决方案。于是，我的项目组率先进行了 CVS 到该商业版本控制工具的迁移。在最终的调研报告中，我实事求是的写了一篇比较文章《CVS Beat Starteam》。现在来看，其中的部分论断也并未过时，而且我认为 CVS 的一些特性，仍然让人怀念。

* 首先 CVS 确定了版本控制系统的标准。

  CVS 的出现，让软件工程师认识到了原来开发者可以这样进行工作上的协同。于是各式各样的版本控制工具雨后春笋般的诞生了。

  其他版本控制的设计或多或少受到 CVS 影响，至少在命令行上会尽量保持一致。

* CVS 版本库裁剪易如反掌。

  因为 CVS 的后端采用目录以及 RCS 文件进行管理，而 RCS 文件的路径和检出文件的路径是一一对应的，因此对 CVS 版本库的裁剪，就像在客户端移动/删除目录一样简单。

  反观 SVN，版本库的整理需要更复杂的操作： svnadmin dump, svndumpfilter, svnadmin load。

  对于很多商业版本控制系统，整理版本库根本就不可能实现。

  Git 版本库的整理也是可以的，但是操作依然非常复杂，可能用到 reset， rebase, read-tree 等

* CVS 的 Tag 和 Git 中的 Tag 一样 是不允许更改的。这一点比 SVN 要强。

  SVN 的 Tag 实际上和分支无本质的区别，靠的是约定俗成，而不是在机制上进行限制。

SVN 号称自己是 A better CVS
----------------------------

SVN 诞生之初是解决 

真正关注 SVN 是在 2005 年底，那时 SVN 正经历着后端存储上的变革，即从BDB 简单的关系型数据库到 FSFS 文件系统上的转变。FSFS 相对于 BDB 的免维护性，以及实现的可视性，让我马上就被 SVN 吸引了。

SVN 对 CVS 用户不可抗拒的力量

* 原子提交
* 目录改名
* 分支创建在眨眼之间
* 授权管理使用授权文件，脱离 CVS 依靠文件系统授权模型

Linux 导致了开源版本控制系统的诞生
----------------------------------

(1991–2002), changes to the software were passed around as patches and archived files 

这期间，有非官方的 CVS 服务器，但是 Linus 一直拒绝使用

为什么 Linus 痛恨 CVS 包括 SVN？

除非把 SVN 服务器立在 Linus 书房里

In 2002, the Linux kernel project began using a proprietary DVCS system called BitKeeper.

In 2005, the relationship between the community that developed the Linux kernel and the commercial company that developed BitKeeper broke down, and the tool’s free-of-charge status was revoked.

开源版本控制的三巨头
--------------------

