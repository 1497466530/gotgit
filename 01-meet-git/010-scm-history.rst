版本控制的前世和今生
********************

除了茫然未知的宇宙，几乎任何事物都是从无到有，从简陋到完善。随着时间车轮的滚滚向前，历史被抛在身后逐渐远去，如同我们的现代社会，世界大同，到处都是忙碌和喧嚣，再也看不到已经远去的刀耕火种、男耕女织的慢生活岁月。

版本控制系统是一个另类。虽然其历史并不短暂，也有几十年，但是他的演进进程却一直在社会的各个角落重复着，而且惊人的相似。有的人从未使用甚至从未听说过版本控制系统，他和他的团队就像停留在黑暗的史前时代，任由数据自生自灭。有的人使用着有几十年历史的 CVS 或其改良版Subversion，让时间空耗在网络连接的等待中。再有就是以 Git 为代表的分布式版本控制系统，已经风靡整个开源社区，正等待你的靠近。

黑暗的史前时代
===============

人们谈及远古，总爱以黑暗形容。黑暗实际上指的是秩序和工具的匮乏，而不是自然，如以自然环境而论，工业化和城市化对环境的破坏，现今才是最黑暗的年代。对软件开发来说也是如此，虽然遥远的 C 语言一统天下的日子，要比今天选 Java，选 .Net，还是选择脚本语言的多选题要简单得多，但是从工具和秩序上讲，过去的年代是黑暗的。

回顾一下我经历的版本控制的“史前时代”吧。在大学里，代码分散地拷贝在各个软盘中，最终我会被搞糊涂，不知道哪个软盘中的代码是最优的，因为最新并非最优，失败的重构会毁掉原来尚能运作的代码。在我工作的第一年，代码的管理并未改观，还是以简单的目录拷贝进行数据的备份，三四个程序员利用文件服务器的共享目录进行协同，公共类库和头文件在操作过程中相互覆盖，痛苦不堪。很明显，那时我尚不知道版本控制系统为何物。我的版本控制史前时代一直延续到2000年，那时 CVS 已经诞生了 14 年，而我在那时对 CVS 还一无所知。

实际上，即便是在 CVS 出现之前的“史前时代”，也已经有了非常好用的源码比较和打补丁的工具： `diff` 和 `patch` ，他们今天生命力依然顽强。大名鼎鼎的 Linus Torvalds 先生（Linux之父）也对这两个工具偏爱有加，在 1991-2002 年之间，Linus一直顽固地使用 `diff` 和 `patch` 管理着 Linux 的代码，即使不断有人提醒他 CVS 的存在 [#]_ 。

那么来看看 `diff` 和 `patch` ，熟悉它们将对理解版本控制系统（差异存储），使用版本控制系统（代码比较和冲突合并）都有莫大的好处。

**命令 diff 用于比较两个文本文件或目录的差异**

先来构造两个文件：

+-----------------------------------------+-------------------------------------------+
| 文件 `hello`                            | 文件 `world`                              |
+=========================================+===========================================+
|   ::                                    |   ::                                      |
|                                         |                                           |
|     应该杜绝文章中的错别子。 [#]_       |     应该杜绝文章中的错别字。              |
|                                         |                                           |
|     但是无论使用                        |     但是无论使用                          |
|     * 全拼，双拼                        |     * 全拼，双拼                          |
|     * 还是五笔                          |     * 还是五笔                            |
|                                         |                                           |
|     是人就有可能犯错，软件更是如此。    |     是人就有可能犯错，软件更是如此。      |
|                                         |                                           |
|     犯了错，就要扣工资！                |     改正的成本可能会很高。                |
|                                         |                                           |
|     改正的成本可能会很高。              |     但是“只要眼球足够多，所有Bug都好捉”， |
|                                         |     这就是开源的哲学之一。                |
+-----------------------------------------+-------------------------------------------+

对这两个文件执行 diff 命令，并通过输出重定向，将差异保存在 `diff.txt` 文件中。

::

  $ diff -u hello world > diff.txt

上面执行 `diff` 命令的 `-u` 参数很重要，使得差异输出中带有上下文。打开文件 `diff.txt` ，会看到其中的差异比较结果。为了说明方便，为每一行增添了行号。

::

   1 --- hello       2010-09-21 17:45:33.551610940 +0800
   2 +++ world       2010-09-21 17:44:46.343610465 +0800
   3 @@ -1,4 +1,4 @@
   4 -应该杜绝文章中的错别子。
   5 +应该杜绝文章中的错别字。
   6  
   7  但是无论使用
   8  * 全拼，双拼
   9 @@ -6,6 +6,7 @@
  10  
  11  是人就有可能犯错，软件更是如此。
  12  
  13 -犯了错，就要扣工资！
  14 -
  15  改正的成本可能会很高。
  16 +
  17 +但是“只要眼球足够多，所有Bug都好捉”，
  18 +这就是开源的哲学之一。

上面的差异文件，可以这么理解：

* 第1、2行，分别记录了比较的原始文件和目标文件的文件名及时间戳。以三个减号（---）开始的行标识的是原始文件，以三个加号（+++）开始的行标识的是目标文件。
* 在比较内容中，以减号（-）开始的行是只出现在原始文件中的行，例如：第4、13、14行。
* 在比较内容中，以加号（+）开始的行是只出现在目标文件中的行，例如：第5、16-18行。
* 在比较内容中，以空格开始的行，是在原始文件和目标文件中都出现的行，例如：第6-8、10-12、15行。这些行用作差异比较的上下文。
* 第3-8行是第一个差异小节。每个差异小节以一行差异定位语句开始。第3行就是一条差异定位语句，其前后分别用两个@ 进行标识。
* 第3行定位语句中 `-1,4` 的含义是：本差异小节的内容相当于原始文件的从第1行开始的4行。而第4、6、7、8行是原始文件中的内容，加起来刚好是4行。
* 第3行定位语句中 `+1,4` 的含义是：本差异小节的内容相当于目标文件的从第1行开始的4行。而第5、6、7、8行是目标文件中的内容，加起来刚好是4行。
* 命令 `diff` 是基于行比较，所以即使改正了一个字，也显示为一整行的修改（参见差异文件第4、5行）。Git 对 `diff` 进行了扩展，还提供一种逐词比较的差异比较方法，参见本书第2篇“11.4.4 差异比较：git diff”小节。
* 第9-18行是第二个差异小节。第9行是一条差异定位语句。
* 第9行定位语句中 `-6,6` 的含义是：本差异小节的内容相当于原始文件的从第6行开始的6行。而第10-15行是原始文件中的内容，加起来刚好是6行。
* 第9行定位语句中 `+6,7` 的含义是：本差异小节的内容相当于目标文件的从第6行开始的7行。而第10-12、15-18行是目标文件中的内容，加起来刚好是7行。

**命令 patch 相当于 diff 的反向操作**

有了 `hello` 和 `diff.txt` 文件，可以放心地将 `world` 文件删除或用 hello 文件将 world 文件覆盖。用下面的命令可以还原 `world` 文件：

::

  $ cp hello world
  $ patch world < diff.txt

也可以保留 `world` 和 `diff.txt` 文件，删除 `hello` 文件或用 `word` 文件将 `hello` 文件覆盖。用下面的命令可以恢复 `hello` 文件：

::

  $ cp world hello
  $ patch -R hello < diff.txt

命令 `diff` 和 `patch` 还可以对目录进行比较操作，这也就是 Linus 在 1991-2002 年用于维护 Linux 不同版本间差异的办法。可以用此命令，在没有版本控制系统的情况下，记录并保存改动前后的差异，还可以将差异文件注入版本控制系统（如果有的话）。

标准的 `diff` 和 `patch` 命令存在一个局限，就是不能对二进制文件进行处理。对二进制文件的修改或添加会在差异文件中缺失，进而丢失对二进制文件的改动或添加。Git 对差异文件格式提供了扩展支持，支持二进制文件的比较，解决了这个问题。这点可以参考本书第7篇“第38章 补丁中的二进制文件”的相关内容。


CVS —— 开启版本控制大爆发
===========================

CVS（Concurrent Versions System） [#]_ 诞生于 1985 年，是由荷兰阿姆斯特丹 VU 大学的 Dick Grune 教授实现的。当时 Dick Grune 和两个学生共同开发一个项目，但是三个人的工作时间无法协调到一起，迫切需要一个记录和协同代码开发的工具软件。于是 Dick Grune 通过脚本语言对 RCS （一个针对单独文件的多版本管理工具）进行封装，设计出有史以来第一个被大规模使用的版本控制工具。在 Dick 教授的网站上介绍了 CVS 这段早期的历史。 [#]_

::

  “在1985年一个糟糕的秋日里，我站在校汽车站等车回家，脑海里一直纠结着一件事 —— 如何处理 RCS 文件、
  用户文件（工作区）和 Entries 文件的复杂关系，有的文件可能会缺失、冲突、删除，等等。我的头有些晕了，
  于是决定画一个大表，将复杂的关联画在其中看看出来的结果是什么样的……”


1986年 Dick 通过新闻组发布了CVS，1989 年由 Brian Berliner 将 CVS 用 C 语言重写。

从 CVS 的历史可以看出 CVS 不是设计出来的，而是被实际需要逼出来的，因此根据实用为上的原则，借用了已有的针对单一文件的多版本管理工具 RCS。CVS 采用客户端/服务器架构设计，版本库位于服务器端，实际上就是一个 RCS 文件容器。每一个 RCS 文件以 “,v” 作为文件名后缀，用于保存对应文件的历次更改历史。RCS 文件中只保留一个版本的完全拷贝，其他历次更改仅将差异存储其中，使得存储变得非常有效率。我在 2008 年设计的一个 SVN 管理后台 pySvnManager [#]_ ，实际上也采用了 RCS 作为保存 SVN 授权文件变更记录的“数据库”。

图1-1展示了CVS版本控制系统的工作原理，可以看到作为RCS文件容器的CVS版本库和工作区目录结构的一一对应关系。

.. figure:: /images/meet-git/cvs-arch.png
   :scale: 80

   图1-1：CVS版本控制系统示意图

CVS 的这种实现方式的最大好处就是简单。把版本库中随便一个目录拿出来就可以成为另外一个版本库。如果将版本库中的一个 RCS 文件重命名，工作区检出的文件名也相应地改变。这种低成本的服务器管理模式成为很多 CVS 粉丝至今不愿离开 CVS 的原因。

CVS 的出现让软件工程师认识到了原来还可以这样工作。CVS 成功地为后来的版本控制系统确立了标准，像提交（commit）、检入（checkin）、检出（checkout）、里程碑（tag）、分支（branch）等概念早在 CVS 中就已经确立。CVS 的命令行格式也被后来的版本控制系统竞相模仿。
df
在 2001 年，我正为使用 CVS 激动不已的时候，公司领导要求采用和美国研发部门同样的版本控制解决方案。于是，我的项目组率先进行了从 CVS 到该商业版本控制工具的迁移 [#]_ 。虽然商业版本控制工具有更漂亮的界面及更好的产品整合性，但是就版本控制本身而言，商业版本控制工具存在着如下缺陷。

* 采用黑盒子式的版本库设计。让人捉摸不透的版本库设计，最大的目的可能就是阻止用户再迁移到其他平台。
* 缺乏版本库整理工具。如果有一个文件（如记录核弹起爆密码的文件）检入到版本库中，就没有办法再彻底移除它。
* 商业版本控制工具很难为个人提供版本控制解决方案，除非个人愿意花费高昂的许可证费用。
* 商业版本控制工具注定是小众软件，对新员工的培训成本不可忽视。

而上述商业版本控制系统的缺点，恰恰是 CVS 及其他开源版本控制系统的强项。但在经历了最初的成功之后，CVS 也尽显疲态：

* 服务器端松散的 RCS 文件，导致在建立里程碑或分支时缺乏效率，服务器端文件越多，速度越慢。
* 分支和里程碑不可见，因为它们被分散地记录在服务器端的各个RCS文件中。
* 合并困难重重，因为缺乏对合并的追踪从而导致重复合并，引发严重冲突。
* 缺乏对原子提交的支持，会导致客户端向服务器端提交不完整的数据。
* 不能优化存储内容相同但文件名不同的文件，因为在服务器端每个文件都是单独进行差异存储的。
* 不能对文件和目录的重命名进行版本控制，虽然直接在服务器端修改RCS文件名可以让改名后的文件保持历史，但是这样做实际会破坏历史。

CVS 的成功开启了版本控制系统的大爆发，各式各样的版本控制系统如雨后春笋般地诞生了。新的版本控制系统或多或少地解决了 CVS 版本控制系统存在的问题。在这些版本控制系统中最典型的就是 Subversion（SVN）。



SVN —— 集中式版本控制集大成者
================================

Subversion [#]_ ，因其命令行工具名为 `svn` 因此通常被简称为 SVN。SVN 由 CollabNet 公司于 2000 年资助并发起开发，目的是创建一个更好用的版本控制系统以取代 CVS。前期 SVN 的开发使用 CVS 做版本控制，到了 2001 年，SVN 已经可以用于自己的版本控制了 [#]_ 。

我开始真正关注 SVN 是在 2005 年，那时 SVN 正经历着后端存储上的变革，即从BDB（简单的关系型数据库）到 FSFS（文件数据库）的转变。FSFS 相对于 BDB 具有稳定性、免维护性，以及实现的可视性，我马上就被 SVN 吸引了。图1-2展示了SVN版本控制系统的工作原理。

.. figure:: /images/meet-git/svn-arch.png
   :scale: 80

   图1-2：SVN版本控制系统示意图

SVN 的每一次提交，都会在服务器端的 `db/revs` 和 `db/revprops` 目录下各创建一个以顺序数字编号命名的文件。其中 `db/revs` 目录下的文件（即变更集文件）记录与上一个提交之间的差异（字母A表示新增，M表示修改，D表示删除）。在 `db/revprops` 目录下的同名文件（没有在图1-2中体现）则保存着提交日志、作者、提交时间等信息。这样设计的好处有：

* 拥有全局版本号。每提交一次， SVN 的版本号就会自动加一。这为 SVN 的使用提供了极大的便利。回想 CVS 时代，每个文件都拥有各自独立的版本号（RCS版本号），要想获得全局版本号，只能通过手工不断地建立里程碑来实现。
* 实现了原子提交。SVN 不会像 CVS 那样出现部分文件被提交而其他没有被提交的状态。
* 文件名不受限制。因为服务器端不再需要建立和客户端文件相似的文件名，这样，文件的命名就不再受服务器操作系统的字符集及大小写的限制。
* 文件和目录重命名也得到了支持。

SVN 最具有特色的功能是轻量级拷贝，例如将目录 trunk 拷贝为 branches/v1.x 只相当于在 `db/revs` 目录中的变更集文件中用特定的语法做了一下标注，无须真正的文件拷贝。SVN 使用轻量级拷贝的功能，轻松地解决了 CVS 存在的里程碑和分支的创建速度慢又不可见的问题，使用 SVN 创建里程碑和分支只在眨眼之间。

SVN 在版本库授权上也有改进，不再像 CVS 那样依赖操作系统本身对版本库目录和文件进行授权，而是采用授权文件的方式来实现。

SVN 还有一个创举，就是在工作区跟踪目录下（.svn目录）为当前目录中的每一个文件都保存一份冗余的原始拷贝。这样做的好处是部分命令不再需要网络连接，例如文件修改的差异比较，以及错误更改的回退等。

正是由于 SVN 的这些闪亮的功能，使得 SVN 成为继 CVS 之后诞生的诸多版本控制系统中的集大成者，成为开源社区一时的新宠，也成为当时各个企业版本控制的最佳选择之一。

但是 SVN 相对 CVS 在本质上并没有突破，都属于集中式版本控制系统。就是一个项目只有唯一的一个版本库与之对应，所有的项目成员都通过网络向该服务器进行提交。这样的设计除了容易出现单点故障以外，单是查看日志、提交数据等操作的延迟，就足以让基于广域网协同工作的团队抓狂了。

除了集中式版本控制系统固有的问题外，SVN 的里程碑、分支的设计也被证明是一个错误，虽然这个错误使得 SVN 拥有了快速创建里程碑和分支的能力，但是这个错误导致了如下的更多问题。

* 项目文件在版本库中必须按照一定的目录结构进行部署，否则就可能无法建立里程碑和分支。

  我在项目咨询过程中就见过很多团队，直接在版本库的根目录下创建项目文件。这样的版本库布局，在需要创建里程碑和分支时就无从下手了，因为根目录是不能拷贝到子目录中的。所以 SVN 的用户在创建版本库时必须遵守一个古怪的约定：先创建三个顶级目录 `/trunk` 、 `/tags` 和 `/branches` 。

* 创建里程碑和分支会破坏精心设计的授权。

  SVN 的授权是基于目录的，分支和里程碑也被视为目录（和其他目录没有分别）。因此每次创建分支或里程碑时，就要将针对 `/trunk` 目录及其子目录的授权在新建的分支或里程碑上重建。随着分支和里程碑数量的增多，授权愈加复杂，维护也愈加困难。

* 分支太随意从而导致混乱。SVN 的分支创建非常随意：可以基于 `/trunk` 目录创建分支，也可以基于其他任何目录创建分支。因此 SVN 很难画出一个有意义的分支图。再加上一次提交可以同时包含针对不同分支的文件变更，使得事情变得更糟。

* 虽然在 SVN 1.5 之后拥有了合并追踪功能，但这个功能会因为混乱的分支管理而被抵消。

2009 年底，SVN 由 CollabNet 公司交由 Apache 社区管理，至此 SVN 成为了 Apache 组织的一个子项目 [#]_ 。这对 SVN 到底意味着什么？是开发的停滞，还是新的开始，结果如何我们将拭目以待。

Git —— Linus 的第二个伟大作品
==================================

Linux 之父 Linus 是坚定的 CVS 反对者，他也同样地反对 SVN。这就是为什么在 1991-2002 这十余年间，Linus 宁可通过手工修补文件的方式维护代码，也迟迟不愿使用 CVS。我想在那个时期要想劝说 Linus 使用 CVS 只有一个办法：把 CVS 服务器请进 Linus 的卧室，并对外配以千兆带宽。

2002年至2005 年， Linus 顶着开源社区精英们的口诛笔伐，选择了一个商业版本控制系统 BitKeeper 作为 Linux 内核的代码管理工具 [#]_ 。BitKeeper 是一款不同于像 CVS/SVN 那样的集中式版本控制工具，而是一款分布式版本控制工具。

分布式版本控制系统最大的反传统之处在于，可以不需要集中式的版本库，每个人都工作在通过克隆操作建立的本地版本库中。也就是说每个人都拥有一个完整的版本库，所有操作包括查看提交日志、提交、创建里程碑和分支、合并分支、回退等都直接在本地完成而不需要网络连接。每个人都是本地版本库的主人，不再有谁能提交谁不能提交的限制，加之多样的协同工作模型（版本库间推送、拉回，及补丁文件传送等）让开源项目的参与度有爆发式增长。

2005 年发生的一件事最终导致了 Git 的诞生。在2005年4月 Andrew Tridgell，即大名鼎鼎的 Samba 的作者，试图尝试对 BitKeeper 反向工程，以开发一个能与 BitKeeper 交互的开源工具。这激怒了 BitKeeper 软件的所有者 BitMover 公司，要求收回对 Linux 社区免费使用 BitKeeper 的授权 [#]_ 。迫不得已， Linus 选择了自己开发一个分布式版本控制工具以替代 BitKeeper。以下是Git 诞生大事记 [#]_ ：

* 2005年4月3日，开始开发 Git。
* 2005年4月6日，项目发布。
* 2005年4月7日，Git就可以作为自身的版本控制工具了。
* 2005年4月18日，发生第一个多分支合并。
* 2005年4月29日，Git的性能就已经达到了 Linus 的预期。
* 2005年6月16日，Linux 核心 2.6.12 发布，那时 Git 已经在维护 Linux 核心的源代码了。

Linus 以一个文件系统专家和内核设计者的视角对 Git 进行了设计，其独特的设计，让 Git 拥有非凡的性能和最为优化的存储能力。完成原型设计后，在2005年7月26日，Linus 功成身退，将 Git 的维护交给另外一个 Git 的主要贡献者 Junio C Hamano [#]_ ，直到现在。

最初的 Git 除了一些核心命令以外，其他的都用脚本语言开发，而且每个功能都作为一条独立的命令，例如克隆操作用 `git-clone` ，提交操作用命令 `git-commit` 。这导致 Git 拥有庞大的命令集，使用习惯也和其他版本控制系统格格不入。随着 Git 的开发者和使用者的增加，Git 也在逐渐演变，例如到 1.5.4 版本时，将一百多个独立的命令封装为一个 `git` 命令，使它看起来更像是一个独立的工具，而且 Git 的使用习惯也逐渐被普通用户所接受。

经过短短几年的发展，众多的开源项目都纷纷从 SVN 或其他版本控制系统迁移到 Git。虽然版本控制系统的迁移过程是痛苦的，但是因为迁移到Git会带来开发效率的极大提升，以及巨大的效益，所以很快就会忘记迁移的痛苦过程，并很快就会适应新的工作模式。在 Git 网站上列出了几个使用 Git 的重量级项目，个个都是人们耳熟能详的，除了 Git 和 Linux 内核外，还有：Perl、Eclipse、Gnome、KDE、Qt、Ruby on Rails、Android、PostgreSQL、Debian、X.org，当然还有 GitHub 的上百万个项目。

Git 虽然是在 Linux 下开发的，但现在已经可以跨平台运行在所有主流的操作系统上，包括 Linux、Mac OS X 和 Windows 等。可以说每一个使用计算机的用户都可以分享 Git 带来的便利和快乐。

----

.. [#] Linus Torvalds于2007-05-03在Google的演讲：http://www.youtube.com/watch?v=4XpnKHJAok8
.. [#] 此处是故意将“字”写成“子”，以便两个文件进行差异比较。
.. [#] http://www.nongnu.org/cvs/
.. [#] http://www.cs.vu.nl/~dick/CVS.html
.. [#] http://pysvnmanager.sourceforge.net/
.. [#] 于是就有了这篇文章：http://www.worldhello.net/doc/cvs_vs_starteam/
.. [#] http://subversion.apache.org/
.. [#] http://svnbook.red-bean.com/en/1.5/svn.intro.whatis.html#svn.intro.history
.. [#] http://en.wikipedia.org/wiki/Apache_Subversion
.. [#] http://en.wikipedia.org/wiki/BitKeeper
.. [#] http://en.wikipedia.org/wiki/Andrew_Tridgell
.. [#] http://en.wikipedia.org/wiki/Git_%28software%29
.. [#]   http://marc.info/?l=git&m=112243466603239
