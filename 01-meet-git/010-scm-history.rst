版本控制的前世和今生
********************

除了茫然未知的宇宙，几乎任何事务都是从无到有，从简陋到完善。大多时候，随着时间车轮的滚滚向前，历史被抛在脑后，如同我们的现代社会，世界大同，再也看不到蛮荒的影子，只能通过想像神游那个刀耕火种、男耕女织的慢生活岁月。

版本控制是一个另类。虽然其历史并不短暂，也有几十年，但是他的演进历史却一直在社会的各个角落（研发团队）重演着，惊人相似。有从未使用甚至从未听说过版本控制系统的，他或者他的团队就像停留在黑暗的史前时代，任由数据自生自灭。也有人使用有着几十年历史的 CVS 或者其改良版 Subversion 的，让时间空耗在网络连接的等待中。还有就是以 Git 为代表的分布式版本控制系统，已经风靡整个开源社区，正加速向每个人靠近。

黑暗的史前时代
===============

人们谈及远古，总爱以黑暗形容。黑暗实际上指的是秩序和工具的匮乏而不是自然，如以自然环境而论，工业化和城市化对环境的破坏，现今才是最黑暗的年代。对软件开发来说也是如此，虽然遥远的 C 语言一统天下的日子，要比今天选 Java，选 .Net，还是选择脚本语言的多选题要简单的多，但是从工具和秩序上讲，过去的年代是黑暗的。

看看我经历的版本控制的“史前时代”。在大学里，代码分散的拷贝在各个软盘中，最终我会被搞糊涂，不知道哪个软盘中的代码是最优的，因为最新并非最优，失败的重构会毁掉原来尚能运作的代码。在我工作的第一年，代码的管理并未改观，还是以简单的目录拷贝进行数据的备份，三四个程序员利用文件服务器共享进行协同，公共类库和头文件往往被互相覆盖，痛苦不堪。可以很明显的看出来，那时我尚不知道版本控制工具为何物。我的版本控制史前时代一直延续到2000年，那时 CVS 已经诞生 14 年，而我在那时对 CVS 还一无所知。

实际上，即便是在 CVS 出现之前的“史前时代”，也已经出现了非常好用的源码比较和补丁工具： `diff` 和 `patch` ，他们今天依然生命力顽强。大名鼎鼎的 Linus Torvalds 先生也对这两个工具偏爱有加，在 1991-2002 年之间，Linus Torvalds一直顽固的用 diff 和 patch 管理着 Linux 的代码，即使不断有人提醒他 CVS 的存在。

那么来看看 `diff` 和 `patch` ，熟悉它们，对理解版本控制系统（差异存储），使用版本控制系统（代码比较和冲突合并）都有莫大好处。

**命令 diff 用于比较两个文本文件或目录的差异**

先来构造两个文件：

..   * 文件 `hello`
..   
..     ::
..   
..       应该杜绝文章中的错别子。
..       
..       但是无论使用
..       * 全拼，双拼
..       * 还是五笔
..       
..       是人就有可能犯错，软件更是如此。
..       
..       犯了错，就要扣工资！
..       
..       改正的成本可能会很高。
..   
..   
..   * 文件 `world`
..   
..     ::
..   
..       应该杜绝文章中的错别字。
..       
..       但是无论使用
..       * 全拼，双拼
..       * 还是五笔
..       
..       是人就有可能犯错，软件更是如此。
..       
..       改正的成本可能会很高。
..       
..       但是“只要眼球足够多，所有Bug都好捉”，
..       这就是开源的哲学之一。


+-----------------------------------------+-------------------------------------------+
| 文件 `hello`                            | 文件 `world`                              |
+=========================================+===========================================+
|   ::                                    |   ::                                      |
|                                         |                                           |
|     应该杜绝文章中的错别子。            |     应该杜绝文章中的错别字。              |
|                                         |                                           |
|     但是无论使用                        |     但是无论使用                          |
|     * 全拼，双拼                        |     * 全拼，双拼                          |
|     * 还是五笔                          |     * 还是五笔                            |
|                                         |                                           |
|     是人就有可能犯错，软件更是如此。    |     是人就有可能犯错，软件更是如此。      |
|                                         |                                           |
|     犯了错，就要扣工资！                |     改正的成本可能会很高。                |
|                                         |                                           |
|     改正的成本可能会很高。              |     但是“只要眼球足够多，所有Bug都好捉”， |
|                                         |     这就是开源的哲学之一。                |
+-----------------------------------------+-------------------------------------------+

对这两个文件执行 diff 命令，并通过输出重定向，将差异保存在 `diff.txt` 文件中。

::

  $ diff -u hello world > diff.txt

上面执行 `diff` 命令的 `-u` 参数很重要，决定了差异输出是否带有上下文。打开文件 `diff.txt` ，会看到其中的差异比较结果。为了说明方便，为每一行增添了行号。

::

   1 --- hello       2010-09-21 17:45:33.551610940 +0800
   2 +++ world       2010-09-21 17:44:46.343610465 +0800
   3 @@ -1,4 +1,4 @@
   4 -应该杜绝文章中的错别子。
   5 +应该杜绝文章中的错别字。
   6  
   7  但是无论使用
   8  * 全拼，双拼
   9 @@ -6,6 +6,7 @@
  10  
  11  是人就有可能犯错，软件更是如此。
  12  
  13 -犯了错，就要扣工资！
  14 -
  15  改正的成本可能会很高。
  16 +
  17 +但是“只要眼球足够多，所有Bug都好捉”，
  18 +这就是开源的哲学之一。

上面的差异文件，可以这么理解：

* 第1,2行，分别记录了比较的原始文件和目标文件的文件名及时间戳。以三个减号（---）开始的行标识的是原始文件，以三个加号（+++）开始的行标识的是目标文件。
* 在比较内容中，以减号（-）开始的行是只出现在原始文件中的行，例如：第4,13,14行。
* 在比较内容中，以减号（+）开始的行是只出现在目标文件中的行，例如：第5,16-18行。
* 在比较内容中，以空格开始的行，是在原始文件和目标文件中都出现的行，例如：第6-8,10-12,15行。这些行用作差异比较的上下文。
* 第3-8行是第一个差异小节。每个差异小节以一行差异定位语句开始。第3行就是一条差异定位语句，其前后分别用两个@ 进行标识。
* 第3行定位语句中 `-1,4` 的含义是：本差异小节的内容相当于原始文件的第1行开始的4行。而第4,6,7,8行是原始文件中的内容，加起来刚好是4行。
* 第3行定位语句中 `+1,4` 的含义是：本差异小节的内容相当于目标文件的第1行开始的4行。而第5,6,7,8行是目标文件中的内容，加起来刚好是4行。
* 命令 `diff` 是基于行比较，所以即使改正了一个字，也显示为一整行的修改。Git 对 `diff` 进行了扩展，提供了一种逐词比较的差异比较方法，在后面可以看到。
* 第9-18行是第二个差异小节。第9行是一条差异定位语句。
* 第9行定位语句中 `-6,6` 的含义是：本差异小节的内容相当于原始文件的第6行开始的6行。而第10-15行是原始文件中的内容，加起来刚好是6行。
* 第9行定位语句中 `+6,7` 的含义是：本差异小节的内容相当于目标文件的第6行开始的7行。而第10-12,15-18行是目标文件中的内容，加起来刚好是7行。

**命令 patch 相当于 diff 的反向操作**

有了 `hello` 和 `diff.txt` 文件，可以放心的将 `world` 文件删除。用下面的命令可以还原 `world` 文件：

::

  $ cp hello world
  $ patch world < diff.txt

或者也可以保留 `world` 和 `diff.txt` 文件，将原始的 `hello` 文件删除。用下面的命令可以还原 `hello` 文件：

::

  $ cp world hello
  $ patch -R hello < diff.txt

命令 `diff` 和 `patch` 还可以对目录进行比较操作，这也就是 Linus Torvalds 在 1991-2002 年用以维护 Linux 不同版本间差异的办法。可以用此命令，在没有版本控制系统的情况下，将改动前后的差异记录并保存，并可以将差异文件注入版本控制系统（如果有的话）。

标准的 `diff` 和 `patch` 命令存在一个局限，就是不能对二进制文件进行处理。对二进制文件的修改和添加会在 diff 差异文件中缺失，进而丢失对二进制文件的改动或添加。Git 对差异文件格式提供了扩展支持，支持二进制文件的比较，解决了这个问题。可以参考本书第7部分相关章节的内容。

CVS —— 开启版本控制大爆发
===========================

CVS (Concurrent Versions System) 诞生于 1985 年，是由荷兰阿姆斯特丹 VU 大学的 Dick Grune 教授实现的。当时 Dick Grune 和两个学生共同开发一个项目，但是三个人的工作时间无法协调到一起，迫切需要一个记录和协同代码开发的工具软件。于是通过脚本语言对 RCS （一个单独文件版本管理工具）进行封装，设计出有史以来第一个被大规模使用的版本控制工具。在 Dick 教授的网站上介绍了 CVS 这段早期的历史。

::

  “在1985年一个糟糕的秋日里，我站在学校汽车站等车回家，脑海里一直纠结着一件事 —— 如何处理 RCS 文件、
  用户文件（工作区）和 Entries 文件的复杂关系，有的文件可能会缺失，冲突，删除，等等。我的头有些晕了，
  于是决定画一个大表，将复杂的关联画在其中看看出来的结果是什么样的...”

  摘自 Dick Grune 的网站: http://www.cs.vu.nl/~dick/CVS.html

1986年 Dick 将 CVS 通过新闻组发布，1989 年由 Brian Berliner 将 CVS 用 C 语言重写。

从 CVS 的历史可以看出 CVS 不是设计出来的，是实际需要逼出来的，因此根据实用为上的原则，借用了已有的单一文件版本管理工具 RCS。CVS 采用客户端-服务器结构设计，版本库位于服务器端，版本库实际上就是一个 RCS 文件容器。每一个 RCS 文件以 `,v` 作为文件名后缀，保存对应文件的历次更改历史。RCS 文件中只保留一个版本库的完全拷贝，其他历次更改仅将差异存储其中，使得存储变得非常有效率。我在 2008 年设计的一个 SVN 管理后台 pySvnManager，实际上也采用了 RCS 作为 SVN 授权文件的变更记录“数据库”。

下图显示的是 CVS 的工作原理图，可以看出版本库和工作区的一一对应关系。

TODO: 图式。

CVS 的这种实现方式的最大好处就是简单。可以把版本库中随便一个目录拿出来就可以成为另外的一个版本库。如果把版本库中的一个 RCS 文件重命名，工作区检出的文件名也相应的改变。这种低成本的服务器管理模式成为很多 CVS 粉丝至今不愿离开 CVS 的原因。

CVS 的出现，让软件工程师认识到了原来开发者还可以这样进行工作上的协同。CVS 成功的为后来的版本控制系统确立了标准，像提交（commit）、检入（checkin）、检出（checkout）、里程碑（tag）、分支（branch）等概念早在 CVS 中就已经确立。CVS 的命令行格式也被后来的版本控制系统竞相模仿。

在 2001 年，我正为使用 CVS 激动不已的时候，公司领导要求采用和美国研发部门同样的版本控制解决方案。于是，我的项目组率先进行了从 CVS 到该商业版本控制工具的迁移。虽然商业版本控制工具有更漂亮的界面以及更好的产品整合性，但是就版本控制本身而言，商业版本控制工具存在着缺陷。

* 黑盒子式的版本库设计。让人捉摸不透的版本库设计最大目的可能就是阻止用户再迁移到其他平台。
* 缺乏版本库整理工具。如果有一个文件（如包含核弹起爆密码的文件）检入到版本库中，没有办法彻底移除。
* 商业版本控制工具很难为个人提供版本控制解决方案，除非个人愿意花费高昂的许可证费用。
* 商业版本控制工具注定是小众软件，对新员工的培训成本不可忽视。

而上述版本控制的缺点，恰恰是 CVS 以及其他开源版本控制系统的强项。

但在经历了最初的成功之后，CVS 也尽显疲态。

* 服务器端松散的 RCS 文件，导致在建立里程碑或者分支时缺乏效率，服务器端文件越多，速度越慢。
* 分支和里程碑不可见，因为分散保存在服务器端各个RCS文件中。
* 缺乏对原子提交的支持，会导致客户端向服务器端提交不完整的数据。
* 相同内容不同文件名的文件不能优化存储，因为在服务器端每个文件单独进行差异存储。
* 不能对文件和目录的重命名进行版本控制，因为直接改变RCS文件名会破坏历史。

CVS 的成功开启了版本控制系统的大爆发，各式各样的版本控制工具雨后春笋般的诞生了。新的版本控制系统或多或少的解决了 CVS 版本控制系统存在的问题，而这些版本控制系统中最典型的就是 Subversion (SVN)。

SVN —— 集中式版本控制集大成者
================================

Subversion，因其命令行工具名为 `svn` 因此通常简称为 SVN。SVN 由 CollabNet 公司于 2000 年资助和发起开发，目的是创建一个更好用的版本控制系统以替换 CVS。前期 SVN 的开发使用 CVS 做版本控制，到了 2001 年，SVN 已经可以用作自己的版本控制了。

我开始真正关注 SVN 是在 2005 年，那时 SVN 正经历着后端存储上的变革，即从BDB 简单的关系型数据库到 FSFS 文件系统上的转变。FSFS 相对于 BDB 的免维护性，以及实现的可视性，我马上就被 SVN 吸引了。

看一看下面的这张 SVN 版本控制系统结构图。

TODO: 

SVN 的每一次提交，都会在服务器端的 `db/revs` 和 `db/revprops` 目录下各创建一个以顺序数字编号命名的文件（事物文件），其中一个文件保存和上一个版本间的差异，另外一个保存提交日志等信息，而产生的事物文件的文件名也正是该提交的提交版本号。这样设计的好处有：

* 全局版本号，每一次提交 SVN 的版本号自动加一。这为 SVN 的使用提供了极大的遍历。回想 CVS 时代，每个文件有各自独立的版本号（RCS版本号），要想获得全局版本号，只能通过建立里程碑的方式。
* 实现了原子提交。不会像 CVS 那样出现部分文件被提交而其他没有被提交的状态。
* 文件名不受限制，因为服务器端不再需要建立和客户端文件相似的文件名，这样文件的命名不再受服务器操作系统字符集及大小写的限制。
* 文件和目录重命名也得到了支持。

SVN 最具有特色的功能是轻量级拷贝，例如将目录 trunk 拷贝为 branches/v1.x 只相当于在 `db/revs` 目录中的事物文件中用特定的语法做一下标注即可，无需真正的文件拷贝。SVN 使用轻量级拷贝的功能，轻松的解决了 CVS 存在的里程碑和分支创建速度慢又不可见的问题，使用 SVN 创建里程碑和分支只在眨眼之间。

SVN 在版本库授权上也有改进，不再像 CVS 那样依赖对操作系统对版本库目录结构有限的授权模型，而是采用授权文件进行。

SVN 还有一个创举，就是在工作区跟踪目录下保存了一份冗余的原始拷贝，好处是部分命令不在需要网络连接，例如文件修改的差异比较，以及错误更改的回退。

正是由于 SVN 有了这些闪亮的功能，使得 SVN 成为 CVS 之后诞生的诸多版本控制控制中的集大成者，成为开源社区一时的首选，也成为企业的版本控制最佳选择。

但是 SVN 相对 CVS 在本质上并没有突破，都属于集中式版本控制系统。就是一个项目只有一个唯一的版本库与之对应，所有的项目成员都通过网络向该服务器进行提交。这样的设计容易出现单点故障不说，单是由于网络延迟导致查看日志、提交操作等需要等待就让足以让基于广域网协同的团队抓狂。

除了集中式版本控制系统固有的问题外，SVN 的里程碑、分支的设计也被证明是一个错误，虽然这个错误使得 SVN 拥有了快速创建里程碑和分支的能力，但是这个错误导致了更多的问题。

* 项目文件在版本库中必须按照一定的目录结构进行部署，否则可能无法建立里程碑和分支。

  我在项目咨询过程中就见过很多项目，直接在版本库的根目录下创建文件。这样的版本库布局当要创建里程碑和分支时就无从下手了，因为根目录是不能拷贝到子目录中的。所以 SVN 的用户在创建版本库时必需遵守一个古怪的约定：创建三个顶级目录 `/trunk`, `/tags` 和 `/branches` 。

* 精心设计的授权，因为创建里程碑和分支而被破坏。

  SVN 的授权是基于目录的，但是无法对分支和里程碑做出区分（因为分支里程碑就是目录）。因此每次创建分支或者里程碑，就要将 /trunk 目录下的所有授权拷贝到分支或者里程碑对应的目录上。随着分支和里程碑数量的增多，愈加复杂，维护也愈加困难。

* 混乱的分支。SVN 的分支创建可以非常随意，可以基于 /trunk 创建分支，或者其他任何目录创建分支，因此很难画出一个有意义的分支图。再加上一次提交可以同时发生在不同的分支中，让事情变得更遭。

* 虽然在 SVN 1.5 之后拥有了合并追踪功能，但这个功能会因为混乱的分支管理而被抵消。

2009 年底，SVN 由 CollabNet 公司交由 Apache 社区管理，至此 SVN 成为了 Apache 组织的一个子项目。这对 SVN 到底意味着什么？是开发的停滞，还是新的开始，拭目以待。

Git —— Linus 的第二个伟大作品
==================================

Linux 之父 Linus Torvalds 是坚定的 CVS 反对者，同样也反对 SVN。这就是为什么在 1991-2002 这十余年间，Linus 宁可手工通过补丁文件方式维护代码，也迟迟不使用 CVS。我想在那个时期要想劝说 Linus 使用 CVS 只有一个办法，把 CVS 服务器搬进 Linus 的卧室，并对外配以千兆带宽。

在 2002-2005 年 Linus Torvalds 冒着开源社区精英的口诛笔伐，选择了一个商业版本控制系统 BitKeeper 作为 Linux 内核的代码管理工具。因为 BitKeeper 是一款不同于 CVS/SVN 那样的集中式版本控制工具，而是一款分布式版本控制工具。

分布式版本控制系统最大的反传统之处在于，可以不需要集中式的版本库，每个人都工作在通过克隆操作建立的本地版本库中。就是说每个人都拥有一个完整的版本库，所有操作包括察看提交日志、提交、创建里程碑和分支、合并分支、回退等都直接在本地完成不需要网络连接。和他人的版本库交互可以有多种方式：可以推送（PUSH），可以拉回（PULL)，可以通过补丁文件传送。

2005 年发生的一件事，最终导致了 Git 的诞生。在2005年4月 Andrew Tridgell，即大名鼎鼎的 Samba 的作者试图尝试对 BitKeeper 反向工程，以开发一个开源工具与 BitKeeper 交互。这激怒了 BitKeeper 软件的所有者 BitMover 公司，要求收回对 Linux 社区免费使用 BitKeeper 的授权。迫不得已 Torvalds 选择自己开发一个分布式版本控制工具以替代 BitKeeper。

* Git 的开发始于2005年4月3日。
* 项目于2005年4月6日发布。
* 在4月7日，Git就可以作为自身的版本控制了。
* 第一个多分支合并发生于4月18日。
* 到4月29日，Git的性能已经达到了 Torvalds 的预期。
* 到6月16日，Linux 核心 2.6.12 发布，那时 Linux 核心已经在使用 Git 来维护源代码了。

Torvalds 以一个文件系统设计者和内核开发者的视角对 Git 进行了设计，其独特的设计，让 Git 拥有非凡的性能和最为优化的存储。在完成原型设计后，在2005年7月26日，Torvalds 功成身退，将 Git 的维护交给另外一个 Git 的主要贡献者 Junio Hamano，直到现在。

最初的 Git 除了一些核心命令，其他都用脚本语言开发，而且每个功能都作为一条独立的命令，例如克隆操作用 `git-clone` ，提交操作用命令 `git-commit` 。这导致 Git 拥有庞大的命令集，使用习惯也和其他版本控制系统格格不入。随着 Git 的开发者和使用者的增加，Git 也在逐渐的演变，例如到 1.5.4 版本时，将一百多个独立命令封装为一个 `git` 命令，看起来更像是一个独立的工具了。而且 Git 的使用习惯也逐渐能给让普通用户所接受。

经过短短的几年的发展，众多的开源项目都纷纷从 SVN 或其他版本控制系统转移到 Git。因为迁移到Git会带来开发效率的极大提升，带来巨大的效益，很快就会忘记迁移过程的痛苦，很快就会适应新的工作模式。在 Git 网站列出了几个使用 Git 的重量级项目，个个都是人们耳熟能详的，除了 Git 和 Linux 内核外，还有：Perl, Eclipse, Gnome, KDE, Qt, Ruby on Rails, Android, PostgreSQL, Debian, X.org。当然还有 GitHub 上的百万个项目。

Git 虽然是在 Linux 下开发的，现在已经可以跨平台运行在所有主流的操作系统上，包括 Linux, Windows 和 Mac OSX 等。可以说每一个使用计算机的用户都可以分享 Git 带来的快乐。
