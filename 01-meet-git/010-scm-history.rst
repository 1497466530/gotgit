版本控制的前世和今生
********************

除了茫然未知的宇宙，几乎任何事务都是从无到有，从简陋到完善。大多时候，随着时间车轮的滚滚向前，历史被抛在脑后，如同我们的现代社会，世界大同，再也看不到蛮荒的影子，只能通过想像神游那个刀耕火种、男耕女织的慢生活岁月。

版本控制是一个另类。虽然其历史并不短暂，也有几十年，但是他的演进历史却一直在社会的各个角落（研发团队）重演着，惊人相似。有从未使用甚至从未听说过版本控制系统的，他或者他的团队就像停留在黑暗的史前时代，任由数据自生自灭。也有人使用有着几十年历史的 CVS 或者其改良版 Subversion 的，让时间空耗在网络连接的等待中。还有就是以 Git 为代表的分布式版本控制系统，已经风靡整个开源社区，正加速向每个人靠近。

黑暗的史前时代
===============

人们谈及远古，总爱以黑暗形容。黑暗实际上指的是秩序和工具的匮乏而不是自然，如以自然环境而论，工业化和城市化对环境的破坏，现今才是最黑暗的年代。对软件开发来说也是如此，虽然遥远的 C 语言一统天下的日子，要比今天选 Java，选 .Net，还是选择脚本语言的多选题要简单的多，但是从工具和秩序上讲，过去的年代是黑暗的。

看看我经历的版本控制的“史前时代”。在大学里，代码分散的拷贝在各个软盘中，最终我会被搞糊涂，不知道哪个软盘中的代码是最优的，因为最新并非最优，失败的重构会毁掉原来尚能运作的代码。在我工作的第一年，代码的管理并未改观，还是以简单的目录拷贝进行数据的备份，三四个程序员利用文件服务器共享进行协同，公共类库和头文件往往被互相覆盖，痛苦不堪。可以很明显的看出来，那时我尚不知道版本控制工具为何物。我的版本控制史前时代一直延续到2000年，那时 CVS 已经诞生 14 年，而我在那时对 CVS 还一无所知。

实际上，即便是在 CVS 出现之前的“史前时代”，也已经出现了非常好用的源码比较和补丁工具： `diff` 和 `patch` ，他们今天依然生命力顽强。大名鼎鼎的 Linus Torvalds 先生也对这两个工具偏爱有加，在 1991-2002 年之间，Linus Torvalds一直顽固的用 diff 和 patch 管理着 Linux 的代码，即使不断有人提醒他 CVS 的存在。

那么来看看 `diff` 和 `patch` ，熟悉它们，对理解版本控制系统（差异存储），使用版本控制系统（代码比较和冲突合并）都有莫大好处。

**命令 diff 用于比较两个文本文件或目录的差异**

先来构造两个文件：

..   * 文件 `hello`
..   
..     ::
..   
..       应该杜绝文章中的错别子。
..       
..       但是无论使用
..       * 全拼，双拼
..       * 还是五笔
..       
..       是人就有可能犯错，软件更是如此。
..       
..       犯了错，就要扣工资！
..       
..       改正的成本可能会很高。
..   
..   
..   * 文件 `world`
..   
..     ::
..   
..       应该杜绝文章中的错别字。
..       
..       但是无论使用
..       * 全拼，双拼
..       * 还是五笔
..       
..       是人就有可能犯错，软件更是如此。
..       
..       改正的成本可能会很高。
..       
..       但是“只要眼球足够多，所有Bug都好捉”，
..       这就是开源的哲学之一。


+-----------------------------------------+-------------------------------------------+
| 文件 `hello`                            | 文件 `world`                              |
+=========================================+===========================================+
|   ::                                    |   ::                                      |
|                                         |                                           |
|     应该杜绝文章中的错别子。            |     应该杜绝文章中的错别字。              |
|                                         |                                           |
|     但是无论使用                        |     但是无论使用                          |
|     * 全拼，双拼                        |     * 全拼，双拼                          |
|     * 还是五笔                          |     * 还是五笔                            |
|                                         |                                           |
|     是人就有可能犯错，软件更是如此。    |     是人就有可能犯错，软件更是如此。      |
|                                         |                                           |
|     犯了错，就要扣工资！                |     改正的成本可能会很高。                |
|                                         |                                           |
|     改正的成本可能会很高。              |     但是“只要眼球足够多，所有Bug都好捉”， |
|                                         |     这就是开源的哲学之一。                |
+-----------------------------------------+-------------------------------------------+

对这两个文件执行 diff 命令，并通过输出重定向，将差异保存在 `diff.txt` 文件中。

::

  $ diff -u hello world > diff.txt

上面执行 `diff` 命令的 `-u` 参数很重要，决定了差异输出是否带有上下文。打开文件 `diff.txt` ，会看到其中的差异比较结果。为了说明方便，为每一行增添了行号。

::

   1 --- hello       2010-09-21 17:45:33.551610940 +0800
   2 +++ world       2010-09-21 17:44:46.343610465 +0800
   3 @@ -1,4 +1,4 @@
   4 -应该杜绝文章中的错别子。
   5 +应该杜绝文章中的错别字。
   6  
   7  但是无论使用
   8  * 全拼，双拼
   9 @@ -6,6 +6,7 @@
  10  
  11  是人就有可能犯错，软件更是如此。
  12  
  13 -犯了错，就要扣工资！
  14 -
  15  改正的成本可能会很高。
  16 +
  17 +但是“只要眼球足够多，所有Bug都好捉”，
  18 +这就是开源的哲学之一。

上面的差异文件，可以这么理解：

* 第1,2行，分别记录了比较的原始文件和目标文件的文件名及时间戳。以三个减号（---）开始的行标识的是原始文件，以三个加号（+++）开始的行标识的是目标文件。
* 在比较内容中，以减号（-）开始的行是只出现在原始文件中的行，例如：第4,13,14行。
* 在比较内容中，以减号（+）开始的行是只出现在目标文件中的行，例如：第5,16-18行。
* 在比较内容中，以空格开始的行，是在原始文件和目标文件中都出现的行，例如：第6-8,10-12,15行。这些行用作差异比较的上下文。
* 第3-8行是第一个差异小节。每个差异小节以一行差异定位语句开始。第3行就是一条差异定位语句，其前后分别用两个@ 进行标识。
* 第3行定位语句中 `-1,4` 的含义是：本差异小节的内容相当于原始文件的第1行开始的4行。而第4,6,7,8行是原始文件中的内容，加起来刚好是4行。
* 第3行定位语句中 `+1,4` 的含义是：本差异小节的内容相当于目标文件的第1行开始的4行。而第5,6,7,8行是目标文件中的内容，加起来刚好是4行。
* 命令 `diff` 是基于行比较，所以即使改正了一个字，也显示为一整行的修改。Git 对 `diff` 进行了扩展，提供了一种逐词比较的差异比较方法，在后面可以看到。
* 第9-18行是第二个差异小节。第9行是一条差异定位语句。
* 第9行定位语句中 `-6,6` 的含义是：本差异小节的内容相当于原始文件的第6行开始的6行。而第10-15行是原始文件中的内容，加起来刚好是6行。
* 第9行定位语句中 `+6,7` 的含义是：本差异小节的内容相当于目标文件的第6行开始的7行。而第10-12,15-18行是目标文件中的内容，加起来刚好是7行。

**命令 patch 相当于 diff 的反向操作**

有了 `hello` 和 `diff.txt` 文件，可以放心的将 `world` 文件删除。用下面的命令可以还原 `world` 文件：

::

  $ cp hello world
  $ patch world < diff.txt

或者也可以保留 `world` 和 `diff.txt` 文件，将原始的 `hello` 文件删除。用下面的命令可以还原 `hello` 文件：

::

  $ cp world hello
  $ patch -R hello < diff.txt

命令 `diff` 和 `patch` 还可以对目录进行比较操作，这也就是 Linus Torvalds 在 1991-2002 年用以维护 Linux 不同版本间差异的办法。可以用此命令，在没有版本控制系统的情况下，将改动前后的差异记录并保存，并可以将差异文件注入版本控制系统（如果有的话）。

标准的 `diff` 和 `patch` 命令存在一个局限，就是不能对二进制文件进行处理。对二进制文件的修改和添加会在 diff 差异文件中缺失，进而丢失对二进制文件的改动或添加。Git 对差异文件格式提供了扩展支持，支持二进制文件的比较，解决了这个问题。可以参考本书第7部分相关章节的内容。

CVS 开启了版本控制大爆发
=========================

CVS 诞生于 1986 年，是教授和学生的一个开发项目中，根据需要用脚本语言从 RCS 工具封装得来。1988 年用 C 语言重新实现。

by Dick Grune.  --- Dick Grune's website <http://www.cs.vu.nl/~dick/CVS.html#History>

这么伟大的工具，诞生在三个人的项目中，而且是产生在学校。联想到 互联网的诞生就是源自一群研究生，不得不感叹中国教育和学术环境的改善有多么大的空间。 如果能够解放高校的创造力，中国将会是一番如何气象。

CVS 源自于 RCS，即使在重新实现后，后端的数据存储结构依然采用 RCS 的文件格式。RCS 实际上就是单独的一个文件的版本控制系统。一个 RCS 文件以 ,v 作为扩展名，保存对应文件的历次更改历史，历次更改差异保存。我在 2008 年写的一个 SVN 管理后台 pySvnManager，实际上也采用了 RCS 作为 SVN 授权文件的变更记录“数据库”。

在 2001 年，我正为 CVS 激动不已的时候，公司领导要求采用和公司在美国研发机构采用同样的版本控制解决方案。于是，我的项目组率先进行了 CVS 到该商业版本控制工具的迁移。在最终的调研报告中，我实事求是的写了一篇比较文章《CVS Beat Starteam》。现在来看，其中的部分论断也并未过时，而且我认为 CVS 的一些特性，仍然让人怀念。

* 首先 CVS 确定了版本控制系统的标准。

  CVS 的出现，让软件工程师认识到了原来开发者可以这样进行工作上的协同。于是各式各样的版本控制工具雨后春笋般的诞生了。

  其他版本控制的设计或多或少受到 CVS 影响，至少在命令行上会尽量保持一致。

* CVS 版本库裁剪易如反掌。

  因为 CVS 的后端采用目录以及 RCS 文件进行管理，而 RCS 文件的路径和检出文件的路径是一一对应的，因此对 CVS 版本库的裁剪，就像在客户端移动/删除目录一样简单。

  反观 SVN，版本库的整理需要更复杂的操作： svnadmin dump, svndumpfilter, svnadmin load。

  对于很多商业版本控制系统，整理版本库根本就不可能实现。

  Git 版本库的整理非常零活，但是相比 CVS，显得有些复杂，可能用到 git-reset， git-rebase, git-read-tree, git-filter-branch 等命令。

* CVS 的 Tag 和 Git 中的 Tag 一样 是不允许更改的。这一点比 SVN 要强。

  SVN 的 Tag 实际上和分支无本质的区别，靠的是约定俗成，而不是在机制上进行限制。

SVN 号称自己是 A better CVS
============================

SVN 诞生之初是解决 

真正关注 SVN 是在 2005 年底，那时 SVN 正经历着后端存储上的变革，即从BDB 简单的关系型数据库到 FSFS 文件系统上的转变。FSFS 相对于 BDB 的免维护性，以及实现的可视性，我马上就被 SVN 吸引了。

SVN 对 CVS 用户不可抗拒的力量

* 原子提交
* 目录改名
* 分支创建在眨眼之间
* 授权管理使用授权文件，脱离 CVS 依靠文件系统授权模型

Linux 导致了开源版本控制系统的诞生
==================================

(1991–2002), changes to the software were passed around as patches and archived files 

这期间，有非官方的 CVS 服务器，但是 Linus 一直拒绝使用

为什么 Linus 痛恨 CVS 包括 SVN？

除非把 SVN 服务器立在 Linus 书房里

In 2002, the Linux kernel project began using a proprietary DVCS system called BitKeeper.

In 2005, the relationship between the community that developed the Linux kernel and the commercial company that developed BitKeeper broke down, and the tool’s free-of-charge status was revoked.

开源版本控制的三巨头
====================

