
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2.4. Git重置 &mdash; GotGit</title>
    
    <link rel="stylesheet" href="../static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="/stylesheets/master.css" type="text/css" />
    <link rel="stylesheet" href="/stylesheets/syntax.css" type="text/css" />
    <link rel="stylesheet" href="../static/worldhello.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/translations.js"></script>
    <link rel="top" title="GotGit" href="../index.html" />
    <link rel="up" title="2. Git独奏" href="index.html" />
    <link rel="next" title="2.5. Git检出" href="050-git-checkout.html" />
    <link rel="prev" title="2.3. Git对象" href="030-head-master-commit-refs.html" /> 
  </head>
  <body>
    <div id='header'>
      <h1><a href='/'>World Hello</a></h1>

      <div id='menu'>
        <ul>
          <li><a href='/' id='home-link' title='Home'>首页</a></li>
          <li><a href='/blog.html' id='blog-link' title='Blog'>博客</a></li>
          <li><a href='/doc/' id='docs-link' title='Docs'>文章</a></li>
          <li><a href='/about.html' id='about-link' title='About'>关于</a></li>
          <li><a href='http://github.com/gotgit' target='_blank' title='GitHub' rel='me' id='github-link'>GitHub</a></li>
          <li><a href='http://weibo.com/gotgit' title='微博' target='_blank' id='weibo-link'>微博</a></li>
        </ul>
      </div>
    </div>

    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="050-git-checkout.html" title="2.5. Git检出"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="030-head-master-commit-refs.html" title="2.3. Git对象"
             accesskey="P">上一页</a> |</li>
        <li><a href="../index.html">GotGit</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">2. Git独奏</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">2.4. Git重置</a><ul>
<li><a class="reference internal" href="#master">2.4.1. 分支游标master的探秘</a></li>
<li><a class="reference internal" href="#reflog">2.4.2. 用reflog挽救错误的重置</a></li>
<li><a class="reference internal" href="#git-reset">2.4.3. 深入了解<strong class="command">git reset</strong>命令</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="030-head-master-commit-refs.html"
                        title="上一章">2.3. Git对象</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="050-git-checkout.html"
                        title="下一章">2.5. Git检出</a></p>
  <h3>本页</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/02-git-solo/040-git-reset.txt"
           rel="nofollow">显示源代码</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>快速搜索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="转向" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    输入相关的术语，模块，类或者函数名称进行搜索
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="git">
<h1>2.4. Git重置<a class="headerlink" href="#git" title="永久链接至标题">¶</a></h1>
<p>在上一章了解了版本库中对象的存储方式以及分支master的实现。即master分支在版本库的引用目录（.git/refs）中体现为一个引用文件<tt class="file docutils literal"><span class="pre">.git/refs/heads/master</span></tt>，其内容就是分支中最新提交的提交ID。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cat .git/refs/heads/master
e695606fc5e31b2ff9038a48a3d363f4c21a3d86
</pre></div>
</div>
<p>上一章还通过对提交本身数据结构的分析，看到提交可以通过到父提交的关联实现对提交历史的追溯。注意：下面的<strong class="command">git log</strong>命令中使用了<tt class="docutils literal"><span class="pre">--oneline</span></tt>参数，类似于<tt class="docutils literal"><span class="pre">--pretty=oneline</span></tt>，但是可以显示更短小的提交ID。参数<tt class="docutils literal"><span class="pre">--oneline</span></tt>在Git 1.6.3 及以后版本提供，老版本的Git可以使用参数<tt class="docutils literal"><span class="pre">--pretty=oneline</span> <span class="pre">--abbrev-commit</span></tt>替代。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git log --graph --oneline
* e695606 which version checked in?
* a0c641e who does commit?
* 9e8a761 initialized.
</pre></div>
</div>
<p>那么是不是有新的提交发生的时候，代表master分支的引用文件的内容会改变呢？代表master分支的引用文件的内容可以人为的改变么？本章就来探讨用<strong class="command">git reset</strong>命令改变分支引用文件内容，即实现分支的重置。</p>
<div class="section" id="master">
<h2>2.4.1. 分支游标master的探秘<a class="headerlink" href="#master" title="永久链接至标题">¶</a></h2>
<p>先来看看当有新的提交发生的时候，文件<tt class="file docutils literal"><span class="pre">.git/refs/heads/master</span></tt>的内容如何改变。首先在工作区创建一个新文件，姑且叫做<tt class="file docutils literal"><span class="pre">new-commit.txt</span></tt>，然后提交到版本库中。</p>
<div class="highlight-python"><div class="highlight"><pre>$ touch new-commit.txt
$ git add new-commit.txt
$ git commit -m &quot;does master follow this new commit?&quot;
[master 4902dc3] does master follow this new commit?
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 new-commit.txt
</pre></div>
</div>
<p>此时工作目录下会有两个文件，其中文件<tt class="file docutils literal"><span class="pre">new-commit.txt</span></tt>是新增的。</p>
<div class="highlight-python"><div class="highlight"><pre>$ ls
new-commit.txt  welcome.txt
</pre></div>
</div>
<p>来看看master分支指向的提交ID是否改变了。</p>
<ul>
<li><p class="first">先看看在版本库引用空间（.git/refs/目录）下的<tt class="docutils literal"><span class="pre">master</span></tt>文件内容的确更改了，指向了新的提交。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cat .git/refs/heads/master
4902dc375672fbf52a226e0354100b75d4fe31e3
</pre></div>
</div>
</li>
<li><p class="first">再用<strong class="command">git log</strong>查看一下提交日志，可以看到刚刚完成的提交。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git log --graph --oneline
* 4902dc3 does master follow this new commit?
* e695606 which version checked in?
* a0c641e who does commit?
* 9e8a761 initialized.
</pre></div>
</div>
</li>
</ul>
<p>引用<tt class="docutils literal"><span class="pre">refs/heads/master</span></tt>就好像是一个游标，在有新的提交发生的时候指向了新的提交。可是如果只可上、不可下，就不能称为“游标”。Git提供了<strong class="command">git reset</strong>命令，可以将“游标”指向任意一个存在的提交ID。下面的示例就尝试人为的更改游标。（注意下面的命令中使用了<tt class="docutils literal"><span class="pre">--hard</span></tt>参数，会破坏工作区未提交的改动，慎用。）</p>
<div class="highlight-python"><div class="highlight"><pre>$ git reset --hard HEAD^
HEAD is now at e695606 which version checked in?
</pre></div>
</div>
<p>还记得上一章介绍的<tt class="docutils literal"><span class="pre">HEAD^</span></tt>代表了<tt class="docutils literal"><span class="pre">HEAD</span></tt>的父提交么？所以这条命令就相当于将master重置到上一个老的提交上。来看一下master文件的内容是否更改了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cat .git/refs/heads/master
e695606fc5e31b2ff9038a48a3d363f4c21a3d86
</pre></div>
</div>
<p>果然master分支的引用文件的指向更改为前一次提交的ID了。而且通过下面的命令可以看出新添加的文件<tt class="file docutils literal"><span class="pre">new-commit.txt</span></tt>也丢失了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ ls
welcome.txt
</pre></div>
</div>
<p>重置命令不仅仅可以重置到前一次提交，重置命令可以直接使用提交ID重置到任何一次提交。</p>
<ul class="simple">
<li>通过<strong class="command">git log</strong>查询到最早的提交ID。</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>$ git log --graph --oneline
* e695606 which version checked in?
* a0c641e who does commit?
* 9e8a761 initialized.
</pre></div>
</div>
<ul class="simple">
<li>然后重置到最早的一次提交。</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>$ git reset --hard 9e8a761
HEAD is now at 9e8a761 initialized.
</pre></div>
</div>
<ul class="simple">
<li>重置后会发现<tt class="file docutils literal"><span class="pre">welcome.txt</span></tt>也回退到原始版本库，曾经的修改都丢失了。</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>$ cat welcome.txt
Hello.
</pre></div>
</div>
<p>使用重置命令很危险，会彻底的丢弃历史。那么还能够通过浏览提交历史的办法找到丢弃的提交ID，再使用重置命令恢复历史么？不可能！因为重置让提交历史也改变了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git log
commit 9e8a761ff9dd343a1380032884f488a2422c495a
Author: Jiang Xin &lt;jiangxin@ossxp.com&gt;
Date:   Sun Nov 28 12:48:26 2010 +0800

    initialized.
</pre></div>
</div>
</div>
<div class="section" id="reflog">
<h2>2.4.2. 用reflog挽救错误的重置<a class="headerlink" href="#reflog" title="永久链接至标题">¶</a></h2>
<p>如果没有记下重置前master分支指向的提交ID，想要重置回原来的提交真的是一件麻烦的事情（去对象库中一个一个地找）。幸好Git提供了一个挽救机制，通过<tt class="file docutils literal"><span class="pre">.git/logs</span></tt>目录下日志文件记录了分支的变更。默认非裸版本库（带有工作区）都提供分支日志功能，这是因为带有工作区的版本库都有如下设置：</p>
<div class="highlight-python"><div class="highlight"><pre>$ git config core.logallrefupdates
true
</pre></div>
</div>
<p>查看一下master分支的日志文件<tt class="file docutils literal"><span class="pre">.git/logs/refs/heads/master</span></tt>中的内容。下面命令显示了该文件的最后几行。为了排版的需要，还将输出中的40位的SHA1提交ID缩短。</p>
<div class="highlight-python"><div class="highlight"><pre>$ tail -5 .git/logs/refs/heads/master
dca47ab a0c641e Jiang Xin &lt;jiangxin@ossxp.com&gt; 1290999606 +0800    commit (amend): who does commit?
a0c641e e695606 Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291022581 +0800    commit: which version checked in?
e695606 4902dc3 Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291435985 +0800    commit: does master follow this new commit?
4902dc3 e695606 Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291436302 +0800    HEAD^: updating HEAD
e695606 9e8a761 Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291436382 +0800    9e8a761: updating HEAD
</pre></div>
</div>
<p>可以看出这个文件记录了master分支指向的变迁，最新的改变追加到文件的末尾因此最后出现。最后一行可以看出因为执行了<strong class="command">git reset &#8211;hard</strong>命令，指向的提交ID由<tt class="docutils literal"><span class="pre">e695606</span></tt>改变为<tt class="docutils literal"><span class="pre">9e8a761</span></tt>。</p>
<p>Git提供了一个<strong class="command">git reflog</strong>命令，对这个文件进行操作。使用<tt class="docutils literal"><span class="pre">show</span></tt>子命令可以显示此文件的内容。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git reflog show master | head -5
9e8a761 master@{0}: 9e8a761: updating HEAD
e695606 master@{1}: HEAD^: updating HEAD
4902dc3 master@{2}: commit: does master follow this new commit?
e695606 master@{3}: commit: which version checked in?
a0c641e master@{4}: commit (amend): who does commit?
</pre></div>
</div>
<p>使用<strong class="command">git reflog</strong>的输出和直接查看日志文件最大的不同在于显示顺序的不同，即最新改变放在了最前面显示，而且只显示每次改变的最终的SHA1哈希值。还有个重要的区别在于使用<strong class="command">git reflog</strong>的输出中还提供一个方便易记的表达式：<tt class="docutils literal"><span class="pre">&lt;refname&gt;&#64;{&lt;n&gt;}</span></tt>。这个表达式的含义是引用<tt class="docutils literal"><span class="pre">&lt;refname&gt;</span></tt>之前第&lt;n&gt;次改变时的SHA1哈希值。</p>
<p>那么将引用master切换到两次变更之前的值，可以使用下面的命令。</p>
<ul>
<li><p class="first">重置master为两次改变之前的值。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git reset --hard master@{2}
HEAD is now at 4902dc3 does master follow this new commit?
</pre></div>
</div>
</li>
<li><p class="first">重置后工作区中文件<tt class="file docutils literal"><span class="pre">new-commit.txt</span></tt>又回来了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ ls
new-commit.txt  welcome.txt
</pre></div>
</div>
</li>
<li><p class="first">提交历史也回来了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git log --oneline
4902dc3 does master follow this new commit?
e695606 which version checked in?
a0c641e who does commit?
9e8a761 initialized.
</pre></div>
</div>
</li>
</ul>
<p>此时如果再用<strong class="command">git reflog</strong>查看，会看到恢复master的操作也记录在日志中了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git reflog show master | head -5
4902dc3 master@{0}: master@{2}: updating HEAD
9e8a761 master@{1}: 9e8a761: updating HEAD
e695606 master@{2}: HEAD^: updating HEAD
4902dc3 master@{3}: commit: does master follow this new commit?
e695606 master@{4}: commit: which version checked in?
</pre></div>
</div>
</div>
<div class="section" id="git-reset">
<h2>2.4.3. 深入了解<strong class="command">git reset</strong>命令<a class="headerlink" href="#git-reset" title="永久链接至标题">¶</a></h2>
<p>重置命令（<strong class="command">git reset</strong>）是Git最常用的命令之一，也是最危险，最容易误用的命令。来看看<strong class="command">git reset</strong>命令的用法。</p>
<div class="highlight-python"><div class="highlight"><pre>用法一： git reset [-q] [&lt;commit&gt;] [--] &lt;paths&gt;...
用法二： git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [&lt;commit&gt;]
</pre></div>
</div>
<p>上面列出了两个用法，其中 &lt;commit&gt; 都是可选项，可以使用引用或者提交ID，如果省略 &lt;commit&gt; 则相当于使用了HEAD的指向作为提交ID。</p>
<p>上面列出的两种用法的区别在于，第一种用法在命令中包含路径<tt class="file docutils literal"><span class="pre">&lt;paths&gt;</span></tt>。为了避免路径和引用（或者提交ID）同名而冲突，可以在<tt class="file docutils literal"><span class="pre">&lt;paths&gt;</span></tt>前用两个连续的短线（减号）作为分隔。</p>
<p>第一种用法（包含了路径<tt class="file docutils literal"><span class="pre">&lt;paths&gt;</span></tt>的用法）<strong>不会</strong>重置引用，更不会改变工作区，而是用指定提交状态（&lt;commit&gt;）下的文件（&lt;paths&gt;）替换掉暂存区中的文件。例如命令<strong class="command">git reset HEAD &lt;paths&gt;</strong>相当于取消之前执行的<strong class="command">git add &lt;paths&gt;</strong>命令时改变的暂存区。</p>
<p>第二种用法（不使用路径<tt class="file docutils literal"><span class="pre">&lt;paths&gt;</span></tt>的用法）则会<strong>重置引用</strong>。根据不同的选项，可以对暂存区或者工作区进行重置。参照下面的版本库模型图，来看一看不同的参数对第二种重置语法的影响。</p>
<blockquote>
<div><div class="figure">
<a class="reference internal image-reference" href="../images/git-reset.png"><img alt="../images/git-reset.png" src="../images/git-reset.png" style="width: 721.6px; height: 318.4px;" /></a>
</div>
</div></blockquote>
<p>命令格式: git reset [&#8211;soft | &#8211;mixed | &#8211;hard ] [&lt;commit&gt;]</p>
<ul>
<li><p class="first">使用参数<tt class="docutils literal"><span class="pre">--hard</span></tt>，如：<strong class="command">git reset &#8211;hard &lt;commit&gt;</strong>。</p>
<p>会执行上图中的1、2、3全部的三个动作。即：</p>
<ol class="arabic simple">
<li>替换引用的指向。引用指向新的提交ID。</li>
<li>替换暂存区。替换后，暂存区的内容和引用指向的目录树一致。</li>
<li>替换工作区。替换后，工作区的内容变得和暂存区一致，也和HEAD所指向的目录树内容相同。</li>
</ol>
</li>
<li><p class="first">使用参数<tt class="docutils literal"><span class="pre">--soft</span></tt>，如:<strong class="command">git reset &#8211;soft &lt;commit&gt;</strong>。</p>
<p>会执行上图中的操作1。即只更改引用的指向，不改变暂存区和工作区。</p>
</li>
<li><p class="first">使用参数<tt class="docutils literal"><span class="pre">--mixed</span></tt>或者不使用参数（缺省即为<tt class="docutils literal"><span class="pre">--mixed</span></tt>），如:<strong class="command">git reset &lt;commit&gt;</strong>。</p>
<p>会执行上图中的操作1和操作2。即更改引用的指向以及重置暂存区，但是不改变工作区。</p>
</li>
</ul>
<p>下面通过一些示例，看一下重置命令的不同用法。</p>
<ul>
<li><p class="first">命令：<strong class="command">git reset</strong></p>
<p>仅用HEAD指向的目录树重置暂存区，工作区不会受到影响，相当于将之前用<strong class="command">git add</strong>命令更新到暂存区的内容撤出暂存区。引用也未改变，因为引用重置到HEAD相当于没有重置。</p>
</li>
<li><p class="first">命令：<strong class="command">git reset HEAD</strong></p>
<p>同上。</p>
</li>
<li><p class="first">命令：<strong class="command">git reset &#8211; filename</strong></p>
<p>仅将文件<tt class="file docutils literal"><span class="pre">filename</span></tt>撤出暂存区，暂存区中其他文件不改变。相当于对命令<strong class="command">git add filename</strong>的反向操作。</p>
</li>
<li><p class="first">命令：<strong class="command">git reset HEAD filename</strong></p>
<p>同上。</p>
</li>
<li><p class="first">命令：<strong class="command">git reset &#8211;soft HEAD^</strong></p>
<p>工作区和暂存区不改变，但是引用向前回退一次。当对最新提交的提交说明或者提交的更改不满意时，撤销最新的提交以便重新提交。</p>
<p>在之前曾经介绍过一个修补提交命令<strong class="command">git commit &#8211;amend</strong>，用于对最新的提交进行重新提交以修补错误的提交说明或者错误的提交文件。修补提交命令实际上相当于执行了下面两条命令。（注：文件<tt class="file docutils literal"><span class="pre">.git/COMMIT_EDITMSG</span></tt>保存了上次的提交日志）</p>
<div class="highlight-python"><div class="highlight"><pre>$ git reset --soft HEAD^
$ git commit -e -F .git/COMMIT_EDITMSG
</pre></div>
</div>
</li>
<li><p class="first">命令：<strong class="command">git reset HEAD^</strong></p>
<p>工作区不改变，但是暂存区会回退到上一次提交之前，引用也会回退一次。</p>
</li>
<li><p class="first">命令：<strong class="command">git reset &#8211;mixed HEAD^</strong></p>
<p>同上。</p>
</li>
<li><p class="first">命令：<strong class="command">git reset &#8211;hard HEAD^</strong></p>
<p>彻底撤销最近的提交。引用回退到前一次，而且工作区和暂存区都会回退到上一次提交的状态。自上一次以来的提交全部丢失。</p>
</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="050-git-checkout.html" title="2.5. Git检出"
             >下一页</a> |</li>
        <li class="right" >
          <a href="030-head-master-commit-refs.html" title="2.3. Git对象"
             >上一页</a> |</li>
        <li><a href="../index.html">GotGit</a> &raquo;</li>
          <li><a href="index.html" >2. Git独奏</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>
      <br />
      全部内容以 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons 署名-非商业性使用-相同方式共享 3.0 协议发布</a>.
      <br />
        &copy; Copyright 2011, 蒋鑫。
      使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3 创建。

    </div>
  </body>
</html>