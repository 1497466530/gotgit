
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2.5. Git检出 &mdash; GotGit</title>
    
    <link rel="stylesheet" href="../static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="/stylesheets/master.css" type="text/css" />
    <link rel="stylesheet" href="/stylesheets/syntax.css" type="text/css" />
    <link rel="stylesheet" href="../static/worldhello.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/translations.js"></script>
    <link rel="top" title="GotGit" href="../index.html" />
    <link rel="up" title="2. Git独奏" href="index.html" />
    <link rel="next" title="2.6. 恢复进度" href="060-git-stage-n-stash.html" />
    <link rel="prev" title="2.4. Git重置" href="040-git-reset.html" /> 
  </head>
  <body>
    <div id='header'>
      <h1><a href='/'>World Hello</a></h1>

      <div id='menu'>
        <ul>
          <li><a href='/' id='home-link' title='Home'>首页</a></li>
          <li><a href='/blog.html' id='blog-link' title='Blog'>博客</a></li>
          <li><a href='/doc/' id='docs-link' title='Docs'>文章</a></li>
          <li><a href='/about.html' id='about-link' title='About'>关于</a></li>
          <li><a href='http://github.com/gotgit' target='_blank' title='GitHub' rel='me' id='github-link'>GitHub</a></li>
          <li><a href='http://weibo.com/gotgit' title='微博' target='_blank' id='weibo-link'>微博</a></li>
        </ul>
      </div>
    </div>

    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="060-git-stage-n-stash.html" title="2.6. 恢复进度"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="040-git-reset.html" title="2.4. Git重置"
             accesskey="P">上一页</a> |</li>
        <li><a href="../index.html">GotGit</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">2. Git独奏</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">2.5. Git检出</a><ul>
<li><a class="reference internal" href="#head">2.5.1. HEAD的重置即检出</a></li>
<li><a class="reference internal" href="#id1">2.5.2. 挽救分离头指针</a></li>
<li><a class="reference internal" href="#git-checkout">2.5.3. 深入了解<strong class="command">git checkout</strong>命令</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="040-git-reset.html"
                        title="上一章">2.4. Git重置</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="060-git-stage-n-stash.html"
                        title="下一章">2.6. 恢复进度</a></p>
  <h3>本页</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/02-git-solo/050-git-checkout.txt"
           rel="nofollow">显示源代码</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>快速搜索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="转向" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    输入相关的术语，模块，类或者函数名称进行搜索
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="git">
<h1>2.5. Git检出<a class="headerlink" href="#git" title="永久链接至标题">¶</a></h1>
<p>在上一章学习了重置命令（<strong class="command">git reset</strong>）。重置命令的一个用途就是修改引用（如master）的游标。实际上在执行重置命令的时候没有使用任何参数对所要重置的分支名进行设置，这是因为重置命名实际上所针对的是头指针HEAD。之所以没有改变HEAD的内容是因为HEAD指向了一个引用<tt class="docutils literal"><span class="pre">refs/heads/master</span></tt>，所以重置命令体现为分支“游标”的变更，HEAD本身一直指向的是refs/heads/master，并没有在重置时改变。</p>
<p>如果HEAD的内容不能改变而一直都指向master分支，那么Git如此精妙的分支设计岂不浪费？如果HEAD要改变该如何改变呢？本章将学习检出命令（<strong class="command">git checkout</strong>），该命令的实质就是修改HEAD本身的指向，该命令不会影响分支“游标”（如master）。</p>
<div class="section" id="head">
<h2>2.5.1. HEAD的重置即检出<a class="headerlink" href="#head" title="永久链接至标题">¶</a></h2>
<p>HEAD可以理解为“头指针”，是当前工作区的“基础版本”，当执行提交时，HEAD指向的提交将作为新提交的父提交。看看当前HEAD的指向。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cat .git/HEAD
ref: refs/heads/master
</pre></div>
</div>
<p>可以看出HEAD指向了分支 master。此时执行<strong class="command">git branch</strong>会看到当前处于master分支。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git branch -v
* master 4902dc3 does master follow this new commit?
</pre></div>
</div>
<p>现在使用<strong class="command">git checkout</strong>命令检出该ID的父提交，看看会怎样。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git checkout 4902dc3^
Note: checking out &#39;4902dc3^&#39;.

You are in &#39;detached HEAD&#39; state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b new_branch_name

HEAD is now at e695606... which version checked in?
</pre></div>
</div>
<p>出现了大段的输出！翻译一下，Git肯定又是在提醒我们了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git checkout 4902dc3^
注意: 正检出 &#39;4902dc3^&#39;.

您现在处于 &#39;分离头指针&#39; 状态。您可以检查、测试和提交，而不影响任何分支。
通过执行另外的一个 checkout 检出指令会丢弃在此状态下的修改和提交。

如果想保留在此状态下的修改和提交，使用 -b 参数调用 checkout 检出指令以
创建新的跟踪分支。如：

  git checkout -b new_branch_name

头指针现在指向 e695606... 提交说明为： which version checked in?
</pre></div>
</div>
<p>什么叫做“分离头指针”状态？查看一下此时HEAD的内容就明白了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cat .git/HEAD
e695606fc5e31b2ff9038a48a3d363f4c21a3d86
</pre></div>
</div>
<p>原来“分离头指针”状态指的就是HEAD头指针指向了一个具体的提交ID，而不是一个引用（分支）。</p>
<p>查看最新提交的reflog也可以看到当针对提交执行<strong class="command">git checkout</strong>命令时，HEAD头指针被更改了：由指向master分支变成了指向一个提交ID。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git reflog -1
e695606 HEAD@{0}: checkout: moving from master to 4902dc3^
</pre></div>
</div>
<p>注意上面的reflog是HEAD头指针的变迁记录，而非master分支。</p>
<p>查看一下HEAD和master对应的提交ID，会发现现在它们指向的不一样。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git rev-parse HEAD master
e695606fc5e31b2ff9038a48a3d363f4c21a3d86
4902dc375672fbf52a226e0354100b75d4fe31e3
</pre></div>
</div>
<p>前一个是HEAD头指针的指向，后一个是master分支的指向。而且还可以看到执行<strong class="command">git checkout</strong>命令并不像<strong class="command">git reset</strong>命令，分支（master）的指向并没有改变，仍旧指向原有的提交ID。</p>
<p>现在版本库的HEAD是基于<tt class="docutils literal"><span class="pre">e695606</span></tt>提交的。再做一次提交，HEAD会如何变化呢？</p>
<ul>
<li><p class="first">先做一次修改：创建一个新文件<tt class="file docutils literal"><span class="pre">detached-commit.txt</span></tt>，添加到暂存区中。</p>
<div class="highlight-python"><div class="highlight"><pre>$ touch detached-commit.txt
$ git add detached-commit.txt
</pre></div>
</div>
</li>
<li><p class="first">看一下状态，会发现其中有：“当前不处于任何分支”的字样，显然这是因为HEAD处于“分离头指针”模式。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git status
# Not currently on any branch.
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       new file:   detached-commit.txt
#
</pre></div>
</div>
</li>
<li><p class="first">执行提交。在提交输出中也会出现<tt class="docutils literal"><span class="pre">[detached</span> <span class="pre">HEAD</span> <span class="pre">...]</span></tt>的标识，也是对用户的警示。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git commit -m &quot;commit in detached HEAD mode.&quot;
[detached HEAD acc2f69] commit in detached HEAD mode.
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 detached-commit.txt
</pre></div>
</div>
</li>
<li><p class="first">此时头指针指向了新的提交。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cat .git/HEAD
acc2f69cf6f0ae346732382c819080df75bb2191
</pre></div>
</div>
</li>
<li><p class="first">再查看一下日志会发现新的提交是建立在之前的提交基础上的。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git log --graph --pretty=oneline
* acc2f69cf6f0ae346732382c819080df75bb2191 commit in detached HEAD mode.
* e695606fc5e31b2ff9038a48a3d363f4c21a3d86 which version checked in?
* a0c641e92b10d8bcca1ed1bf84ca80340fdefee6 who does commit?
* 9e8a761ff9dd343a1380032884f488a2422c495a initialized.
</pre></div>
</div>
</li>
</ul>
<p>记下新的提交ID（acc2f69），然后以master分支名作为参数执行<strong class="command">git checkout</strong>命令，会切换到master分支上。</p>
<ul>
<li><p class="first">切换到master分支。没有之前大段的文字警告。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git checkout master
Previous HEAD position was acc2f69... commit in detached HEAD mode.
Switched to branch &#39;master&#39;
</pre></div>
</div>
</li>
<li><p class="first">因为HEAD头指针重新指向了分支，而不是处于“断头模式”（分离头指针模式）。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cat .git/HEAD
ref: refs/heads/master
</pre></div>
</div>
</li>
<li><p class="first">切换之后，之前本地建立的新文件<tt class="file docutils literal"><span class="pre">detached-commit.txt</span></tt>不见了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ ls
new-commit.txt  welcome.txt
</pre></div>
</div>
</li>
<li><p class="first">切换之后，刚才的提交日志也不见了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git log --graph --pretty=oneline
* 4902dc375672fbf52a226e0354100b75d4fe31e3 does master follow this new commit?
* e695606fc5e31b2ff9038a48a3d363f4c21a3d86 which version checked in?
* a0c641e92b10d8bcca1ed1bf84ca80340fdefee6 who does commit?
* 9e8a761ff9dd343a1380032884f488a2422c495a initialized.
</pre></div>
</div>
</li>
</ul>
<p>刚才的提交在版本库的对象库中还存在么？看看刚才记下的提交ID。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git show acc2f69
commit acc2f69cf6f0ae346732382c819080df75bb2191
Author: Jiang Xin &lt;jiangxin@ossxp.com&gt;
Date:   Sun Dec 5 15:43:24 2010 +0800

    commit in detached HEAD mode.

diff --git a/detached-commit.txt b/detached-commit.txt
new file mode 100644
index 0000000..e69de29
</pre></div>
</div>
<p>可以看出这个提交现在仍在版本库中。由于这个提交没有被任何分支跟踪到，因此并不能保证这个提交会永久存在。实际上当reflog中含有该提交的日志过期后，这个提交随时都会从版本库中彻底清除。</p>
</div>
<div class="section" id="id1">
<h2>2.5.2. 挽救分离头指针<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>在“分离头指针”模式下进行的测试提交除了使用提交ID（acc2f69）访问之外，不能通过master分支或其他引用访问到。如果这个提交是master分支所需要的，那么该如何处理呢？如果使用上一章介绍的<strong class="command">git reset</strong>命令，的确可以将master分支重置到该测试提交<tt class="docutils literal"><span class="pre">acc2f69</span></tt>，但是如果那样就会丢掉master分支原先的提交<tt class="docutils literal"><span class="pre">4902dc3</span></tt>。使用合并操作（<strong class="command">git merge</strong>）可以实现两者的兼顾。</p>
<p>下面的操作会将提交<tt class="docutils literal"><span class="pre">acc2f69</span></tt>合并到master分支中来。</p>
<ul>
<li><p class="first">确认当前处于master分支。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git branch -v
* master 4902dc3 does master follow this new commit?
</pre></div>
</div>
</li>
<li><p class="first">执行合并操作，将<tt class="docutils literal"><span class="pre">acc2f69</span></tt>提交合并到当前分支。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git merge acc2f69
Merge made by recursive.
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 detached-commit.txt
</pre></div>
</div>
</li>
<li><p class="first">工作区中多了一个<tt class="file docutils literal"><span class="pre">detached-commit.txt</span></tt>文件。</p>
<div class="highlight-python"><div class="highlight"><pre>$ ls
detached-commit.txt  new-commit.txt  welcome.txt
</pre></div>
</div>
</li>
<li><p class="first">查看日志，会看到不一样的分支图。即在<tt class="docutils literal"><span class="pre">e695606</span></tt>提交开始出现了开发分支，而分支在最新的<tt class="docutils literal"><span class="pre">2b31c19</span></tt>提交发生了合并。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git log --graph --pretty=oneline
*   2b31c199d5b81099d2ecd91619027ab63e8974ef Merge commit &#39;acc2f69&#39;
|\
| * acc2f69cf6f0ae346732382c819080df75bb2191 commit in detached HEAD mode.
* | 4902dc375672fbf52a226e0354100b75d4fe31e3 does master follow this new commit?
|/
* e695606fc5e31b2ff9038a48a3d363f4c21a3d86 which version checked in?
* a0c641e92b10d8bcca1ed1bf84ca80340fdefee6 who does commit?
* 9e8a761ff9dd343a1380032884f488a2422c495a initialized.
</pre></div>
</div>
</li>
<li><p class="first">仔细看看最新提交，会看到这个提交有两个父提交。这就是合并的奥秘。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git cat-file -p HEAD
tree ab676f92936000457b01507e04f4058e855d4df0
parent 4902dc375672fbf52a226e0354100b75d4fe31e3
parent acc2f69cf6f0ae346732382c819080df75bb2191
author Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291535485 +0800
committer Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291535485 +0800

Merge commit &#39;acc2f69&#39;
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="git-checkout">
<h2>2.5.3. 深入了解<strong class="command">git checkout</strong>命令<a class="headerlink" href="#git-checkout" title="永久链接至标题">¶</a></h2>
<p>检出命令（<strong class="command">git checkout</strong>）是Git最常用的命令之一，同样也很危险，因为这条命令会重写工作区。</p>
<div class="highlight-python"><div class="highlight"><pre>用法一： git checkout [-q] [&lt;commit&gt;] [--] &lt;paths&gt;...
用法二： git checkout [&lt;branch&gt;]
用法三： git checkout [-m] [[-b|--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;]
</pre></div>
</div>
<p>上面列出的第一种用法和第二种用法的区别在于，第一种用法在命令中包含路径<tt class="file docutils literal"><span class="pre">&lt;paths&gt;</span></tt>。为了避免路径和引用（或者提交ID）同名而冲突，可以在<tt class="file docutils literal"><span class="pre">&lt;paths&gt;</span></tt>前用两个连续的短线（减号）作为分隔。</p>
<p>第一种用法的<tt class="docutils literal"><span class="pre">&lt;commit&gt;</span></tt>是可选项，如果省略则相当于从暂存区（index）进行检出。这和上一章的重置命令大不相同：重置的默认值是 HEAD，而检出的默认值是暂存区。因此重置一般用于重置暂存区（除非使用<tt class="docutils literal"><span class="pre">--hard</span></tt>参数，否则不重置工作区），而检出命令主要是覆盖工作区（如果<tt class="docutils literal"><span class="pre">&lt;commit&gt;</span></tt>不省略，也会替换暂存区中相应的文件）。</p>
<p>第一种用法（包含了路径<tt class="file docutils literal"><span class="pre">&lt;paths&gt;</span></tt>的用法）<strong>不会</strong>改变HEAD头指针，主要是用于指定版本的文件覆盖工作区中对应的文件。如果省略<tt class="docutils literal"><span class="pre">&lt;commit&gt;</span></tt>，会拿暂存区的文件覆盖工作区的文件，否则用指定提交中的文件覆盖暂存区和工作区中对应的文件。</p>
<p>第二种用法（不使用路径<tt class="file docutils literal"><span class="pre">&lt;paths&gt;</span></tt>的用法）则会<strong>改变</strong>HEAD头指针。之所以后面的参数写作<tt class="docutils literal"><span class="pre">&lt;branch&gt;</span></tt>，是因为只有HEAD切换到一个分支才可以对提交进行跟踪，否则仍然会进入“分离头指针”的状态。在“分离头指针”状态下的提交不能被引用关联到而可能会丢失。所以用法二最主要的作用就是切换到分支。如果省略<tt class="docutils literal"><span class="pre">&lt;branch&gt;</span></tt>则相当于对工作区进行状态检查。</p>
<p>第三种用法主要是创建和切换到新的分支（<tt class="docutils literal"><span class="pre">&lt;new_branch&gt;</span></tt>），新的分支从<tt class="docutils literal"><span class="pre">&lt;start_point&gt;</span></tt>指定的提交开始创建。新分支和我们熟悉的master分支没有什么实质的不同，都是在<tt class="docutils literal"><span class="pre">refs/heads</span></tt>命名空间下的引用。关于分支和<strong class="command">git checkout</strong>命令的这个用法会在后面的章节做具体的介绍。</p>
<p>下面的版本库模型图描述了<strong class="command">git checkout</strong>实际完成的操作。</p>
<blockquote>
<div><div class="figure">
<a class="reference internal image-reference" href="../images/git-checkout.png"><img alt="../images/git-checkout.png" src="../images/git-checkout.png" style="width: 709.6px; height: 318.4px;" /></a>
</div>
</div></blockquote>
<p>下面通过一些示例，具体的看一下检出命令的不同用法。</p>
<ul>
<li><p class="first">命令：<strong class="command">git checkout branch</strong></p>
<p>检出branch分支。要完成如图的三个步骤，更新HEAD以指向branch分支，以branch指向的树更新暂存区和工作区。</p>
</li>
<li><p class="first">命令：<strong class="command">git checkout</strong></p>
<p>汇总显示工作区、暂存区与HEAD的差异。</p>
</li>
<li><p class="first">命令：<strong class="command">git checkout HEAD</strong></p>
<p>同上。</p>
</li>
<li><p class="first">命令：<strong class="command">git checkout &#8211; filename</strong></p>
<p>用暂存区中<tt class="file docutils literal"><span class="pre">filename</span></tt>文件来覆盖工作区中的<tt class="file docutils literal"><span class="pre">filename</span></tt>文件。相当于取消自上次执行<strong class="command">git add filename</strong>以来（如果执行过）本地的修改。</p>
<p>这个命令很危险，因为对于本地的修改会悄无声息的覆盖，毫不留情。</p>
</li>
<li><p class="first">命令：<strong class="command">git checkout branch &#8211; filename</strong></p>
<p>维持HEAD的指向不变。将branch所指向的提交中的<tt class="file docutils literal"><span class="pre">filename</span></tt>替换暂存区和工作区中相应的文件。注意会将暂存区和工作区中的<tt class="file docutils literal"><span class="pre">filename</span></tt>文件直接覆盖。</p>
</li>
<li><p class="first">命令：<strong class="command">git checkout &#8211; . 或写做 git checkout .</strong></p>
<p>注意：<strong class="command">git checkout</strong>命令后的参数为一个点（“.”）。这条命令最危险！会取消所有本地的修改（相对于暂存区）。相当于将暂存区的所有文件直接覆盖本地文件，不给用户任何确认的机会！</p>
</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="060-git-stage-n-stash.html" title="2.6. 恢复进度"
             >下一页</a> |</li>
        <li class="right" >
          <a href="040-git-reset.html" title="2.4. Git重置"
             >上一页</a> |</li>
        <li><a href="../index.html">GotGit</a> &raquo;</li>
          <li><a href="index.html" >2. Git独奏</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>
      <br />
      全部内容以 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons 署名-非商业性使用-相同方式共享 3.0 协议发布</a>.
      <br />
        &copy; Copyright 2011, 蒋鑫。
      使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3 创建。

    </div>
  </body>
</html>