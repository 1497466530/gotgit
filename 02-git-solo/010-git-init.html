
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2.1. Git初始化 &mdash; GotGit</title>
    
    <link rel="stylesheet" href="../static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="/stylesheets/master.css" type="text/css" />
    <link rel="stylesheet" href="/stylesheets/syntax.css" type="text/css" />
    <link rel="stylesheet" href="../static/worldhello.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/translations.js"></script>
    <link rel="top" title="GotGit" href="../index.html" />
    <link rel="up" title="2. Git独奏" href="index.html" />
    <link rel="next" title="2.2. Git暂存区" href="020-git-stage.html" />
    <link rel="prev" title="2. Git独奏" href="index.html" /> 
  </head>
  <body>
    <div id='header'>
      <h1><a href='/'>World Hello</a></h1>

      <div id='menu'>
        <ul>
          <li><a href='/' id='home-link' title='Home'>首页</a></li>
          <li><a href='/blog.html' id='blog-link' title='Blog'>博客</a></li>
          <li><a href='/doc/' id='docs-link' title='Docs'>文章</a></li>
          <li><a href='/about.html' id='about-link' title='About'>关于</a></li>
          <li><a href='http://github.com/gotgit' target='_blank' title='GitHub' rel='me' id='github-link'>GitHub</a></li>
          <li><a href='http://weibo.com/gotgit' title='微博' target='_blank' id='weibo-link'>微博</a></li>
        </ul>
      </div>
    </div>

    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="020-git-stage.html" title="2.2. Git暂存区"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="index.html" title="2. Git独奏"
             accesskey="P">上一页</a> |</li>
        <li><a href="../index.html">GotGit</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">2. Git独奏</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">2.1. Git初始化</a><ul>
<li><a class="reference internal" href="#id1">2.1.1. 创建版本库及第一次提交</a></li>
<li><a class="reference internal" href="#id5">2.1.2. 思考：为什么工作区下有一个<tt class="file docutils literal"><span class="pre">.git</span></tt>目录？</a></li>
<li><a class="reference internal" href="#git-config">2.1.3. 思考：<strong class="command">git config</strong>命令参数的区别？</a></li>
<li><a class="reference internal" href="#id7">2.1.4. 思考：是谁完成的提交？</a></li>
<li><a class="reference internal" href="#id8">2.1.5. 思考：随意设置提交者姓名，是否太不安全？</a></li>
<li><a class="reference internal" href="#id9">2.1.6. 思考：命令别名是干什么的？</a></li>
<li><a class="reference internal" href="#id10">2.1.7. 备份本章的工作成果</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="index.html"
                        title="上一章">2. Git独奏</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="020-git-stage.html"
                        title="下一章">2.2. Git暂存区</a></p>
  <h3>本页</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/02-git-solo/010-git-init.txt"
           rel="nofollow">显示源代码</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>快速搜索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="转向" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    输入相关的术语，模块，类或者函数名称进行搜索
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="git">
<h1>2.1. Git初始化<a class="headerlink" href="#git" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>2.1.1. 创建版本库及第一次提交<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>您当前使用的是1.5.6或更高版本的Git么？</p>
<div class="highlight-python"><div class="highlight"><pre>$ git --version
git version 1.7.11.2
</pre></div>
</div>
<p>Git是一个活跃的项目，仍在不断的进化之中，不同Git版本的功能不尽相同。本书对Git的介绍涵盖了1.5.6到1.7.11版本，这也是目前Git的主要版本。如果您使用的Git版本低于1.5.6，那么请升级到1.5.6或更高的版本。本书示例使用的是1.7.11.2版本的Git，我们会尽可能地指出那些低版本不兼容的命令及参数。</p>
<p>在开始Git之旅之前，我们需要设置一下Git的环境变量，这个设置是一次性的工作。即这些设置会在全局文件（用户主目录下的<tt class="file docutils literal"><span class="pre">.gitconfig</span></tt>）或系统文件（<tt class="file docutils literal"><span class="pre">/etc/gitconfig</span></tt>）中做永久的记录。</p>
<ul>
<li><p class="first">告诉Git当前用户的姓名和邮件地址，配置的用户名和邮件地址将在版本库提交时作为提交者的用户名和邮件地址。</p>
<p>注意下面的两条命令不要照抄照搬，而是用您自己的用户名和邮件地址代替这里的用户名和邮件地址，否则您的劳动成果（提交内容）可要算到作者的头上了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git config --global user.name &quot;Jiang Xin&quot;
$ git config --global user.email jiangxin@ossxp.com
</pre></div>
</div>
</li>
<li><p class="first">设置一些Git别名，以便可以使用更为简洁的子命令。</p>
<p>例如：输入<strong class="command">git ci</strong>即相当于<strong class="command">git commit -s</strong><a class="footnote-reference" href="#id11" id="id2">[1]</a>，输入<strong class="command">git st</strong>即相当于<strong class="command">git -p status</strong><a class="footnote-reference" href="#id12" id="id3">[2]</a>。</p>
<ul>
<li><p class="first">如果拥有系统管理员权限（可以执行<strong class="command">sudo</strong>命令），希望注册的命令别名能够被所有用户使用，可以执行如下命令：</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo git config --system alias.br branch
$ sudo git config --system alias.ci &quot;commit -s&quot;
$ sudo git config --system alias.co checkout
$ sudo git config --system alias.st &quot;-p status&quot;
</pre></div>
</div>
</li>
<li><p class="first">也可以运行下面的命令，只在本用户的全局配置中添加Git命令别名：</p>
<div class="highlight-python"><div class="highlight"><pre>$ git config --global alias.st status
$ git config --global alias.ci &quot;commit -s&quot;
$ git config --global alias.co checkout
$ git config --global alias.br branch
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
<p>Git的所有操作，包括创建版本库等管理操作都用<strong class="command">git</strong>一个命令即可完成，不像其他有的版本控制系统（如Subversion），一些涉及管理的操作要使用另外的命令（如<strong class="command">svnadmin</strong>）。创建Git版本库，可以直接进入到包含数据（文件和子目录）的目录下，通过执行<strong class="command">git init</strong>完成版本库的初始化。</p>
<p>下面就从一个空目录开始初始化版本库，这个版本库命名为“demo”，这个DEMO版本库将贯穿本篇始终。为了方便说明，使用了名为<tt class="file docutils literal"><span class="pre">/path/to/my/workspace</span></tt>的目录作为个人的工作区根目录，您可以在磁盘中创建该目录并设置正确的权限。</p>
<p>首先建立一个新的工作目录，进入该目录后，执行<strong class="command">git init</strong>创建版本库。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cd /path/to/my/workspace
$ mkdir demo
$ cd demo
$ git init
初始化空的 Git 版本库于 /path/to/my/workspace/demo/.git/
</pre></div>
</div>
<p>实际上，如果Git的版本是1.6.5或更新的版本，可以在<strong class="command">git init</strong>命令的后面直接输入目录名称，自动完成目录的创建。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cd /path/to/my/workspace
$ git init demo
初始化空的 Git 版本库于 /path/to/my/workspace/demo/.git/
$ cd demo
</pre></div>
</div>
<p>从上面版本库初始化后的输出中，可以看到执行<strong class="command">git init</strong>命令在工作区创建了隐藏目录<tt class="file docutils literal"><span class="pre">.git</span></tt>。</p>
<div class="highlight-python"><div class="highlight"><pre>$ ls -aF
./  ../  .git/
</pre></div>
</div>
<p>这个隐藏的<tt class="file docutils literal"><span class="pre">.git</span></tt>目录就是Git版本库（又叫仓库，repository）。</p>
<p><tt class="file docutils literal"><span class="pre">.git</span></tt>版本库目录所在的目录，即<tt class="file docutils literal"><span class="pre">/path/to/my/workspace/demo</span></tt>目录称为<strong>工作区</strong>，目前工作区除了包含一个隐藏的file:<cite>.git</cite>版本库目录外空无一物。</p>
<p>下面为工作区中加点料：在工作区中创建一个文件<tt class="file docutils literal"><span class="pre">welcome.txt</span></tt>，内容就是一行“<tt class="docutils literal"><span class="pre">Hello.</span></tt>”。</p>
<div class="highlight-python"><div class="highlight"><pre>$ echo &quot;Hello.&quot; &gt; welcome.txt
</pre></div>
</div>
<p>为了将这个新建立的文件添加到版本库，需要执行下面的命令：</p>
<div class="highlight-python"><div class="highlight"><pre>$ git add welcome.txt
</pre></div>
</div>
<p>切记，到这里还没有完。Git和大部分其他版本控制系统都需要再执行一次提交操作，对于Git来说就是执行<strong class="command">git commit</strong>命令完成提交。在提交过程中需要输入提交说明，这个要求对于Git来说是强制性的，不像其他很多版本控制系统（如CVS、Subversion）允许空白的提交说明。在Git提交时，如果在命令行不提供提交说明（没有使用<tt class="docutils literal"><span class="pre">-m</span></tt>参数），Git会自动打开一个编辑器，要求您在其中输入提交说明，输入完毕保存退出。需要说明的是，读者要在一定程度上掌握vim或emacs这两种Linux下常用编辑器的编辑技巧，否则保存退出也会成为问题。</p>
<p>下面进行提交。为了说明方便，使用<tt class="docutils literal"><span class="pre">-m</span></tt>参数直接给出了提交说明。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git ci -m &quot;initialized&quot;
[master（根提交） 7e749cc] initialized
 1 个文件被修改，插入 1 行(+)
 create mode 100644 welcome.txt
</pre></div>
</div>
<p>从上面的命令及输出可以看出：</p>
<ul class="simple">
<li>使用了Git命令别名，即<strong class="command">git ci</strong>相当于执行<strong class="command">git commit</strong>。在本节的一开始就进行了Git命令别名的设置。</li>
<li>通过<tt class="docutils literal"><span class="pre">-m</span></tt>参数设置提交说明为：&#8221;initialized&#8221;。该提交说明也显示在命令输出的第一行中。</li>
<li>命令输出的第一行还显示了当前处于名为<tt class="docutils literal"><span class="pre">master</span></tt>的分支上，提交ID为7e749cc<a class="footnote-reference" href="#id13" id="id4">[3]</a>，且该提交是该分支的第一个提交，即根提交（root-commit）。根提交和其他提交的区别在于没有关联的父提交，这会在后面的章节中加以讨论。</li>
<li>命令输出的第二行开始显示本次提交所做修改的统计：修改了一个文件，包含一行的插入。</li>
</ul>
</div>
<div class="section" id="id5">
<h2>2.1.2. 思考：为什么工作区下有一个<tt class="file docutils literal"><span class="pre">.git</span></tt>目录？<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>Git及其他分布式版本控制系统（如Mercurial/Hg、Bazaar）的一个显著特点是，版本库位于工作区的根目录下。对于Git来说，版本库位于工作区根目录下的<tt class="file docutils literal"><span class="pre">.git</span></tt>目录中，且仅此一处，在工作区的子目录下则没有任何其他跟踪文件或目录。Git的这个设计要比CVS、Subversion这些传统的集中式版本控制工具来说方便多了。</p>
<p>看看版本控制系统前辈们是如何对工作区的跟踪进行设计的。通过其各自设计的优缺点，我们会更加深刻地体会到Git实现的必要和巧妙。</p>
<p>对于CVS，工作区的根目录及每一个子目录下都有一个<tt class="file docutils literal"><span class="pre">CVS</span></tt>目录，<tt class="file docutils literal"><span class="pre">CVS</span></tt>目录中包含几个配置文件，建立了对版本库的追踪。如<tt class="file docutils literal"><span class="pre">CVS</span></tt>目录下的<tt class="file docutils literal"><span class="pre">Entries</span></tt>文件记录了从版本库检出到工作区的文件的名称、版本和时间戳等，这样就可以通过对工作区文件时间戳的改变来判断文件是否更改。这样设计的好处是，可以将工作区移动到任何其他目录中，而工作区和版本控制服务器的映射关系保持不变，这样工作区依然能够正常工作。甚至还将工作区的某个子目录移动到其他位置，形成新的工作区，在新的工作区下仍然可以完成版本控制相关的操作。但是缺点也很多，例如工作区文件修改了，因为没有原始文件做比对，因此向服务器提交修改的时候只能对整个文件进行传输而不能仅传输文件的改动部分，导致从客户端到服务器的网络传输效率降低。还有一个风险是信息泄漏。例如Web服务器的目录下如果包含了<tt class="file docutils literal"><span class="pre">CVS</span></tt>目录，黑客就可以通过扫描<tt class="file docutils literal"><span class="pre">CVS/Entries</span></tt>文件得到目录下的文件列表，由此造成信息泄漏。</p>
<p>对于Subversion来说，工作区的根目录和每一个子目录下都有一个<tt class="file docutils literal"><span class="pre">.svn</span></tt>目录。目录<tt class="file docutils literal"><span class="pre">.svn</span></tt>中不但包含了类似CVS的跟踪目录下的配置文件，还包含了当前工作区下每一个文件的拷贝。多出文件的原始拷贝让某些svn命令可以脱离版本库执行，还可以在由客户端向服务器提交时，仅仅对文件改动的内容进行提交，因为改动的文件可以和原始拷贝进行差异比较。但是这么做的缺点除了像CVS因为引入<tt class="file docutils literal"><span class="pre">CVS</span></tt>跟踪目录而造成的信息泄漏的风险外，还导致了加倍占用工作区的空间。再有一个不方便的地方就是，当在工作区目录下针对文件内容进行搜索的时候，会因为<tt class="file docutils literal"><span class="pre">.svn</span></tt>目录下文件的原始拷贝，导致搜索的结果加倍，而出现混乱的搜索结果。</p>
<p>有的版本控制系统，在工作区根本就没有任何跟踪文件，例如，某款版本控制的商业软件（就不点名了），工作区就非常干净没有任何的配置文件和配置目录。但是这样的设计更加糟糕，因为它实际上是由服务器端建立的文件跟踪，在服务器端的数据库中保存了一个表格：哪台客户端，在哪个本地目录检出了哪个版本的版本库文件。这样做的后果是，如果客户端将工作区移动或改名会导致文件的跟踪状态丢失，出现文件状态未知的问题。客户端操作系统重装，也会导致文件跟踪状态丢失。</p>
<p>Git的这种设计，将版本库放在工作区根目录下，所有的版本控制操作（除了和其他远程版本库之间的互操作）都在本地即可完成，不像Subversion只有寥寥无几的几个命令才能脱离网络执行。而且Git也没有CVS和Subversion的安全泄漏问题（只要保护好<tt class="file docutils literal"><span class="pre">.git</span></tt>目录），也没有Subversion在本地文件搜索时出现搜索结果混乱的问题，甚至Git还提供了一条<strong class="command">git grep</strong>命令来更好地搜索工作区的文件内容。</p>
<p>例如作者在本书的Git库中执行下面的命令对版本库中的文件进行内容搜索：</p>
<div class="highlight-python"><div class="highlight"><pre>$ git grep &quot;工作区文件内容搜索&quot;
02-git-solo/010-git-init.rst::command:`git grep`\ 命令来更好地搜索工作区的文件内容。
</pre></div>
</div>
<p><strong>当工作区中包含了子目录，在子目录中执行Git命令时，如何定位版本库呢？</strong></p>
<p>实际上，当在Git工作区目录下执行操作的时候，会对目录依次向上递归查找<tt class="file docutils literal"><span class="pre">.git</span></tt> 目录，找到的<tt class="file docutils literal"><span class="pre">.git</span></tt>目录就是工作区对应的版本库，<tt class="file docutils literal"><span class="pre">.git</span></tt>所在的目录就是工作区的根目录，文件<tt class="file docutils literal"><span class="pre">.git/index</span></tt>记录了工作区文件的状态（实际上是暂存区的状态）。</p>
<p>例如在非Git工作区执行<strong class="command">git</strong>命令，会因为找不到<tt class="file docutils literal"><span class="pre">.git</span></tt>目录而报错。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cd /path/to/my/workspace/
$ git status
fatal: Not a git repository (or any of the parent directories): .git
</pre></div>
</div>
<p>如果跟踪一下执行<strong class="command">git status</strong>命令时的磁盘访问<a class="footnote-reference" href="#id14" id="id6">[4]</a>，会看到沿目录依次向上递归的过程。</p>
<div class="highlight-python"><div class="highlight"><pre>$ strace -e &#39;trace=file&#39; git status
...
getcwd(&quot;/path/to/my/workspace&quot;, 4096)           = 14
...
access(&quot;.git/objects&quot;, X_OK)            = -1 ENOENT (No such file or directory)
access(&quot;./objects&quot;, X_OK)               = -1 ENOENT (No such file or directory)
...
chdir(&quot;..&quot;)                             = 0
...
access(&quot;.git/objects&quot;, X_OK)            = -1 ENOENT (No such file or directory)
access(&quot;./objects&quot;, X_OK)               = -1 ENOENT (No such file or directory)
...
chdir(&quot;..&quot;)                             = 0
...
access(&quot;.git/objects&quot;, X_OK)            = -1 ENOENT (No such file or directory)
access(&quot;./objects&quot;, X_OK)               = -1 ENOENT (No such file or directory)
fatal: Not a git repository (or any of the parent directories): .git
</pre></div>
</div>
<p><strong>那么有什么办法知道Git版本库的位置，以及工作区的根目录在哪里呢？</strong></p>
<p>当在工作区执行<strong class="command">git</strong>命令时，上面查找版本库的操作总是默默地执行，就好像什么也没有发生的一样。如果希望显示工作区的根目录，Git有一个底层命令可以实现。</p>
<ul>
<li><p class="first">在工作区下建立目录<tt class="file docutils literal"><span class="pre">a/b/c</span></tt>，进入到该目录中。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cd /path/to/my/workspace/demo/
$ mkdir -p a/b/c
$ cd /path/to/my/workspace/demo/a/b/c
</pre></div>
</div>
</li>
<li><p class="first">显示版本库<tt class="file docutils literal"><span class="pre">.git</span></tt>目录所在的位置。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git rev-parse --git-dir
/path/to/my/workspace/demo/.git
</pre></div>
</div>
</li>
<li><p class="first">显示工作区根目录。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git rev-parse --show-toplevel
/path/to/my/workspace/demo
</pre></div>
</div>
</li>
<li><p class="first">相对于工作区根目录的相对目录。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git rev-parse --show-prefix
a/b/c/
</pre></div>
</div>
</li>
<li><p class="first">显示从当前目录（cd）后退（up）到工作区的根的深度。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git rev-parse --show-cdup
../../../
</pre></div>
</div>
</li>
</ul>
<p><strong>把版本库:file:`.git`目录放在工作区，是不是太不安全了？</strong></p>
<p>从存储安全的角度上来讲，将版本库放在工作区目录下，有点“把鸡蛋装在一个篮子里”的味道。如果忘记了工作区中还有版本库，直接从工作区的根执行目录删除就会连版本库一并删除，这个风险的确是蛮高的。将版本库和工作区拆开似乎更加安全，但是不要忘了之前的讨论，将版本库和工作区拆开，就要引入其他机制以便实现版本库对工作区的追踪。</p>
<p>Git克隆可以降低因为版本库和工作区混杂在一起导致的版本库被破坏的风险。可以通过克隆版本库，在本机另外的磁盘/目录中建立Git克隆，并在工作区有改动提交时，手动或自动地执行向克隆版本库的推送（<tt class="file docutils literal"><span class="pre">git</span> <span class="pre">push</span></tt>）操作。如果使用网络协议，还可以实现在其他机器上建立克隆，这样就更安全了（双机备份）。对于使用Git做版本控制的团队，每个人都是一个备份，因此团队开发中的Git版本库更安全，管理员甚至根本无须顾虑版本库存储安全问题。</p>
</div>
<div class="section" id="git-config">
<h2>2.1.3. 思考：<strong class="command">git config</strong>命令参数的区别？<a class="headerlink" href="#git-config" title="永久链接至标题">¶</a></h2>
<p>在之前出现的<strong class="command">git config</strong>命令，有的使用了<tt class="docutils literal"><span class="pre">--global</span></tt>参数，有的使用了<tt class="docutils literal"><span class="pre">--system</span></tt>参数，这两个参数有什么区别么？执行下面的命令，您就明白<strong class="command">git config`</strong> 命令实际操作的文件了。</p>
<ul>
<li><p class="first">执行下面的命令，将打开<tt class="file docutils literal"><span class="pre">/path/to/my/workspace/demo/.git/config</span></tt>文件进行编辑。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cd /path/to/my/workspace/demo/
$ git config -e
</pre></div>
</div>
</li>
<li><p class="first">执行下面的命令，将打开<tt class="file docutils literal"><span class="pre">/home/jiangxin/.gitconfig</span></tt>（用户主目录下的<tt class="file docutils literal"><span class="pre">.gitconfig</span></tt>文件）全局配置文件进行编辑。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git config -e --global
</pre></div>
</div>
</li>
<li><p class="first">执行下面的命令，将打开<tt class="file docutils literal"><span class="pre">/etc/gitconfig</span></tt>系统级配置文件进行编辑。</p>
<p>如果Git安装在<tt class="file docutils literal"><span class="pre">/usr/local/bin</span></tt>下，这个系统级的配置文件也可能是在<tt class="file docutils literal"><span class="pre">/usr/local/etc/gitconfig</span></tt>。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git config -e --system
</pre></div>
</div>
</li>
</ul>
<p>Git的三个配置文件分别是版本库级别的配置文件、全局配置文件（用户主目录下）和系统级配置文件（<tt class="file docutils literal"><span class="pre">/etc</span></tt>目录下）。其中版本库级别配置文件的优先级最高，全局配置文件其次，系统级配置文件优先级最低。这样的优先级设置就可以让版本库<tt class="file docutils literal"><span class="pre">.git</span></tt>目录下的<tt class="file docutils literal"><span class="pre">config</span></tt>文件中的配置可以覆盖用户主目录下的Git环境配置。而用户主目录下的配置也可以覆盖系统的Git配置文件。</p>
<p>执行前面的三个<strong class="command">git config</strong>命令，会看到这三个级别配置文件的格式和内容，原来Git配置文件采用的是INI文件格式。示例如下：</p>
<div class="highlight-python"><div class="highlight"><pre>$ cat /path/to/my/workspace/demo/.git/config
[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
</pre></div>
</div>
<p>命令<strong class="command">git config</strong>可以用于读取和更改INI配置文件的内容。使用命令<strong class="command">git config &lt;section&gt;.&lt;key&gt;</strong>，来读取INI配置文件中某个配置的键值。例如读取<tt class="docutils literal"><span class="pre">[core]</span></tt>小节的<tt class="docutils literal"><span class="pre">bare</span></tt>的属性值，可以用如下命令：</p>
<div class="highlight-python"><div class="highlight"><pre>$ git config core.bare
false
</pre></div>
</div>
<p>如果想更改或设置INI文件中某个属性的值也非常简单，命令格式是：<strong class="command">git config &lt;section&gt;.&lt;key&gt; &lt;value&gt;</strong>。可以用如下操作：</p>
<div class="highlight-python"><div class="highlight"><pre>$ git config a.b something
$ git config x.y.z others
</pre></div>
</div>
<p>如果打开<tt class="file docutils literal"><span class="pre">.git/config</span></tt>文件，会看到如下内容：</p>
<div class="highlight-python"><div class="highlight"><pre>[a]
        b = something

[x &quot;y&quot;]
        z = others
</pre></div>
</div>
<p>对于类似<tt class="docutils literal"><span class="pre">[x</span> <span class="pre">&quot;y&quot;]</span></tt>一样的配置小节，会在本书第三篇介绍远程版本库的章节中经常遇到。</p>
<p>从上面的介绍中，可以看到使用<strong class="command">git config</strong>命令可以非常方便地操作INI文件，实际上可以用<strong class="command">git config</strong>命令操作任何其他的INI文件。</p>
<ul>
<li><p class="first">向配置文件<tt class="file docutils literal"><span class="pre">test.ini</span></tt>中添加配置。</p>
<div class="highlight-python"><div class="highlight"><pre>$ GIT_CONFIG=test.ini git config a.b.c.d &quot;hello, world&quot;
</pre></div>
</div>
</li>
<li><p class="first">从配置文件<tt class="file docutils literal"><span class="pre">test.ini</span></tt>中读取配置。</p>
<div class="highlight-python"><div class="highlight"><pre>$ GIT_CONFIG=test.ini git config a.b.c.d
hello, world
</pre></div>
</div>
</li>
</ul>
<p>后面介绍的git-svn软件，就使用这个技术读写git-svn专有的配置文件。</p>
</div>
<div class="section" id="id7">
<h2>2.1.4. 思考：是谁完成的提交？<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>在本章的一开始，先为Git设置了<tt class="docutils literal"><span class="pre">user.name</span></tt>和<tt class="docutils literal"><span class="pre">user.email</span></tt>全局环境变量，如果不设置会有什么结果呢？</p>
<p>执行下面的命令，删除Git全局配置文件中关于<tt class="docutils literal"><span class="pre">user.name</span></tt>和<tt class="docutils literal"><span class="pre">user.email</span></tt>的设置：</p>
<div class="highlight-python"><div class="highlight"><pre>$ git config --unset --global user.name
$ git config --unset --global user.email
</pre></div>
</div>
<p>这下关于用户姓名和邮件的设置都被清空了，执行下面的命令将看不到输出。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git config user.name
$ git config user.email
</pre></div>
</div>
<p>下面再尝试进行一次提交，看看提交的过程会有什么不同，以及提交之后显示的提交者是谁？</p>
<p>在下面的命令中使用了<tt class="docutils literal"><span class="pre">--allow-empty</span></tt>参数，这是因为没有对工作区的文件进行任何修改，Git默认不会执行提交，使用了<tt class="docutils literal"><span class="pre">--allow-empty</span></tt>参数后，允许执行空白提交。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cd /path/to/my/workspace/demo
$ git commit --allow-empty -m &quot;who does commit?&quot;
[master 252dc53] who does commit?
 Committer: JiangXin &lt;jiangxin@hp.moon.ossxp.com&gt;
Your name and email address were configured automatically based
on your username and hostname. Please check that they are accurate.
You can suppress this message by setting them explicitly:

    git config --global user.name &quot;Your Name&quot;
    git config --global user.email you@example.com

If the identity used for this commit is wrong, you can fix it with:

    git commit --amend --author=&#39;Your Name &lt;you@example.com&gt;&#39;
</pre></div>
</div>
<p>喔，因为没有设置<tt class="docutils literal"><span class="pre">user.name</span></tt>和<tt class="docutils literal"><span class="pre">user.email</span></tt>变量，提交输出乱得一塌糊涂。仔细看看上面执行<tt class="docutils literal"><span class="pre">git</span> <span class="pre">commit</span></tt>命令的输出，原来Git提供了详细的帮助指引来告诉如何设置必需的变量，以及如何修改之前提交中出现的错误的提交者信息。</p>
<p>看看此时版本库的提交日志，会看到有两次提交。</p>
<p>注意：下面的输出和您的输出肯定会有所不同，一个是提交时间会不一样，再有就是由40位十六进制数字组成的提交ID也不可能一样，甚至本书中凡是您亲自完成的提交，相关的40位魔幻般的数字ID都会不一样（原因会在后面的章节看到）。因此凡是涉及数字ID和作者示例不一致的时候，以读者自己的数字ID为准，作者提供的仅是示例和参考，切记切记。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git log --pretty=fuller
commit 252dc539b5b5f9683edd54849c8e0a246e88979c
Author:     JiangXin &lt;jiangxin@hp.moon.ossxp.com&gt;
AuthorDate: Mon Nov 29 10:39:35 2010 +0800
Commit:     JiangXin &lt;jiangxin@hp.moon.ossxp.com&gt;
CommitDate: Mon Nov 29 10:39:35 2010 +0800

    who does commit?

commit 9e8a761ff9dd343a1380032884f488a2422c495a
Author:     Jiang Xin &lt;jiangxin@ossxp.com&gt;
AuthorDate: Sun Nov 28 12:48:26 2010 +0800
Commit:     Jiang Xin &lt;jiangxin@ossxp.com&gt;
CommitDate: Sun Nov 28 12:48:26 2010 +0800

    initialized.
</pre></div>
</div>
<p>最早的提交（下面的提交），提交者的信息是由之前设置的环境变量<tt class="docutils literal"><span class="pre">user.name</span></tt>和<tt class="docutils literal"><span class="pre">user.email</span></tt>给出的。而最新的提交（上面第一个提交）因为删除了<tt class="docutils literal"><span class="pre">user.name</span></tt>和<tt class="docutils literal"><span class="pre">user.email</span></tt>，提交时Git对提交者的用户名和邮件地址做了大胆的猜测，这个猜测可能是错的。</p>
<p>为了保证提交时提交者和作者信息的正确性，重新恢复<tt class="docutils literal"><span class="pre">user.name</span></tt>和<tt class="docutils literal"><span class="pre">user.email</span></tt>的设置。记住不要照抄照搬下面的命令，请使用您自己的用户名和邮件地址。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git config --global user.name &quot;Jiang Xin&quot;
$ git config --global user.email jiangxin@ossxp.com
</pre></div>
</div>
<p>然后执行下面的命令，重新修改最新的提交，改正作者和提交者的错误信息。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git commit --amend --allow-empty --reset-author
</pre></div>
</div>
<p>说明：</p>
<ul class="simple">
<li>参数<tt class="docutils literal"><span class="pre">--amend</span></tt>是对刚刚的提交进行修补，这样就可以改正前面错误的提交（用户信息错误），而不会产生另外的新提交。</li>
<li>参数<tt class="docutils literal"><span class="pre">--allow-empty</span></tt>是因为要进行修补的提交实际上是一个空白提交，Git默认不允许空白提交。</li>
<li>参数<tt class="docutils literal"><span class="pre">--reset-author</span></tt>的含义是将Author（提交者）的ID重置，否则只会影响最新的Commit（提交者）的ID。这条命令也会重置<tt class="docutils literal"><span class="pre">AuthorDate</span></tt>信息。</li>
</ul>
<p>通过日志，可以看到最新提交的作者和提交者的信息已经改正了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git log --pretty=fuller
commit a0c641e92b10d8bcca1ed1bf84ca80340fdefee6
Author:     Jiang Xin &lt;jiangxin@ossxp.com&gt;
AuthorDate: Mon Nov 29 11:00:06 2010 +0800
Commit:     Jiang Xin &lt;jiangxin@ossxp.com&gt;
CommitDate: Mon Nov 29 11:00:06 2010 +0800

    who does commit?

commit 9e8a761ff9dd343a1380032884f488a2422c495a
Author:     Jiang Xin &lt;jiangxin@ossxp.com&gt;
AuthorDate: Sun Nov 28 12:48:26 2010 +0800
Commit:     Jiang Xin &lt;jiangxin@ossxp.com&gt;
CommitDate: Sun Nov 28 12:48:26 2010 +0800

    initialized.
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>2.1.5. 思考：随意设置提交者姓名，是否太不安全？<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>使用过CVS、Subversion等集中式版本控制系统的用户会知道，每次提交的时候须要认证，认证成功后，登录ID就作为提交者ID出现在版本库的提交日志中。很显然，对于CVS或Subversion这样的版本控制系统，很难冒充他人提交。那么像Git这样的分布式版本控制系统，可以随心所欲的设定提交者，这似乎太不安全了。</p>
<p>Git可以随意设置提交的用户名和邮件地址信息，这是分布式版本控制系统的特性使然，每个人都是自己版本库的主人，很难也没有必要进行身份认证从而使用经过认证的用户名作为提交的用户名。</p>
<p>在进行“独奏”的时候，还要为自己强制加上一个“指纹识别”实在是太没有必要了。但是团队合作时授权就成为必需了。不过一般来说，设置的Git服务器只会在个人向服务器版本库执行推送操作（推送其本地提交）的时候进行身份认证，并不对所推送的提交本身所包含的用户名作出检查。但Android项目是个例外。</p>
<p>Android项目为了更好的使用Git实现对代码的集中管理，开发了一套叫做Gerrit的审核服务器来管理Git提交，对提交者的邮件地址进行审核。例如下面的示例中在向Gerrit服务器推送的时候，提交中的提交者邮件地址为<tt class="docutils literal"><span class="pre">jiangxin&#64;ossxp.com</span></tt>，但是在Gerrit中注册用户时使用的邮件地址为<tt class="docutils literal"><span class="pre">jiangxin&#64;moon.ossxp.com</span></tt>。因为两者不匹配，从而导致推送失败。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git push origin master
Counting objects: 3, done.
Writing objects: 100% (3/3), 222 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To ssh://localhost:29418/new/project.git
 ! [remote rejected] master -&gt; master (you are not committer jiangxin@ossxp.com)
error: failed to push some refs to &#39;ssh://localhost:29418/new/project.git&#39;
</pre></div>
</div>
<p>即使没有使用类似Gerrit的服务，作为提交者也不应该随意改变<tt class="docutils literal"><span class="pre">user.name</span></tt>和<tt class="docutils literal"><span class="pre">user.email</span></tt>的环境变量设置，因为当多人协同时这会给他人造成迷惑，也会给一些项目管理软件造成麻烦。</p>
<p>例如Redmine是一款实现需求管理和缺陷跟踪的项目管理软件，可以和Git版本库实现整合。Git的提交可以直接关闭Redmine上的Bug，还有Git的提交可以反映出项目成员的工作进度。Redmine中的用户（项目成员）是用一个ID做标识，而Git的提交者则用一个包含用户名和邮件地址的字符串，如何将Redmine的用户和Git提交者相关联呢？Redmine提供了一个配置界面用于设置二者之间的关系，如图4-1所示。</p>
<blockquote>
<div><div class="figure">
<a class="reference internal image-reference" href="../images/redmine-user-config.png"><img alt="../images/redmine-user-config.png" src="../images/redmine-user-config.png" style="width: 664.3px; height: 448.0px;" /></a>
<p class="caption">图 4‑1：Redmine中用户ID和Git提交者关联</p>
</div>
</div></blockquote>
<p>显然如果在Git提交时随意变更提交者的姓名和邮件地址，会破坏Redmine软件中设置好的用户对应关系。</p>
</div>
<div class="section" id="id9">
<h2>2.1.6. 思考：命令别名是干什么的？<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>在本章的一开始，通过对<tt class="docutils literal"><span class="pre">alias.ci</span></tt>等Git环境变量的设置，为Git设置了命令别名。命令别名可以帮助用户解决从其他版本控制系统迁移到Git后的使用习惯问题。像CVS和Subversion在提交的时候，一般习惯使用<tt class="docutils literal"><span class="pre">ci</span></tt>（check in）子命令，在检出的时候则习惯使用<tt class="docutils literal"><span class="pre">co</span></tt>（check out）子命令。如果Git不能提供对<tt class="docutils literal"><span class="pre">ci</span></tt>和<tt class="docutils literal"><span class="pre">co</span></tt>这类简洁命令的支持，对于拥有其他版本控制系统使用经验的用户来说，Git的用户体检就会打折扣。幸好聪明的Git提供了别名机制，可以满足用户特殊的使用习惯。</p>
<p>本章前面列出的四条别名设置指令，创建的是最常用的几个Git别名。实际上别名还可以包含命令参数。例如下面的别名设置指令：</p>
<div class="highlight-python"><div class="highlight"><pre>$ git config --global alias.ci &quot;commit -s&quot;
</pre></div>
</div>
<p>如上设置后，当使用<tt class="docutils literal"><span class="pre">git</span> <span class="pre">ci</span></tt>命令提交的时候，会自动带上<tt class="docutils literal"><span class="pre">-s</span></tt>参数，这样会在提交的说明中自动添加上包含提交者姓名和邮件地址的签名标识，类似于<tt class="docutils literal"><span class="pre">Signed-off-by:</span> <span class="pre">User</span> <span class="pre">Name</span> <span class="pre">&lt;email&#64;address&gt;</span></tt>。这对于一些项目（Git、Linux kernel、Android等）来说是必要甚至是必须的。</p>
<p>不过在本书会尽量避免使用别名命令，以免由于读者因为尚未设置别名而造成学习上的困惑。</p>
</div>
<div class="section" id="id10">
<h2>2.1.7. 备份本章的工作成果<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<p>执行下面的命令，算是对本章工作成果的备份。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cd /path/to/my/workspace
$ git clone demo demo-step-1
Cloning into demo-step-1...
done.
</pre></div>
</div>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>命令<strong class="command">git commit -s</strong>中的参数<tt class="docutils literal"><span class="pre">-s</span></tt>含义为在提交说明的最后添加“Signed-off-by:”签名。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>命令<strong class="command">git -p status</strong>中的参数<tt class="docutils literal"><span class="pre">-p</span></tt>含义是为<strong class="command">git status</strong>命令的输出添加分页器。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>大家实际操作中看到的ID肯定和这里写的不一样，具体原因会在后面的“6.1 Git对象库探秘”一节中予以介绍。如果碰巧您的操作显示出了同样的ID（78cde45），那么我建议您赶紧去买一张彩票。;)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[4]</a></td><td>示例中使用了Linux下的<strong class="command">strace</strong>命令跟踪系统调用，在Mac OS X下则可使用<strong class="command">sudo dtruss git status</strong>命令跟踪相关Git操作的系统调用。</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="020-git-stage.html" title="2.2. Git暂存区"
             >下一页</a> |</li>
        <li class="right" >
          <a href="index.html" title="2. Git独奏"
             >上一页</a> |</li>
        <li><a href="../index.html">GotGit</a> &raquo;</li>
          <li><a href="index.html" >2. Git独奏</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>
      <br />
      全部内容以 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons 署名-非商业性使用-相同方式共享 3.0 协议发布</a>.
      <br />
        &copy; Copyright 2011, 蒋鑫。
      使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3 创建。

    </div>
  </body>
</html>