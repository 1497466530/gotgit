
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2.6. 恢复进度 &mdash; GotGit</title>
    
    <link rel="stylesheet" href="../static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="/stylesheets/master.css" type="text/css" />
    <link rel="stylesheet" href="/stylesheets/syntax.css" type="text/css" />
    <link rel="stylesheet" href="../static/worldhello.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/translations.js"></script>
    <link rel="top" title="GotGit" href="../index.html" />
    <link rel="up" title="2. Git独奏" href="index.html" />
    <link rel="next" title="2.7. Git基本操作" href="070-git-basic.html" />
    <link rel="prev" title="2.5. Git检出" href="050-git-checkout.html" /> 
  </head>
  <body>
    <div id='header'>
      <h1><a href='/'>World Hello</a></h1>

      <div id='menu'>
        <ul>
          <li><a href='/' id='home-link' title='Home'>首页</a></li>
          <li><a href='/blog.html' id='blog-link' title='Blog'>博客</a></li>
          <li><a href='/doc/' id='docs-link' title='Docs'>文章</a></li>
          <li><a href='/about.html' id='about-link' title='About'>关于</a></li>
          <li><a href='http://github.com/gotgit' target='_blank' title='GitHub' rel='me' id='github-link'>GitHub</a></li>
          <li><a href='http://weibo.com/gotgit' title='微博' target='_blank' id='weibo-link'>微博</a></li>
        </ul>
      </div>
    </div>

    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="070-git-basic.html" title="2.7. Git基本操作"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="050-git-checkout.html" title="2.5. Git检出"
             accesskey="P">上一页</a> |</li>
        <li><a href="../index.html">GotGit</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">2. Git独奏</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">2.6. 恢复进度</a><ul>
<li><a class="reference internal" href="#id2">2.6.1. 继续暂存区未完成的实践</a></li>
<li><a class="reference internal" href="#git-stash">2.6.2. 使用<strong class="command">git stash</strong></a></li>
<li><a class="reference internal" href="#id3">2.6.3. 探秘<strong class="command">git stash</strong></a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="050-git-checkout.html"
                        title="上一章">2.5. Git检出</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="070-git-basic.html"
                        title="下一章">2.7. Git基本操作</a></p>
  <h3>本页</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/02-git-solo/060-git-stage-n-stash.txt"
           rel="nofollow">显示源代码</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>快速搜索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="转向" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    输入相关的术语，模块，类或者函数名称进行搜索
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>2.6. 恢复进度<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>在之前“Git暂存区”一章的结尾，曾经以终结者（The Terminator）的口吻说：“我会再回来”，会继续对暂存区的探索。经过了前面三章对Git对象、重置命令、检出命令的探索，现在已经拥有了足够多的武器，是时候“回归”了。</p>
<p>本章“回归”之后，再看Git状态输出中关于<strong class="command">git reset</strong>或者<strong class="command">git checkout</strong>的指示，有了前面几章的基础已经会觉得很亲切和易如反掌了。本章还会重点介绍“回归”使用的<strong class="command">git stash</strong>命令。</p>
<div class="section" id="id2">
<h2>2.6.1. 继续暂存区未完成的实践<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>经过了前面的实践，现在DEMO版本库应该处于master分支上，看看是不是这样。</p>
<div class="highlight-python"><div class="highlight"><pre>$ cd /path/to/my/workspace/demo
$ git status -sb       # Git 1.7.2 及以上版本才支持 -b 参数哦
## master
$ git log --graph --pretty=oneline --stat
*   2b31c199d5b81099d2ecd91619027ab63e8974ef Merge commit &#39;acc2f69&#39;
|\
| * acc2f69cf6f0ae346732382c819080df75bb2191 commit in detached HEAD mode.
| |  0 files changed, 0 insertions(+), 0 deletions(-)
* | 4902dc375672fbf52a226e0354100b75d4fe31e3 does master follow this new commit?
|/
|    0 files changed, 0 insertions(+), 0 deletions(-)
* e695606fc5e31b2ff9038a48a3d363f4c21a3d86 which version checked in?
|  welcome.txt |    1 +
|  1 files changed, 1 insertions(+), 0 deletions(-)
* a0c641e92b10d8bcca1ed1bf84ca80340fdefee6 who does commit?
* 9e8a761ff9dd343a1380032884f488a2422c495a initialized.
   welcome.txt |    1 +
   1 files changed, 1 insertions(+), 0 deletions(-)
</pre></div>
</div>
<p>还记得在之前“Git暂存区”一章的结尾，是如何保存进度的么？翻回去看一下，用的是<strong class="command">git stash</strong>命令。这个命令用于保存当前进度，也是恢复进度要用的命令。</p>
<p>查看保存的进度用命令<strong class="command">git stash list</strong>。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git stash list
stash@{0}: WIP on master: e695606 which version checked in?
</pre></div>
</div>
<p>现在就来恢复进度。使用<strong class="command">git stash pop</strong>从最近保存的进度进行恢复。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git stash pop
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       new file:   a/b/c/hello.txt
#
# Changes not staged for commit:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#       modified:   welcome.txt
#
Dropped refs/stash@{0} (c1bd56e2565abd64a0d63450fe42aba23b673cf3)
</pre></div>
</div>
<p>先不要管<strong class="command">git stash pop</strong>命令的输出，后面会专题介绍<strong class="command">git stash</strong>命令。通过查看工作区的状态，可以发现进度已经找回了（状态和进度保存前稍有不同）。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       new file:   a/b/c/hello.txt
#
# Changes not staged for commit:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#       modified:   welcome.txt
#
</pre></div>
</div>
<p>此时再看Git状态输出，是否别有一番感觉呢？有了前面三章的基础，现在可以游刃有余的应对各种情况了。</p>
<ul>
<li><p class="first">以当前暂存区状态进行提交，即只提交<tt class="file docutils literal"><span class="pre">a/b/c/hello.txt</span></tt>，不提交<tt class="file docutils literal"><span class="pre">welcome.txt</span></tt>。</p>
<ul>
<li><p class="first">执行提交：</p>
<div class="highlight-python"><div class="highlight"><pre>$ git commit -m &quot;add new file: a/b/c/hello.txt, but leave welcome.txt alone.&quot;
[master 6610d05] add new file: a/b/c/hello.txt, but leave welcome.txt alone.
 1 files changed, 2 insertions(+), 0 deletions(-)
 create mode 100644 a/b/c/hello.txt
</pre></div>
</div>
</li>
<li><p class="first">查看提交后的状态：</p>
<div class="highlight-python"><div class="highlight"><pre>$ git status -s
 M welcome.txt
</pre></div>
</div>
</li>
</ul>
</li>
<li><p class="first">反悔了，回到之前的状态。</p>
<ul>
<li><p class="first">用重置命令放弃最新的提交：</p>
<div class="highlight-python"><div class="highlight"><pre>$ git reset --soft HEAD^
</pre></div>
</div>
</li>
<li><p class="first">查看最新的提交日志，可以看到前面的提交被抛弃了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git log -1 --pretty=oneline
2b31c199d5b81099d2ecd91619027ab63e8974ef Merge commit &#39;acc2f69&#39;
</pre></div>
</div>
</li>
<li><p class="first">工作区和暂存区的状态也都维持原来的状态。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git status -s
A  a/b/c/hello.txt
 M welcome.txt
</pre></div>
</div>
</li>
</ul>
</li>
<li><p class="first">想将<tt class="file docutils literal"><span class="pre">welcome.txt</span></tt>提交。</p>
<p>再简单不过了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git add welcome.txt
$ git status -s
A  a/b/c/hello.txt
M  welcome.txt
</pre></div>
</div>
</li>
<li><p class="first">想将<tt class="file docutils literal"><span class="pre">a/b/c/hello.txt</span></tt>撤出暂存区。</p>
<p>也是用重置命令。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git reset HEAD a/b/c
$ git status -s
M  welcome.txt
?? a/
</pre></div>
</div>
</li>
<li><p class="first">想将剩下的文件（<tt class="file docutils literal"><span class="pre">welcome.txt</span></tt>）从暂存区撤出，就是说不想提交任何东西了。</p>
<p>还是使用重置命令，甚至可以不使用任何参数。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git reset
Unstaged changes after reset:
M       welcome.txt
</pre></div>
</div>
</li>
<li><p class="first">想将本地工作区所有的修改清除。即清除<tt class="file docutils literal"><span class="pre">welcome.txt</span></tt>的改动，删除添加的目录<tt class="file docutils literal"><span class="pre">a</span></tt>即下面的子目录和文件。</p>
<ul>
<li><p class="first">清除<tt class="file docutils literal"><span class="pre">welcome.txt</span></tt>的改动用检出命令。</p>
<p>实际对于此例执行<strong class="command">git checkout .</strong>也可以。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git checkout -- welcome.txt
</pre></div>
</div>
</li>
<li><p class="first">工作区显示还有一个多余的目录<tt class="file docutils literal"><span class="pre">a</span></tt>。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git status
# On branch master
# Untracked files:
#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
#
#       a/
</pre></div>
</div>
</li>
<li><p class="first">删除本地多余的目录和文件，可以使用<strong class="command">git clean</strong>命令。先来测试运行以便看看哪些文件和目录会被删除，以免造成误删。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git clean -nd
Would remove a/
</pre></div>
</div>
</li>
<li><p class="first">真正开始强制删除多余的目录和文件。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git clean -fd
Removing a/
</pre></div>
</div>
</li>
<li><p class="first">整个世界清净了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git status -s
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="git-stash">
<h2>2.6.2. 使用<strong class="command">git stash</strong><a class="headerlink" href="#git-stash" title="永久链接至标题">¶</a></h2>
<p>命令<strong class="command">git stash</strong>可以用于保存和恢复工作进度，掌握这个命令对于日常的工作会有很大的帮助。关于这个命令的最主要的用法实际上通过前面的演示已经了解了。</p>
<ul>
<li><p class="first">命令：<strong class="command">git stash</strong></p>
<p>保存当前工作进度。会分别对暂存区和工作区的状态进行保存。</p>
</li>
<li><p class="first">命令：<strong class="command">git stash list</strong></p>
<p>显示进度列表。此命令显然暗示了<strong class="command">git stash</strong>可以多次保存工作进度，并且在恢复的时候进行选择。</p>
</li>
<li><p class="first">命令：<strong class="command">git stash pop [&#8211;index] [&lt;stash&gt;]</strong></p>
<p>如果不使用任何参数，会恢复最新保存的工作进度，并将恢复的工作进度从存储的工作进度列表中清除。</p>
<p>如果提供<tt class="docutils literal"><span class="pre">&lt;stash&gt;</span></tt>参数（来自于<strong class="command">git stash list</strong>显示的列表），则从该<tt class="docutils literal"><span class="pre">&lt;stash&gt;</span></tt>中恢复。恢复完毕也将从进度列表中删除<tt class="docutils literal"><span class="pre">&lt;stash&gt;</span></tt>。</p>
<p>选项<tt class="docutils literal"><span class="pre">--index</span></tt>除了恢复工作区的文件外，还尝试恢复暂存区。这也就是为什么在本章一开始恢复进度的时候显示的状态和保存进度前略有不同。</p>
</li>
</ul>
<p>实际上还有几个用法也很有用。</p>
<ul>
<li><p class="first">命令：<strong class="command">git stash [save [&#8211;patch] [-k|&#8211;[no-]keep-index] [-q|&#8211;quiet] [&lt;message&gt;]]</strong></p>
<ul>
<li><p class="first">这条命令实际上是第一条<strong class="command">git stash</strong>命令的完整版。即如果需要在保存工作进度的时候使用指定的说明，必须使用如下格式：</p>
<div class="highlight-python"><div class="highlight"><pre>git stash save &quot;message...&quot;
</pre></div>
</div>
</li>
<li><p class="first">使用参数<tt class="docutils literal"><span class="pre">--patch</span></tt>会显示工作区和HEAD的差异，通过对差异文件的编辑决定在进度中最终要保存的工作区的内容，通过编辑差异文件可以在进度中排除无关内容。</p>
</li>
<li><p class="first">使用<tt class="docutils literal"><span class="pre">-k</span></tt>或者<tt class="docutils literal"><span class="pre">--keep-index</span></tt>参数，在保存进度后不会将暂存区重置。缺省会将暂存区和工作区强制重置。</p>
</li>
</ul>
</li>
<li><p class="first">命令：<strong class="command">git stash apply [&#8211;index] [&lt;stash&gt;]</strong></p>
<p>除了不删除恢复的进度之外，其余和<strong class="command">git stash pop</strong>命令一样。</p>
</li>
<li><p class="first">命令：<strong class="command">git stash drop [&lt;stash&gt;]</strong></p>
<p>删除一个存储的进度。缺省删除最新的进度。</p>
</li>
<li><p class="first">命令：<strong class="command">git stash clear</strong></p>
<p>删除所有存储的进度。</p>
</li>
<li><p class="first">命令：<strong class="command">git stash branch &lt;branchname&gt; &lt;stash&gt;</strong></p>
<p>基于进度创建分支。对了，还没有讲到分支呢。;)</p>
</li>
</ul>
</div>
<div class="section" id="id3">
<h2>2.6.3. 探秘<strong class="command">git stash</strong><a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>了解一下<strong class="command">git stash</strong>的机理会有几个好处：当保存了多个进度的时候知道从哪个进度恢复；综合运用前面介绍的Git知识点；了解Git的源码，Git将不再神秘。</p>
<p>在执行<strong class="command">git stash</strong>命令时，Git实际调用了一个脚本文件实现相关的功能，这个脚本的文件名就是<tt class="file docutils literal"><span class="pre">git-stash</span></tt>。看看<tt class="file docutils literal"><span class="pre">git-stash</span></tt>安装在哪里了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git --exec-path
/usr/lib/git-core
</pre></div>
</div>
<p>如果检查一下这个目录，会震惊的。</p>
<div class="highlight-python"><div class="highlight"><pre>$ ls /usr/lib/git-core/
git                    git-help                 git-reflog
git-add                git-http-backend         git-relink
git-add--interactive   git-http-fetch           git-remote
git-am                 git-http-push            git-remote-ftp
git-annotate           git-imap-send            git-remote-ftps
git-apply              git-index-pack           git-remote-http
..................
... 省略40余行 ...
..................
</pre></div>
</div>
<p>实际上在1.5.4之前的版本，Git会安装这些一百多个以<strong class="command">git-&lt;cmd&gt;</strong>格式命名的程序到可执行路径中。这样做的唯一好处就是不用借助任何扩展机制就可以实现命令行补齐：即键入<tt class="docutils literal"><span class="pre">git-</span></tt>后，连续两次键入<tt class="docutils literal"><span class="pre">&lt;Tab&gt;</span></tt>键，就可以把这一百多个命令显示出来。这种方式随着Git子命令的增加越来越显得混乱，因此在1.5.4版本开始，不再提供<strong class="command">git-&lt;cmd&gt;</strong>格式的命令，而是用唯一的<strong class="command">git</strong>命令。而之前的名为<strong class="command">git-&lt;cmd&gt;</strong>的子命令则保存在非可执行目录下，由Git负责加载。</p>
<p>在后面的章节中偶尔会看到形如<strong class="command">git-&lt;cmd&gt;</strong>字样的名称，以及同时存在的<strong class="command">git &lt;cmd&gt;</strong>命令。可以这样理解：<strong class="command">git-&lt;cmd&gt;</strong>作为软件本身的名称，而其命令行为<strong class="command">git &lt;cmd&gt;</strong>。</p>
<p>最早很多Git命令都是用Shell或者Perl脚本语言开发的，在Git的发展中一些对运行效率要求高的命令用C语言改写。而<tt class="file docutils literal"><span class="pre">git-stash</span></tt>（至少在Git 1.7.3.2版本）还是使用Shell脚本开发的，研究它会比研究用C写的命令要简单的多。</p>
<div class="highlight-python"><div class="highlight"><pre>$ file /usr/lib/git-core/git-stash
/usr/lib/git-core/git-stash: POSIX shell script text executable
</pre></div>
</div>
<p>解析<tt class="file docutils literal"><span class="pre">git-stash</span></tt>脚本会比较枯燥，还是通过运行一些示例更好一些。</p>
<p>当前的进度保存列表是空的。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git stash list
</pre></div>
</div>
<p>下面在工作区中做一些改动。</p>
<div class="highlight-python"><div class="highlight"><pre>$ echo Bye-Bye. &gt;&gt; welcome.txt
$ echo hello. &gt; hack-1.txt
$ git add hack-1.txt
$ git status -s
A  hack-1.txt
 M welcome.txt
</pre></div>
</div>
<p>可见暂存区中已经添加了新增的<tt class="file docutils literal"><span class="pre">hack-1.txt</span></tt>，修改过的<tt class="file docutils literal"><span class="pre">welcome.txt</span></tt>并未添加到暂存区。执行<strong class="command">git stash</strong>保存一下工作进度。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git stash save &quot;hack-1: hacked welcome.txt, newfile hack-1.txt&quot;
Saved working directory and index state On master: hack-1: hacked welcome.txt, newfile hack-1.txt
HEAD is now at 2b31c19 Merge commit &#39;acc2f69&#39;
</pre></div>
</div>
<p>再来看工作区恢复了修改前的原貌（实际上用了 git reset &#8211;hard HEAD 命令），文件<tt class="file docutils literal"><span class="pre">welcome.txt</span></tt>的修改不见了，文件<tt class="file docutils literal"><span class="pre">hack-1.txt</span></tt>整个都不见了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git status -s
$ ls
detached-commit.txt  new-commit.txt  welcome.txt
</pre></div>
</div>
<p>再做一个修改，并尝试保存进度。</p>
<div class="highlight-python"><div class="highlight"><pre>$ echo fix. &gt; hack-2.txt
$ git stash
No local changes to save
</pre></div>
</div>
<p>进度保存失败！可见本地没有被版本控制系统跟踪的文件并不能保存进度。因此本地新文件需要执行添加再执行<strong class="command">git stash</strong>命令。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git add hack-2.txt
$ git stash
Saved working directory and index state WIP on master: 2b31c19 Merge commit &#39;acc2f69&#39;
HEAD is now at 2b31c19 Merge commit &#39;acc2f69&#39;
</pre></div>
</div>
<p>不用看就知道工作区再次恢复原状。如果这时执行<strong class="command">git stash list</strong>会看到有两次进度保存。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git stash list
stash@{0}: WIP on master: 2b31c19 Merge commit &#39;acc2f69&#39;
stash@{1}: On master: hack-1: hacked welcome.txt, newfile hack-1.txt
</pre></div>
</div>
<p>从上面的输出可以得出两个结论：</p>
<ul class="simple">
<li>在用<strong class="command">git stash</strong>命令保存进度时，提供说明更容易找到对应的进度文件。</li>
<li>每个进度的标识都是<tt class="docutils literal"><span class="pre">stash&#64;{&lt;n&gt;}</span></tt>格式，像极了前面介绍的reflog的格式。</li>
</ul>
<p>实际上，<strong class="command">git stash</strong>的就是用到了前面介绍的引用和引用变更日志（reflog）来实现的。</p>
<div class="highlight-python"><div class="highlight"><pre>$ ls -l .git/refs/stash .git/logs/refs/stash
-rw-r--r-- 1 jiangxin jiangxin 364 Dec  6 16:11 .git/logs/refs/stash
-rw-r--r-- 1 jiangxin jiangxin  41 Dec  6 16:11 .git/refs/stash
</pre></div>
</div>
<p>那么在“Git重置”一章中学习的reflog可以派上用场了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git reflog show refs/stash
e5c0cdc refs/stash@{0}: WIP on master: 2b31c19 Merge commit &#39;acc2f69&#39;
6cec9db refs/stash@{1}: On master: hack-1: hacked welcome.txt, newfile hack-1.txt
</pre></div>
</div>
<p>对照<strong class="command">git reflog</strong>的结果和前面<strong class="command">git stash list</strong>的结果，可以肯定用<strong class="command">git stash</strong>保存进度，实际上会将进度保存在引用<tt class="docutils literal"><span class="pre">refs/stash</span></tt>所指向的提交中。多次的进度保存，实际上相当于引用<tt class="docutils literal"><span class="pre">refs/stash</span></tt>一次又一次的变化，而<tt class="docutils literal"><span class="pre">refs/stash</span></tt>引用的变化由reflog（即<strong class="command">.git/logs/refs/stash</strong>）所记录下来。这个实现是多么的简单而巧妙啊。</p>
<p>新的一个疑问又出现了，如何在引用<tt class="docutils literal"><span class="pre">refs/stash</span></tt>中同时保存暂存区的进度和工作区中的进度呢？查看一下引用<tt class="docutils literal"><span class="pre">refs/stash</span></tt>的提交历史能够看出端倪。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git log --graph --pretty=raw  refs/stash -2
*   commit e5c0cdc2dedc3e50e6b72a683d928e19a1d9de48
|\  tree 780c22449b7ff67e2820e09a6332c360ddc80578
| | parent 2b31c199d5b81099d2ecd91619027ab63e8974ef
| | parent c5edbdcc90addb06577ff60f644acd1542369194
| | author Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291623066 +0800
| | committer Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291623066 +0800
| |
| |     WIP on master: 2b31c19 Merge commit &#39;acc2f69&#39;
| |
| * commit c5edbdcc90addb06577ff60f644acd1542369194
|/  tree 780c22449b7ff67e2820e09a6332c360ddc80578
|   parent 2b31c199d5b81099d2ecd91619027ab63e8974ef
|   author Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291623066 +0800
|   committer Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291623066 +0800
|
|       index on master: 2b31c19 Merge commit &#39;acc2f69&#39;
</pre></div>
</div>
<p>可以看到在提交关系图可以看到进度保存的最新提交是一个合并提交。最新的提交说明中有<tt class="docutils literal"><span class="pre">WIP</span></tt>字样（是Work In Progess的简称），说明代表了工作区进度。而最新提交的第二个父提交（上图中显示为第二个提交）有<tt class="docutils literal"><span class="pre">index</span> <span class="pre">on</span> <span class="pre">master</span></tt>字样，说明这个提交代表着暂存区的进度。</p>
<p>但是上图中的两个提交都指向了同一个树——tree ``780c224``...，这是因为最后一次做进度保存时工作区相对暂存区没有改变，这让关于工作区和暂存区在引用<tt class="docutils literal"><span class="pre">refs/stash</span></tt>中的存储变得有些扑朔迷离。别忘了第一次进度保存工作区、暂存区和版本库都是不同的，可以用于验证关于<tt class="docutils literal"><span class="pre">refs/stash</span></tt>实现机制的判断。</p>
<p>第一次进度保存可以用reflog中的语法，即用<tt class="docutils literal"><span class="pre">refs/stash&#64;{1}</span></tt>来访问，也可以用简称<tt class="docutils literal"><span class="pre">stash&#64;{1}</span></tt>。下面就用第一次的进度保存来研究一下。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git log --graph --pretty=raw  stash@{1} -3
*   commit 6cec9db44af38d01abe7b5025a5190c56fd0cf49
|\  tree 7250f186c6aa3e2d1456d7fa915e529601f21d71
| | parent 2b31c199d5b81099d2ecd91619027ab63e8974ef
| | parent 4560d76c19112868a6a5692bf9379de09c0452b7
| | author Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291622767 +0800
| | committer Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291622767 +0800
| |
| |     On master: hack-1: hacked welcome.txt, newfile hack-1.txt
| |
| * commit 4560d76c19112868a6a5692bf9379de09c0452b7
|/  tree 5d4dd328187e119448c9171f99cf2e507e91a6c6
|   parent 2b31c199d5b81099d2ecd91619027ab63e8974ef
|   author Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291622767 +0800
|   committer Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291622767 +0800
|
|       index on master: 2b31c19 Merge commit &#39;acc2f69&#39;
|
*   commit 2b31c199d5b81099d2ecd91619027ab63e8974ef
|\  tree ab676f92936000457b01507e04f4058e855d4df0
| | parent 4902dc375672fbf52a226e0354100b75d4fe31e3
| | parent acc2f69cf6f0ae346732382c819080df75bb2191
| | author Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291535485 +0800
| | committer Jiang Xin &lt;jiangxin@ossxp.com&gt; 1291535485 +0800
| |
| |     Merge commit &#39;acc2f69&#39;
</pre></div>
</div>
<p>果然上面显示的三个提交对应的三棵树各不相同。查看一下差异。用“原基线”代表进度保存时版本库的状态，即提交<tt class="docutils literal"><span class="pre">2b31c199</span></tt>；用“原暂存区”代表进度保存时暂存区的状态，即提交<tt class="docutils literal"><span class="pre">4560d76</span></tt>；用“原工作区”代表进度保存时工作区的状态，即提交<tt class="docutils literal"><span class="pre">6cec9db</span></tt>。</p>
<ul>
<li><p class="first">原基线和原暂存区的差异比较。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git diff stash@{1}^2^ stash@{1}^2
diff --git a/hack-1.txt b/hack-1.txt
new file mode 100644
index 0000000..25735f5
--- /dev/null
+++ b/hack-1.txt
@@ -0,0 +1 @@
+hello.
</pre></div>
</div>
</li>
<li><p class="first">原暂存区和原工作区的差异比较。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git diff stash@{1}^2 stash@{1}
diff --git a/welcome.txt b/welcome.txt
index fd3c069..51dbfd2 100644
--- a/welcome.txt
+++ b/welcome.txt
@@ -1,2 +1,3 @@
 Hello.
 Nice to meet you.
+Bye-Bye.
</pre></div>
</div>
</li>
<li><p class="first">原基线和原工作区的差异比较。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git diff stash@{1}^1 stash@{1}
diff --git a/hack-1.txt b/hack-1.txt
new file mode 100644
index 0000000..25735f5
--- /dev/null
+++ b/hack-1.txt
@@ -0,0 +1 @@
+hello.
diff --git a/welcome.txt b/welcome.txt
index fd3c069..51dbfd2 100644
--- a/welcome.txt
+++ b/welcome.txt
@@ -1,2 +1,3 @@
 Hello.
 Nice to meet you.
+Bye-Bye.
</pre></div>
</div>
</li>
</ul>
<p>从<tt class="docutils literal"><span class="pre">stash&#64;{1}</span></tt>来恢复进度。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git stash apply stash@{1}
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       new file:   hack-1.txt
#
# Changes not staged for commit:
#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
#
#       modified:   welcome.txt
#
</pre></div>
</div>
<p>显示进度列表，然后删除进度列表。</p>
<div class="highlight-python"><div class="highlight"><pre>$ git stash list
stash@{0}: WIP on master: 2b31c19 Merge commit &#39;acc2f69&#39;
stash@{1}: On master: hack-1: hacked welcome.txt, newfile hack-1.txt
$ git stash clear
</pre></div>
</div>
<p>删除进度列表之后，会发现stash相关的引用和reflog也都不见了。</p>
<div class="highlight-python"><div class="highlight"><pre>$ ls -l .git/refs/stash .git/logs/refs/stash
ls: cannot access .git/refs/stash: No such file or directory
ls: cannot access .git/logs/refs/stash: No such file or directory
</pre></div>
</div>
<p>通过上面的这些分析，有一定Shell编程基础的读者就可以尝试研究<tt class="docutils literal"><span class="pre">git-stash</span></tt>的代码了，可能会有新的发现。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="070-git-basic.html" title="2.7. Git基本操作"
             >下一页</a> |</li>
        <li class="right" >
          <a href="050-git-checkout.html" title="2.5. Git检出"
             >上一页</a> |</li>
        <li><a href="../index.html">GotGit</a> &raquo;</li>
          <li><a href="index.html" >2. Git独奏</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>
      <br />
      全部内容以 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons 署名-非商业性使用-相同方式共享 3.0 协议发布</a>.
      <br />
        &copy; Copyright 2011, 蒋鑫。
      使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3 创建。

    </div>
  </body>
</html>